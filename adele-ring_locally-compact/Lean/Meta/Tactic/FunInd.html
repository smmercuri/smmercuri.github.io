<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Tactic.FunInd</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Lean.Meta.Tactic.FunInd";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Lean/Elab/Command.html">Lean.Elab.Command</a></li><li><a href="../../.././Lean/Meta/ArgsPacker.html">Lean.Meta.ArgsPacker</a></li><li><a href="../../.././Lean/Meta/Basic.html">Lean.Meta.Basic</a></li><li><a href="../../.././Lean/Meta/Check.html">Lean.Meta.Check</a></li><li><a href="../../.././Lean/Meta/Injective.html">Lean.Meta.Injective</a></li><li><a href="../../.././Lean/Meta/Tactic/Cleanup.html">Lean.Meta.Tactic.Cleanup</a></li><li><a href="../../.././Lean/Meta/Tactic/ElimInfo.html">Lean.Meta.Tactic.ElimInfo</a></li><li><a href="../../.././Lean/Meta/Tactic/Subst.html">Lean.Meta.Tactic.Subst</a></li><li><a href="../../.././Lean/Elab/PreDefinition/Structural/Eqns.html">Lean.Elab.PreDefinition.Structural.Eqns</a></li><li><a href="../../.././Lean/Elab/PreDefinition/WF/Eqns.html">Lean.Elab.PreDefinition.WF.Eqns</a></li><li><a href="../../.././Lean/Meta/Match/MatcherApp/Transform.html">Lean.Meta.Match.MatcherApp.Transform</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Tactic.FunInd" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.removeLamda"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">removeLamda</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.mkFst"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">mkFst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.mkSnd"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">mkSnd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.isPProdProj"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">isPProdProj</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.isPProdProjWithArgs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">isPProdProjWithArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.foldCalls"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">foldCalls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.collectIHs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">collectIHs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.deduplicateIHs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deduplicateIHs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.assertIHs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">assertIHs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.substVarAfter"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">substVarAfter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.M"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.buildInductionCase"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">buildInductionCase</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.mkLambdaFVarsMasked"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">mkLambdaFVarsMasked</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.maskArray"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">maskArray</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.buildInductionBody"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">buildInductionBody</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.abstractIndependentMVars"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">abstractIndependentMVars</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.motiveUniverseParamPos"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">motiveUniverseParamPos</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.findRecursor"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">findRecursor</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.findRecursor.err"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">findRecursor</span>.<span class="name">err</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.deriveUnaryInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveUnaryInduction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.cleanPackedArgs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanPackedArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.unpackMutualInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">unpackMutualInduction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.deriveUnpackedInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveUnpackedInduction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.deriveInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveInduction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Tactic.FunInd.isFunInductName"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">isFunInductName</span></a></div></nav><main>
<div class="mod_doc"><p>This module contains code to derive, from the definition of a recursive function (structural or
well-founded, possibly mutual), a <strong>functional induction principle</strong> tailored to proofs about that
function(s).</p><p>For example from:</p><pre><code>def ackermann : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../.././Init/Prelude.html#Nat">Nat</a>
  | 0, m =&gt; m + 1
  | n+1, 0 =&gt; ackermann n 1
  | n+1, m+1 =&gt; ackermann n (ackermann (n + 1) m)
</code></pre><p>we get</p><pre><code>ackermann.induct (motive : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../.././Init/Prelude.html#Nat">Nat</a> → Prop) (case1 : ∀ (m : Nat), motive 0 m)
  (case2 : ∀ (n : Nat), motive n 1 → motive (Nat.succ n) 0)
  (case3 : ∀ (n m : Nat), motive (n + 1) m → motive n (ackermann (n + 1) m) → motive (Nat.succ n) (Nat.succ m))
  (x x : Nat) : motive x x
</code></pre><h2 class="markdown-heading" id="Specification">Specification <a class="hover-link" href="#Specification">#</a></h2><p>The functional induction principle takes the same fixed parameters as the function, and
the motive takes the same non-fixed parameters as the original function.</p><p>For each branch of the original function, there is a case in the induction principle.
Here &quot;branch&quot; roughly corresponds to tail-call positions: branches of top-level
<code>if</code>-<code>then</code>-<code>else</code> and of <code>match</code> expressions.</p><p>For every recursive call in that branch, an induction hypothesis asserting the
motive for the arguments of the recursive call is provided.
If the recursive call is under binders and it, or its proof of termination,
depend on the the bound values, then these become assumptions of the inductive
hypothesis.</p><p>Additionally, the local context of the branch (e.g. the condition of an
if-then-else; a let-binding, a have-binding) is provided as assumptions in the
corresponding induction case, if they are likely to be useful (as determined
by <code>MVarId.cleanup</code>).</p><p>Mutual recursion is supported and results in multiple motives.</p><h2 class="markdown-heading" id="Implementation-overview-well-founded-recursion">Implementation overview (well-founded recursion) <a class="hover-link" href="#Implementation-overview-well-founded-recursion">#</a></h2><p>For a non-mutual, unary function <code>foo</code> (or else for the <code>_unary</code> function), we</p><ol>
<li><p>expect its definition, possibly after some <code>whnf</code>’ing, to be of the form</p>
<pre><code>def foo := fun x₁ … xₙ (y : a) =&gt; <a href="../../.././Init/WF.html#WellFounded.fix">WellFounded.fix</a> (fun y' oldIH =&gt; body) y
</code></pre>
<p>where <code>xᵢ…</code> are the fixed parameter prefix and <code>y</code> is the varying parameter of
the function.</p>
</li>
<li><p>From this structure we derive the type of the motive, and start assembling the induction
principle:</p>
<pre><code>def foo.induct := fun x₁ … xₙ (motive : (y : a) → Prop) =&gt;
 fix (fun y' newIH =&gt; T[body])
</code></pre>
</li>
<li><p>The first phase, transformation <code>T1[body]</code> (implemented in) <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody">buildInductionBody</a></code>,
mirrors the branching structure of <code>foo</code>, i.e. replicates <code><a href="../../.././Init/Prelude.html#dite">dite</a></code> and some matcher applications,
while adjusting their motive. It also unfolds calls to <code>oldIH</code> and collects induction hypotheses
in conditions (see below).</p>
<p>In particular, when translating a <code>match</code> it is prepared to recognize the idiom
as introduced by <code>mkFix</code> via <code><a href="../../.././Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.addArg?">Lean.Meta.MatcherApp.addArg?</a></code>, which refines the type of <code>oldIH</code>
throughout the match. The transformation will replace <code>oldIH</code> with <code>newIH</code> here.</p>
<pre><code>     T[(match (motive := fun oldIH =&gt; …) y with | … =&gt; fun oldIH' =&gt; body) oldIH]
 ==&gt; (match (motive := fun newIH =&gt; …) y with | … =&gt; fun newIH' =&gt; T[body]) newIH
</code></pre>
<p>In addition, the information gathered from the match is preserved, so that when performing the
proof by induction, the user can reliably enter the right case. To achieve this</p>
<ul>
<li>the matcher is replaced by its splitter, which brings extra assumptions into scope when
patterns are overlapping</li>
<li>simple discriminants that are mentioned in the goal (i.e plain parameters) are instantiated
in the code.</li>
<li>for discriminants that are not instantiated that way, equalities connecting the discriminant
to the instantiation are added (just as if the user wrote <code>match h : x with …</code>)</li>
</ul>
</li>
<li><p>When a tail position (no more branching) is found, function <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase">buildInductionCase</a></code> assembles the
type of the case: a fresh <code>MVar</code> asserts the current goal, unwanted values from the local context
are cleared, and the current <code>body</code> is searched for recursive calls using <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.collectIHs">collectIHs</a></code>,
which are then asserted as inductive hyptheses in the <code>MVar</code>.</p>
</li>
<li><p>The function <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.collectIHs">collectIHs</a></code> walks the term and collects the induction hypotheses for the current case
(with proofs). When it encounters a saturated application of <code>oldIH x proof</code>, it returns
<code>newIH x proof : motive x</code>.</p>
<p>Since <code>x</code> and <code>proof</code> can contain further recursive calls, it uses
<code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldCalls">foldCalls</a></code> to replace these with calls to <code>foo</code>. This assumes that the
termination proof <code>proof</code> works nevertheless.</p>
<p>Again, <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.collectIHs">collectIHs</a></code> may encounter the <code>Lean.Meta.Matcherapp.addArg?</code> idiom, and again it threads <code>newIH</code>
through, replacing the extra argument. The resulting type of this induction hypothesis is now
itself a <code>match</code> statement (cf. <code><a href="../../.././Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.inferMatchType">Lean.Meta.MatcherApp.inferMatchType</a></code>)</p>
<p>The termination proof of <code>foo</code> may have abstracted over some proofs; these proofs must be transferred, so
auxillary lemmas are unfolded if needed.</p>
</li>
<li><p>The function <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldCalls">foldCalls</a></code> replaces calls to <code>oldIH</code> with calls to <code>foo</code> that
make sense to the user.</p>
<p>At the end of this transformation, no mention of <code>oldIH</code> must remain.</p>
</li>
<li><p>After this construction, the MVars introduced by <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase">buildInductionCase</a></code> are turned into parameters.</p>
</li>
</ol><p>The resulting term then becomes <code>foo.induct</code> at its inferred type.</p><h2 class="markdown-heading" id="Implementation-overview-mutual-non-unary-well-founded-recursion">Implementation overview (mutual/non-unary well-founded recursion) <a class="hover-link" href="#Implementation-overview-mutual-non-unary-well-founded-recursion">#</a></h2><p>If <code>foo</code> is not unary and/or part of a mutual reduction, then the induction theorem for <code>foo._unary</code>
(i.e. the unary non-mutual recursion function produced by the equation compiler)
of the form</p><pre><code>foo._unary.induct : {motive : (a ⊗' b) ⊕' c → Prop} →
  (case1 : ∀ …, motive (PSum.inl (x,y)) →  …) → … →
  (x : (a ⊗' b) ⊕' c) → motive x
</code></pre><p>will first in <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.unpackMutualInduction">unpackMutualInduction</a></code> be turned into a joint induction theorem of the form</p><pre><code>foo.mutual_induct : {motive1 : a → b → Prop} {motive2 : c → Prop} →
  (case1 : ∀ …, motive1 x y  →  …) → … →
  ((x : a) → (y : b) → motive1 x y) ∧ ((z : c) → motive2 z)
</code></pre><p>where all the <code><a href="../../.././Init/Core.html#PSum">PSum</a></code>/<code><a href="../../.././Init/Core.html#PSigma">PSigma</a></code> encoding has been resolved. This theorem is attached to the
name of the first function in the mutual group, like the <code>._unary</code> definition.</p><p>Finally, in <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnpackedInduction">deriveUnpackedInduction</a></code>, for each of the funtions in the mutual group, a simple
projection yields the final <code>foo.induct</code> theorem:</p><pre><code>foo.induct : {motive1 : a → b → Prop} {motive2 : c → Prop} →
  (case1 : ∀ …, motive1 x y  →  …) → … →
  (x : a) → (y : b) → motive1 x y
</code></pre><h2 class="markdown-heading" id="Implementation-overview-structural-recursion">Implementation overview (structural recursion) <a class="hover-link" href="#Implementation-overview-structural-recursion">#</a></h2><p>When handling structural recursion, the overall approach is the same, with the following
differences:</p><ul>
<li><p>Instead of <code><a href="../../.././Init/WF.html#WellFounded.fix">WellFounded.fix</a></code> we look for a <code>.brecOn</code> application, using <code>isBRecOnRecursor</code></p>
<p>Despite its name, this function does <em>not</em> recognize the <code>.brecOn</code> of inductive <em>predicates</em>,
which we also do not support at this point.</p>
</li>
<li><p>The elaboration of structurally recursive function can handle extra arguments. We keep the
<code>motive</code> parameters in the original order.</p>
</li>
<li><p>The “induction hyothesis” in a <code>.brecOn</code> call is a <code>below x</code> term that contains all the possible
recursive calls, whic are projected out using <code>.fst.snd.…</code>. The <code>is_wf</code> flag that we pass down
tells us which form of induction hypothesis we are looking for.</p>
</li>
<li><p>If we have nested recursion (<code>foo n (foo m acc))</code>), then we need to infer the argument <code>m</code> of the
nested call <code>ih.fst.snd acc</code>. To do so reliably, we replace the <code>ih</code> with the “new <code>ih</code>”, which
will have type <code>motive m acc</code>, and since <code>motive</code> is a FVar we can then read off the arguments
off this nicely.</p>
</li>
<li><p>There exist inductive types where the <code>.brecOn</code> only supports motives producing <code>Type u</code>, but
not <code>Sort u</code>, but our induction principles produce <code>Prop</code>. We recognize this case and, rather
hazardously, replace <code>.brecOn</code> with <code>.binductionOn</code> (and thus <code>.below </code> with <code>.ibelow</code> and
<code><a href="../../.././Init/Prelude.html#PProd">PProd</a></code> with <code><a href="../../.././Init/Prelude.html#And">And</a></code>). This assumes that these definitions are highly analogous.</p>
</li>
</ul></div><div class="decl" id="Lean.Tactic.FunInd.removeLamda"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L200-L204">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.removeLamda"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">removeLamda</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <span class="fn"><a href="../../.././foundational_types.html">Type</a> → <a href="../../.././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#MonadLiftT">MonadLiftT</a> <a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Lean/Exception.html#Lean.MonadError">Lean.MonadError</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Meta.html#Lean.MonadNameGenerator">Lean.MonadNameGenerator</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(k : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a> → <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></div></div><p>Opens the body of a lambda, <em>without</em> putting the free variable into the local context.
This is used when replacing parameters with different expressions.
This way it will not be picked up by metavariables.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.removeLamda" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.mkFst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L207-L212">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkFst"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">mkFst</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p><code><a href="../../.././Init/Prelude.html#PProd.fst">PProd.fst</a></code> or <code><a href="../../.././Init/Prelude.html#And.left">And.left</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.mkFst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.mkSnd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L215-L220">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkSnd"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">mkSnd</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p><code><a href="../../.././Init/Prelude.html#PProd.snd">PProd.snd</a></code> or <code><a href="../../.././Init/Prelude.html#And.right">And.right</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.mkSnd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.isPProdProj"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L227-L241">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isPProdProj"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">isPProdProj</span></a></span><span class="decl_args">
<span class="fn">(oldIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(newIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span></div></div><p>Structural recursion only:
Recognizes <code>oldIH.fst.snd a₁ a₂</code> and returns <code>newIH.fst.snd</code>.
Possibly switching from <code><a href="../../.././Init/Prelude.html#PProd.fst">PProd.fst</a></code> to <code><a href="../../.././Init/Prelude.html#And.left">And.left</a></code> if needed</p></div></div><div class="decl" id="Lean.Tactic.FunInd.isPProdProjWithArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L247-L254">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isPProdProjWithArgs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">isPProdProjWithArgs</span></a></span><span class="decl_args">
<span class="fn">(oldIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(newIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></span>)</span></span>)</span></span></div></div><p>Structural recursion only:
Recognizes <code>oldIH.fst.snd a₁ a₂</code> and returns <code>newIH.fst.snd</code> and <code>#[a₁, a₂]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.isPProdProjWithArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.foldCalls"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L263-L348">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldCalls"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">foldCalls</span></a></span><span class="decl_args">
<span class="fn">(is_wf : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(fn : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(oldIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(newIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Replace calls to oldIH back to calls to the original function. At the end, if <code>oldIH</code> occurs, an
error is thrown.</p><p>The <code>newIH</code> will not show up in the output of <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldCalls">foldCalls</a></code>, we use it as a helper to infer the
argument of nested recursive calls when we have structural recursion.</p></div></div><div class="decl" id="Lean.Tactic.FunInd.collectIHs"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L358-L473">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.collectIHs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">collectIHs</span></a></span><span class="decl_args">
<span class="fn">(is_wf : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(fn : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(oldIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(newIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span></div></div></div></div><div class="decl" id="Lean.Tactic.FunInd.deduplicateIHs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L479-L487">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deduplicateIHs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deduplicateIHs</span></a></span><span class="decl_args">
<span class="fn">(vals : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.deduplicateIHs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.assertIHs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L489-L493">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.assertIHs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">assertIHs</span></a></span><span class="decl_args">
<span class="fn">(vals : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(mvarid : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.assertIHs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.substVarAfter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L501-L508">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.substVarAfter"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">substVarAfter</span></a></span><span class="decl_args">
<span class="fn">(mvarId : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(x : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span></div></div><p>Substitutes equations, but makes sure to only substitute variables introduced after the motive
as the motive could depend on anything before, and <code>substVar</code> would happily drop equations
about these fixed parameters.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.substVarAfter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.M"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L513-L513">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">M</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Helper monad to traverse the function body, collecting the cases as mvars</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">Lean.Tactic.FunInd.M</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Control/State.html#StateT">StateT</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span> <a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">α</span></span></span></li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.M" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.buildInductionCase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L517-L530">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">buildInductionCase</span></a></span><span class="decl_args">
<span class="fn">(is_wf : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(fn : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(oldIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(newIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(toClear : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(toPreserve : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(goal : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(IHs : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">Lean.Tactic.FunInd.M</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Base case of <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody">buildInductionBody</a></code>: Construct a case for the final induction hypthesis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.buildInductionCase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.mkLambdaFVarsMasked"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L546-L558">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkLambdaFVarsMasked"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">mkLambdaFVarsMasked</span></a></span><span class="decl_args">
<span class="fn">(xs : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span></div></div><p>Like <code>mkLambdaFVars (usedOnly := true)</code>, but</p><ul>
<li>silently skips expression in <code>xs</code> that are not <code>.isFVar</code></li>
<li>returns a mask (same size as <code>xs</code>) indicating which variables have been abstracted
(<code>true</code> means was abstracted).</li>
</ul><p>The result <code>r</code> can be applied with <code>r.beta (maskArray mask args)</code>.</p><p>We use this when generating the functional induction principle to refine the goal through a <code>match</code>,
here <code>xs</code> are the discriminans of the <code>match</code>.
We do not expect non-trivial discriminants to appear in the goal (and if they do, the user will
get a helpful equality into the context).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.mkLambdaFVarsMasked" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.maskArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L561-L565">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.maskArray"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">maskArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(mask : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(xs : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p><code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.maskArray">maskArray</a> mask xs</code> keeps those <code>x</code> where the corresponding entry in <code>mask</code> is <code>true</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.maskArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.buildInductionBody"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L572-L663">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">buildInductionBody</span></a></span><span class="decl_args">
<span class="fn">(is_wf : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(fn : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(toClear : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(toPreserve : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(goal : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(oldIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(newIH : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(IHs : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M">Lean.Tactic.FunInd.M</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Builds an expression of type <code>goal</code> by replicating the expression <code>e</code> into its tail-call-positions,
where it calls <code><a href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase">buildInductionCase</a></code>. Collects the cases of the final induction hypothesis
as <code>MVars</code> as it goes.</p></div></div><div class="decl" id="Lean.Tactic.FunInd.abstractIndependentMVars"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L682-L692">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.abstractIndependentMVars"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">abstractIndependentMVars</span></a></span><span class="decl_args">
<span class="fn">(mvars : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Given an expression <code>e</code> with metavariables</p><ul>
<li>collects all these meta-variables,</li>
<li>lifts them to the current context by reverting all local declarations up to <code>x</code></li>
<li>introducing a local variable for each of the meta variable</li>
<li>assigning that local variable to the mvar</li>
<li>and finally lambda-abstracting over these new local variables.</li>
</ul><p>This operation only works if the metavariables are independent from each other.</p><p>The resulting meta variable assignment is no longer valid (mentions out-of-scope
variables), so after this operations, terms that still mention these meta variables must not
be used anymore.</p><p>We are not using <code>mkLambdaFVars</code> on mvars directly, nor <code>abstractMVars</code>, as these at the moment
do not handle delayed assignemnts correctly.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.abstractIndependentMVars" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.motiveUniverseParamPos"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L698-L709">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.motiveUniverseParamPos"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">motiveUniverseParamPos</span></a></span><span class="decl_args">
<span class="fn">(declName : <a href="../../.././Init/Prelude.html#Lean.Name">Lake.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Init/Prelude.html#Nat">Nat</a></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.motiveUniverseParamPos" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.findRecursor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L727-L801">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.findRecursor"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">findRecursor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(name : <a href="../../.././Init/Prelude.html#Lean.Name">Lake.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(varNames : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lake.Name</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(k : <span class="fn"><a href="../../.././Init/Prelude.html#Bool">Bool</a> →
  <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> →
    <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> →
      <span class="fn"><a href="../../.././Init/Prelude.html#Nat">Nat</a> → <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></span>)</span> → <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">α</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">α</span></span></div></div><p>This function looks that the body of a recursive function and looks for either users of
<code>fix</code>, <code>fixF</code> or a <code>.brecOn</code>, and abstracts over the differences between them. It passes
to the continuation</p><ul>
<li>whether we are using well-founded recursion</li>
<li>the fixed parameters of the function body</li>
<li>the varying parameters of the function body (this includes both the targets of the
recursion and extra parameters passed to the recursor)</li>
<li>the position of the motive/induction hypothesis in the body's arguments</li>
<li>the body, as passed to the recursor. Expected to be a lambda that takes the
varying paramters and the motive</li>
<li>a function to re-assemble the call with a new Motive. The resulting expression expects
the new body next, so that the expected type of the body can be inferred</li>
<li>a function to finish assembling the call with the new body.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.findRecursor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.findRecursor.err"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L798-L801">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.findRecursor.err"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">findRecursor</span>.<span class="name">err</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(name : <a href="../../.././Init/Prelude.html#Lean.Name">Lake.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.findRecursor.err" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.deriveUnaryInduction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L808-L866">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnaryInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveUnaryInduction</span></a></span><span class="decl_args">
<span class="fn">(name : <a href="../../.././Init/Prelude.html#Lean.Name">Lake.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lake.Name</a></span></div></div><p>Given a definition <code>foo</code> defined via <code><a href="../../.././Init/WF.html#WellFounded.fixF">WellFounded.fixF</a></code>, derive a suitable induction principle
<code>foo.induct</code> for it. See module doc for details.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.deriveUnaryInduction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.cleanPackedArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L876-L920">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanPackedArgs"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">cleanPackedArgs</span></a></span><span class="decl_args">
<span class="fn">(eqnInfo : <a href="../../.././Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo">Lean.Elab.WF.EqnInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(value : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>In the type of <code>value</code>, reduces</p><ul>
<li>Beta-redexes</li>
<li><code><a href="../../.././Init/Core.html#PSigma.casesOn">PSigma.casesOn</a> (PSigma.mk a b) (fun x y =&gt; k x y)  --&gt;  k a b</code></li>
<li><code><a href="../../.././Init/Core.html#PSum.casesOn">PSum.casesOn</a> (PSum.inl x) k₁ k₂                    --&gt;  k₁ x</code></li>
<li><code>foo._unary (PSum.inl (PSigma.mk a b))              --&gt;  foo a b</code>
and then wraps <code>value</code> in an appropriate type hint.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.cleanPackedArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.unpackMutualInduction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L926-L969">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.unpackMutualInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">unpackMutualInduction</span></a></span><span class="decl_args">
<span class="fn">(eqnInfo : <a href="../../.././Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo">Lean.Elab.WF.EqnInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(unaryInductName : <a href="../../.././Init/Prelude.html#Lean.Name">Lake.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lake.Name</a></span></div></div><p>Takes an induction principle where the motive is a <code><a href="../../.././Init/Core.html#PSigma">PSigma</a></code>/<code><a href="../../.././Init/Core.html#PSum">PSum</a></code> type and
unpacks it into a n-ary and (possibly) joint induction principle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.unpackMutualInduction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.deriveUnpackedInduction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L972-L986">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnpackedInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveUnpackedInduction</span></a></span><span class="decl_args">
<span class="fn">(eqnInfo : <a href="../../.././Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo">Lean.Elab.WF.EqnInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(unaryInductName : <a href="../../.././Init/Prelude.html#Lean.Name">Lake.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Given <code>foo._unary.induct</code>, define <code>foo.mutual_induct</code> and then <code>foo.induct</code>, <code>bar.induct</code>, …</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.deriveUnpackedInduction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.deriveInduction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L991-L997">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInduction"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">deriveInduction</span></a></span><span class="decl_args">
<span class="fn">(name : <a href="../../.././Init/Prelude.html#Lean.Name">Lake.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Given a recursively defined function <code>foo</code>, derives <code>foo.induct</code>. See the module doc for details.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.deriveInduction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Tactic.FunInd.isFunInductName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L999-L1011">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunInductName"><span class="name">Lean</span>.<span class="name">Tactic</span>.<span class="name">FunInd</span>.<span class="name">isFunInductName</span></a></span><span class="decl_args">
<span class="fn">(env : <a href="../../.././Lean/Environment.html#Lean.Environment">Lean.Environment</a>)</span></span>
<span class="decl_args">
<span class="fn">(name : <a href="../../.././Init/Prelude.html#Lean.Name">Lake.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Tactic.FunInd.isFunInductName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>