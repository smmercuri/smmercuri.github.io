<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Comma.Over</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Comma.Over";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Comma</span>.<span class="name">Over</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/PUnit.html">Mathlib.CategoryTheory.PUnit</a></li><li><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html">Mathlib.CategoryTheory.Comma.StructuredArrow</a></li><li><a href="../../.././Mathlib/CategoryTheory/Functor/EpiMono.html">Mathlib.CategoryTheory.Functor.EpiMono</a></li><li><a href="../../.././Mathlib/CategoryTheory/Functor/ReflectsIso.html">Mathlib.CategoryTheory.Functor.ReflectsIso</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Comma.Over" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over"><span class="name">CategoryTheory</span>.<span class="name">Over</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instCategoryOver"><span class="name">CategoryTheory</span>.<span class="name">instCategoryOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">inhabited</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.OverMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">OverMorphism</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.over_right"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">over_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.id_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">id_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.comp_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">comp_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.w"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.coeFromHom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coeFromHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.coe_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coe_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.homMk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.homMk_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.homMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_inv_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_hom_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_inv_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_hom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forgetCocone_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_ι_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forgetCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forgetCocone"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map_map_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapId_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapId"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapForget_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapForget_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapForget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapForget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.eqToHom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">eqToHom_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapComp_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_reflects_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mkIdTerminal"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mkIdTerminal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.epi_of_epi_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">epi_of_epi_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mono_of_mono_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_of_mono_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mono_left_of_mono"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_left_of_mono</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward_forget_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_forget_forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.post_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.post"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_map_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_obj_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.instFaithfulOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFaithfulOverToOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.instFullOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFullOverToOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.instEssSurjOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instEssSurjOverToOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.isEquivalence_toOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">isEquivalence_toOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under"><span class="name">CategoryTheory</span>.<span class="name">Under</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instCategoryUnder"><span class="name">CategoryTheory</span>.<span class="name">instCategoryUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">inhabited</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.UnderMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">UnderMorphism</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.under_left"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">under_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.id_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">id_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.comp_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">comp_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.w"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.homMk_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.homMk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.homMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.isoMk_hom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_hom_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.isoMk_inv_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_inv_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forgetCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forgetCone_π_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_π_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forgetCone"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map_map_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapId_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapId"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapForget_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapForget_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapForget"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapForget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.eqToHom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">eqToHom_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapComp_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_reflects_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mkIdInitial"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mkIdInitial</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mono_of_mono_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mono_of_mono_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.epi_of_epi_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_of_epi_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.epi_right_of_epi"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_right_of_epi</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.post_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.post"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_map_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_obj_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.instFaithfulUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFaithfulUnderToUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.instFullUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFullUnderToUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.instEssSurjUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instEssSurjUnderToUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.isEquivalence_toUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">isEquivalence_toUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOverCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOverCompForget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_comp_forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnderCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnderCompForget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_comp_forget</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Over-and-under-categories">Over and under categories <a class="hover-link" href="#Over-and-under-categories">#</a></h1><p>Over (and under) categories are special cases of comma categories.</p><ul>
<li>If <code>L</code> is the identity functor and <code>R</code> is a constant functor, then <code>Comma L R</code> is the &quot;slice&quot; or
&quot;over&quot; category over the object <code>R</code> maps to.</li>
<li>Conversely, if <code>L</code> is a constant functor and <code>R</code> is the identity functor, then <code>Comma L R</code> is the
&quot;coslice&quot; or &quot;under&quot; category under the object <code>L</code> maps to.</li>
</ul><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>Comma, Slice, Coslice, Over, Under</p></div><div class="decl" id="CategoryTheory.Over"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L38-L39">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over"><span class="name">CategoryTheory</span>.<span class="name">Over</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u₁ v₁)</div></div><p>The over category has as objects arrows in <code>T</code> with codomain <code>X</code> and as morphisms commutative
triangles.</p><p>See <a href="https://stacks.math.columbia.edu/tag/001G">https://stacks.math.columbia.edu/tag/001G</a>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">X</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.instCategoryOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L41-L41">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.instCategoryOver"><span class="name">CategoryTheory</span>.<span class="name">instCategoryOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, max u₁ v₁}</a>            <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.instCategoryOver">CategoryTheory.instCategoryOver</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.commaCategory</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.inhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L44-L48">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">inhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">default</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Over.inhabited</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">default</span> :=
      <span class="fn">{ <span class="fn">left</span> := <span class="fn">default</span>, <span class="fn">right</span> := <span class="fn">default</span>,
        <span class="fn">hom</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span>.obj</span> <span class="fn">default</span></span>)</span></span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.OverMorphism.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L55-L59">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.OverMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">OverMorphism</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.over_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L62-L62">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.over_right"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">over_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">as</span> := <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a> }</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.id_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L65-L66">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.id_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">id_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">U</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">U</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.comp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L69-L70">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.comp_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">comp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.left</span> <span class="fn"><span class="fn">g</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.w_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L72-L72">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span>.obj</span> <span class="fn"><span class="fn">B</span>.right</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.left</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">B</span>.hom</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">A</span>.hom</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.w"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L73-L73">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.w"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.left</span> <span class="fn"><span class="fn">B</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">A</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mk_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L76-L76">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Y</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mk_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L76-L76">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L77-L78">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span></div></div><p>To give an object in the over category, it suffices to give a morphism with codomain <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.CostructuredArrow.mk">CategoryTheory.CostructuredArrow.mk</a> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.coeFromHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L82-L82">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.coeFromHom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coeFromHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Coe.html#CoeOut">CoeOut</a> <span class="fn">(<span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span></div></div><p>We can set up a coercion from arrows with codomain <code>X</code> to <code>over X</code>. This most likely should not
be a global instance, but it is sometimes useful.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Over.coeFromHom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">coe</span> := <span class="fn">CategoryTheory.Over.mk</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.coeFromHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.coe_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L89-L90">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.coe_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coe_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.homMk_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L96-L96">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">V</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.450">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">f</span> <span class="fn">w</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.homMk_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L96-L96">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">V</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.450">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.homMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L97-L98">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">V</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.450">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span></div></div><p>To give a morphism in the over category, it suffices to give an arrow fitting in a commutative
triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">f</span> <span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.CostructuredArrow.homMk">CategoryTheory.CostructuredArrow.homMk</a> <span class="fn">f</span> <span class="fn">w</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.homMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.isoMk_inv_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L106-L106">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk_inv_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.487">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">hl</span> <span class="fn">hw</span></span>)</span>.inv</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hl</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk_hom_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L106-L106">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk_hom_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.487">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk_inv_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L106-L106">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk_inv_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.487">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk_hom_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L106-L106">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk_hom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.487">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">hl</span> <span class="fn">hw</span></span>)</span>.hom</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hl</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L107-L109">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.487">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span></div></div><p>Construct an isomorphism in the over category given isomorphisms of the objects whose forward
direction gives a commutative triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">hl</span> <span class="fn">hw</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.CostructuredArrow.isoMk">CategoryTheory.CostructuredArrow.isoMk</a> <span class="fn">hl</span> <span class="fn">hw</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.isoMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.forget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L122-L123">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span> <span class="fn">T</span></span></div></div><p>The forgetful functor mapping an arrow to its domain.</p><p>See <a href="https://stacks.math.columbia.edu/tag/001G">https://stacks.math.columbia.edu/tag/001G</a>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.fst">CategoryTheory.Comma.fst</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.forget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.forget_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L128-L129">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span>.obj</span> <span class="fn">U</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forget_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L132-L133">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forgetCocone_ι_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L136-L136">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_ι_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone">CategoryTheory.Over.forgetCocone</a> <span class="fn">X</span></span>)</span>.ι</span>.app</span> <span class="fn">self</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">self</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forgetCocone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L136-L136">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone">CategoryTheory.Over.forgetCocone</a> <span class="fn">X</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forgetCocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L137-L139">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span></div></div><p>The natural cocone over the forgetful functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X ⥤ T</code> with cocone point <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone">CategoryTheory.Over.forgetCocone</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn">X</span>, <span class="fn">ι</span> := <span class="fn">{ <span class="fn">app</span> := <span class="fn">CategoryTheory.Comma.hom</span>, <span class="fn">naturality</span> := <span class="fn">⋯</span> }</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.forgetCocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L145-L146">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span>)</span></span></div></div><p>A morphism <code>f : X ⟶ Y</code> induces a functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> Y</code> in the obvious way.</p><p>See <a href="https://stacks.math.columbia.edu/tag/001G">https://stacks.math.columbia.edu/tag/001G</a>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.mapRight">CategoryTheory.Comma.mapRight</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans">CategoryTheory.Discrete.natTrans</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{1}</a></span>) =&gt; <span class="fn">f</span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.map_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L153-L154">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span>)</span>.obj</span> <span class="fn">U</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.map_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L157-L158">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span>)</span>.obj</span> <span class="fn">U</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.map_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L161-L162">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map_map_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span>)</span>.map</span> <span class="fn">g</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.left</span></span></div></div></div></div><div class="mod_doc"><p>This section proves various equalities between functors that
demonstrate, for instance, that over categories assemble into a
functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor">mapFunctor</a> : T ⥤ Cat</code>.</p><p>These equalities between functors are then converted to natural
isomorphisms using <code>eqToIso</code>. Such natural isomorphisms could be
obtained directly using <code>Iso.<a href="../../.././Mathlib/Init/Algebra/Classes.html#refl">refl</a></code> but this method will have
better computational properties, when used, for instance, in
developing the theory of Beck-Chevalley transformations.</p></div><div class="decl" id="CategoryTheory.Over.mapId_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L179-L187">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapId_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span>)</span></span></span></div></div><p>Mapping by the identity morphism is just the identity functor.</p></div></div><div class="decl" id="CategoryTheory.Over.mapId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L190-L190">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapId"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span>)</span></span></span></div></div><p>The natural isomorphism arising from <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget_eq">mapForget_eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapId">CategoryTheory.Over.mapId</a> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mapForget_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L194-L198">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapForget_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">Y</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span></span></div></div><p>Mapping by <code>f</code> and then forgetting is the same as forgetting.</p></div></div><div class="decl" id="CategoryTheory.Over.mapForget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L201-L202">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapForget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">Y</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span></span></div></div><p>The natural isomorphism arising from <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget_eq">mapForget_eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget">CategoryTheory.Over.mapForget</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapForget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.eqToHom_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L205-L207">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.eqToHom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">eqToHom_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">U</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">V</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">e</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapComp_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L210-L216">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">g</span></span>)</span></span></span></div></div><p>Mapping by the composite morphism <code>f ≫ g</code> is the same as mapping by <code>f</code> then by <code>g</code>.</p></div></div><div class="decl" id="CategoryTheory.Over.mapComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L219-L220">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">g</span></span>)</span></span></span></div></div><p>The natural isomorphism arising from <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp_eq">mapComp_eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp">CategoryTheory.Over.mapComp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mapFunctor_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L224-L224">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor_map</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">T</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor">CategoryTheory.Over.mapFunctor</a> <span class="fn">T</span></span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapFunctor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L224-L224">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor_obj</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor">CategoryTheory.Over.mapFunctor</a> <span class="fn">T</span></span>)</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat.of">CategoryTheory.Cat.of</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L224-L228">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat">CategoryTheory.Cat</a></span></div></div><p>The functor defined by the over categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor">CategoryTheory.Over.mapFunctor</a> <span class="fn">T</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">obj</span> := <span class="fn">fun (<span class="fn">X</span> : <span class="fn">T</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat.of">CategoryTheory.Cat.of</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span></span>,
    <span class="fn">map</span> := <span class="fn">fun {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">T</span>} =&gt; <span class="fn">CategoryTheory.Over.map</span></span>, <span class="fn">map_id</span> := <span class="fn">⋯</span>, <span class="fn">map_comp</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.forget_reflects_iso"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L232-L238">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_reflects_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span>.ReflectsIsomorphisms</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mkIdTerminal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L241-L242">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mkIdTerminal"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mkIdTerminal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.IsTerminal">CategoryTheory.Limits.IsTerminal</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">X</span></span>)</span></span>)</span></span></div></div><p>The identity over <code>X</code> is terminal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Over.mkIdTerminal</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.CostructuredArrow.mkIdTerminal</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mkIdTerminal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.forget_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L244-L244">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_faithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.epi_of_epi_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L253-L254">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.epi_of_epi_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">epi_of_epi_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn"><span class="fn">k</span>.left</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn">k</span></span></div></div><p>If <code>k.left</code> is an epimorphism, then <code>k</code> is an epimorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">Over.forget</a> X</code> reflects
epimorphisms.
The converse does not hold without additional assumptions on the underlying category, see
<code>CategoryTheory.Over.epi_left_of_epi</code>.</p></div></div><div class="decl" id="CategoryTheory.Over.mono_of_mono_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L263-L264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mono_of_mono_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_of_mono_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn"><span class="fn">k</span>.left</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn">k</span></span></div></div><p>If <code>k.left</code> is a monomorphism, then <code>k</code> is a monomorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">Over.forget</a> X</code> reflects
monomorphisms.
The converse of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mono_left_of_mono">CategoryTheory.Over.mono_left_of_mono</a></code>.</p><p>This lemma is not an instance, to avoid loops in type class inference.</p></div></div><div class="decl" id="CategoryTheory.Over.mono_left_of_mono"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L271-L278">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mono_left_of_mono"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_left_of_mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn">k</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn"><span class="fn">k</span>.left</span></span></div></div><p>If <code>k</code> is a monomorphism, then <code>k.left</code> is a monomorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">Over.forget</a> X</code> preserves
monomorphisms.
The converse of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mono_of_mono_left">CategoryTheory.Over.mono_of_mono_left</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L285-L285">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceForward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceForward</span>.obj</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn"><span class="fn"><span class="fn">α</span>.hom</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L285-L285">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceForward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>} (<span class="fn">κ</span> : <span class="fn"><span class="fn">X_1</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceForward</span>.map</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.left</span>.left</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L286-L288">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceForward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>)</span></span></div></div><p>Given f : Y ⟶ X, this is the obvious functor from (T/X)/f to T/Y</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.iteratedSliceForward" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L291-L291">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceBackward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceBackward</span>.obj</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn"><span class="fn">g</span>.hom</span> <span class="fn">⋯</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L291-L291">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceBackward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>} (<span class="fn">α</span> : <span class="fn"><span class="fn">X_1</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceBackward</span>.map</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn"><span class="fn">α</span>.left</span> <span class="fn">⋯</span></span>)</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L292-L294">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceBackward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>)</span></span></div></div><p>Given f : Y ⟶ X, this is the obvious functor from T/Y to (T/X)/f</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.iteratedSliceBackward" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L297-L297">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceEquiv</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.iteratedSliceForward</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L297-L297">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceEquiv</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a>
          <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>)</span></span>)</span>.obj</span> <span class="fn">g</span></span>)</span>.left</span>.left</span></span>)</span> <span class="fn">⋯</span></span>)</span>
        <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L297-L297">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceEquiv</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceBackward</span>.comp</span> <span class="fn"><span class="fn">f</span>.iteratedSliceForward</span></span>)</span>.obj</span> <span class="fn">g</span></span>)</span>.left</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L297-L297">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceEquiv</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.iteratedSliceBackward</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L298-L302">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceEquiv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span></span></div></div><p>Given f : Y ⟶ X, we have an equivalence between (T/X)/f and T/Y</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.iteratedSliceEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L304-L306">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceForward_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceForward</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">f</span>.left</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">f</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward_forget_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L308-L310">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceBackward_forget_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_forget_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceBackward</span>.comp</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">f</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">f</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.post_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L319-L319">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">f</span>.left</span></span>)</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.post_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L319-L319">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">Y</span>.hom</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.post"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L320-L323">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span></div></div><p>A functor <code>F : T ⥤ D</code> induces a functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> (F.obj X)</code> in the obvious way.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.post" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L335-L335">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X✝</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn"><span class="fn">X</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L335-L335">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span></span>}
  (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">f</span>.left</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L335-L335">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X✝</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L335-L335">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver_map_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span></span>}
  (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">X_1</span>.right</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L335-L335">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver_obj_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X✝</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L336-L337">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span></div></div><p>Reinterpreting an <code>F</code>-costructured arrow <code>F.obj d ⟶ X</code> as an arrow over <code>X</code> induces a functor
<code>CostructuredArrow F X ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.CostructuredArrow.pre">CategoryTheory.CostructuredArrow.pre</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">X</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.CostructuredArrow.toOver" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.instFaithfulOverToOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L339-L340">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.instFaithfulOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFaithfulOverToOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Faithful</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.instFullOverToOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L342-L343">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.instFullOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFullOverToOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Full</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span>.Full</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.instEssSurjOverToOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L345-L346">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.instEssSurjOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instEssSurjOverToOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.EssSurj</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span>.EssSurj</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.isEquivalence_toOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L349-L351">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.isEquivalence_toOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">isEquivalence_toOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span>.IsEquivalence</span></div></div><p>An equivalence <code>F</code> induces an equivalence <code>CostructuredArrow F X ≌ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L357-L358">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under"><span class="name">CategoryTheory</span>.<span class="name">Under</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u₁ v₁)</div></div><p>The under category has as objects arrows with domain <code>X</code> and as morphisms commutative
triangles.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.instCategoryUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L360-L360">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.instCategoryUnder"><span class="name">CategoryTheory</span>.<span class="name">instCategoryUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, max u₁ v₁}</a>            <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.instCategoryUnder">CategoryTheory.instCategoryUnder</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.commaCategory</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.inhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L363-L367">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">inhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">default</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.UnderMorphism.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L374-L377">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.UnderMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">UnderMorphism</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.under_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L380-L380">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.under_left"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">under_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">as</span> := <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a> }</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.id_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L383-L384">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.id_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">id_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">U</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">U</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.comp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L387-L388">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.comp_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">comp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.right</span> <span class="fn"><span class="fn">g</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.w_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L390-L390">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">B</span>.right</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">A</span>.hom</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.right</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">B</span>.hom</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.w"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L391-L391">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.w"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">A</span>.hom</span> <span class="fn"><span class="fn">f</span>.right</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">B</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mk_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L394-L394">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mk_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L394-L394">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">f</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Y</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L395-L396">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span></div></div><p>To give an object in the under category, it suffices to give an arrow with domain <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.StructuredArrow.mk">CategoryTheory.StructuredArrow.mk</a> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.homMk_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L400-L400">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">V</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.2738">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.homMk_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L400-L400">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">V</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.2738">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn">f</span> <span class="fn">w</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.homMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L401-L402">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">V</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.2738">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span></div></div><p>To give a morphism in the under category, it suffices to give a morphism fitting in a
commutative triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn">f</span> <span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.StructuredArrow.homMk">CategoryTheory.StructuredArrow.homMk</a> <span class="fn">f</span> <span class="fn">w</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.homMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.isoMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L410-L412">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.hom</span> <span class="fn"><span class="fn">hr</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.hom</span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#_auto._@.Mathlib.CategoryTheory.Comma.Over._hyg.2774">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span></div></div><p>Construct an isomorphism in the over category given isomorphisms of the objects whose forward
direction gives a commutative triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">hr</span> <span class="fn">hw</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.StructuredArrow.isoMk">CategoryTheory.StructuredArrow.isoMk</a> <span class="fn">hr</span> <span class="fn">hw</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.isoMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.isoMk_hom_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L415-L417">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk_hom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_hom_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.hom</span> <span class="fn"><span class="fn">hr</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.hom</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">hr</span> <span class="fn">hw</span></span>)</span>.hom</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hr</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.isoMk_inv_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L420-L422">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk_inv_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_inv_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.hom</span> <span class="fn"><span class="fn">hr</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.hom</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">hr</span> <span class="fn">hw</span></span>)</span>.inv</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hr</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L429-L430">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span> <span class="fn">T</span></span></div></div><p>The forgetful functor mapping an arrow to its domain.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.snd">CategoryTheory.Comma.snd</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.forget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.forget_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L435-L436">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span>.obj</span> <span class="fn">U</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forget_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L439-L440">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forgetCone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L443-L443">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone">CategoryTheory.Under.forgetCone</a> <span class="fn">X</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forgetCone_π_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L443-L443">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone_π_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_π_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone">CategoryTheory.Under.forgetCone</a> <span class="fn">X</span></span>)</span>.π</span>.app</span> <span class="fn">self</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">self</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forgetCone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L444-L446">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span></div></div><p>The natural cone over the forgetful functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X ⥤ T</code> with cone point <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone">CategoryTheory.Under.forgetCone</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn">X</span>, <span class="fn">π</span> := <span class="fn">{ <span class="fn">app</span> := <span class="fn">CategoryTheory.Comma.hom</span>, <span class="fn">naturality</span> := <span class="fn">⋯</span> }</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.forgetCone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L449-L450">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span></div></div><p>A morphism <code>X ⟶ Y</code> induces a functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> Y ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X</code> in the obvious way.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.mapLeft">CategoryTheory.Comma.mapLeft</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans">CategoryTheory.Discrete.natTrans</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{1}</a></span>) =&gt; <span class="fn">f</span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.map_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L457-L458">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span>)</span>.obj</span> <span class="fn">U</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.map_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L461-L462">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span>)</span>.obj</span> <span class="fn">U</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">U</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.map_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L465-L466">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map_map_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span>)</span>.map</span> <span class="fn">g</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.right</span></span></div></div></div></div><div class="mod_doc"><p>This section proves various equalities between functors that
demonstrate, for instance, that under categories assemble into a
functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor">mapFunctor</a> : Tᵒᵖ ⥤ Cat</code>.</p></div><div class="decl" id="CategoryTheory.Under.mapId_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L477-L485">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapId_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>)</span></span></span></div></div><p>Mapping by the identity morphism is just the identity functor.</p></div></div><div class="decl" id="CategoryTheory.Under.mapId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L488-L488">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapId"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>)</span></span></span></div></div><p>Mapping by the identity morphism is just the identity functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapId">CategoryTheory.Under.mapId</a> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mapForget_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L491-L495">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapForget_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapForget_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">Y</span></span></span></div></div><p>Mapping by <code>f</code> and then forgetting is the same as forgetting.</p></div></div><div class="decl" id="CategoryTheory.Under.mapForget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L498-L499">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapForget"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapForget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">Y</span></span></span></div></div><p>The natural isomorphism arising from <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget_eq">mapForget_eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapForget">CategoryTheory.Under.mapForget</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapForget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.eqToHom_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L502-L504">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.eqToHom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">eqToHom_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">U</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">V</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">e</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapComp_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L507-L513">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapComp_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">g</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span>)</span></span></span></div></div><p>Mapping by the composite morphism <code>f ≫ g</code> is the same as mapping by <code>f</code> then by <code>g</code>.</p></div></div><div class="decl" id="CategoryTheory.Under.mapComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L516-L517">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">g</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span>)</span></span></span></div></div><p>The natural isomorphism arising from <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp_eq">mapComp_eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapComp">CategoryTheory.Under.mapComp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mapFunctor_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L521-L521">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor_map</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><span class="fn">T</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapFunctor">CategoryTheory.Under.mapFunctor</a> <span class="fn">T</span></span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn"><span class="fn">f</span>.unop</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapFunctor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L521-L521">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor_obj</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapFunctor">CategoryTheory.Under.mapFunctor</a> <span class="fn">T</span></span>)</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat.of">CategoryTheory.Cat.of</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L521-L525">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">T</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat">CategoryTheory.Cat</a></span></div></div><p>The functor defined by the under categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.forget_reflects_iso"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L529-L535">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_reflects_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span>.ReflectsIsomorphisms</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mkIdInitial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L538-L539">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mkIdInitial"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mkIdInitial</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.IsInitial">CategoryTheory.Limits.IsInitial</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">X</span></span>)</span></span>)</span></span></div></div><p>The identity under <code>X</code> is initial.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Under.mkIdInitial</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.StructuredArrow.mkIdInitial</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mkIdInitial" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.forget_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L541-L541">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_faithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mono_of_mono_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L549-L550">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mono_of_mono_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mono_of_mono_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn"><span class="fn">k</span>.right</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn">k</span></span></div></div><p>If <code>k.right</code> is a monomorphism, then <code>k</code> is a monomorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">Under.forget</a> X</code>
reflects epimorphisms.
The converse does not hold without additional assumptions on the underlying category, see
<code>CategoryTheory.Under.mono_right_of_mono</code>.</p></div></div><div class="decl" id="CategoryTheory.Under.epi_of_epi_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L559-L560">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.epi_of_epi_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_of_epi_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn"><span class="fn">k</span>.right</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn">k</span></span></div></div><p>If <code>k.right</code> is an epimorphism, then <code>k</code> is an epimorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">Under.forget</a> X</code>
reflects epimorphisms.
The converse of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.epi_right_of_epi">CategoryTheory.Under.epi_right_of_epi</a></code>.</p><p>This lemma is not an instance, to avoid loops in type class inference.</p></div></div><div class="decl" id="CategoryTheory.Under.epi_right_of_epi"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L567-L573">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.epi_right_of_epi"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_right_of_epi</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn">k</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn"><span class="fn">k</span>.right</span></span></div></div><p>If <code>k</code> is an epimorphism, then <code>k.right</code> is an epimorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">Under.forget</a> X</code>
preserves epimorphisms.
The converse of <code>CategoryTheory.under.<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.epi_of_epi_right">epi_of_epi_right</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.post_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L580-L580">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">f</span>.right</span></span>)</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.post_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L580-L580">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">Y</span>.hom</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.post"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L581-L584">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span></div></div><p>A functor <code>F : T ⥤ D</code> induces a functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> (F.obj X)</code> in the obvious way.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Under.post" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L596-L596">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder_map_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>}
  (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">X_1</span>.left</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L596-L596">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X✝</span> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn"><span class="fn">X</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L596-L596">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder_obj_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X✝</span> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L596-L596">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X✝</span> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L596-L596">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>}
  (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">f</span>.right</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L597-L598">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span></div></div><p>Reinterpreting an <code>F</code>-structured arrow <code>X ⟶ F.obj d</code> as an arrow under <code>X</code> induces a functor
<code>StructuredArrow X F ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.StructuredArrow.pre">CategoryTheory.StructuredArrow.pre</a> <span class="fn">X</span> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.StructuredArrow.toUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.instFaithfulUnderToUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L600-L601">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.instFaithfulUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFaithfulUnderToUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Faithful</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.instFullUnderToUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L603-L604">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.instFullUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFullUnderToUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Full</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span>.Full</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.instEssSurjUnderToUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L606-L607">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.instEssSurjUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instEssSurjUnderToUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.EssSurj</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span>.EssSurj</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.isEquivalence_toUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L610-L612">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.isEquivalence_toUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">isEquivalence_toUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span>.IsEquivalence</span></div></div><p>An equivalence <code>F</code> induces an equivalence <code>StructuredArrow X F ≌ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toOver_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L623-L623">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">S</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span>)</span>.obj</span> <span class="fn">Y</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toOver_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L623-L623">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span><span class="fn">Y</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">X_1</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span>)</span>.map</span> <span class="fn">g</span></span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toOver"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L624-L626">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toOver"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span></div></div><p>Given <code>X : T</code>, to upgrade a functor <code>F : S ⥤ T</code> to a functor <code>S ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X</code>, it suffices to
provide maps <code>F.obj Y ⟶ X</code> for all <code>Y</code> making the obvious triangles involving all <code>F.<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">map</a> g</code>
commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.toCostructuredArrow</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toOver" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toOverCompForget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L630-L632">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toOverCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOverCompForget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span></div></div><p>Upgrading a functor <code>S ⥤ T</code> to a functor <code>S ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X</code> and composing with the forgetful functor
<code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X ⥤ T</code> recovers the original functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.toOverCompForget</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toOverCompForget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toOver_comp_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L635-L637">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toOver_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_comp_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">F</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toUnder_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L642-L642">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span><span class="fn">Y</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">X_1</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span>)</span>.map</span> <span class="fn">g</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toUnder_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L642-L642">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">S</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span>)</span>.obj</span> <span class="fn">Y</span></span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L643-L645">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toUnder"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span></div></div><p>Given <code>X : T</code>, to upgrade a functor <code>F : S ⥤ T</code> to a functor <code>S ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X</code>, it suffices to
provide maps <code>X ⟶ F.obj Y</code> for all <code>Y</code> making the obvious triangles involving all <code>F.<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">map</a> g</code>
commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.toStructuredArrow</span> <span class="fn">X</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">f</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toUnderCompForget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L649-L651">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toUnderCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnderCompForget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span></div></div><p>Upgrading a functor <code>S ⥤ T</code> to a functor <code>S ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X</code> and composing with the forgetful functor
<code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X ⥤ T</code> recovers the original functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.toUnderCompForget</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toUnderCompForget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toUnder_comp_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Comma/Over.lean#L654-L656">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toUnder_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_comp_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">F</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>