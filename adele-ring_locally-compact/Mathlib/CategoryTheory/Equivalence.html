<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Equivalence</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Equivalence";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Equivalence</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/CategoryTheory/EssentialImage.html">Mathlib.CategoryTheory.EssentialImage</a></li><li><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html">Mathlib.CategoryTheory.FullSubcategory</a></li><li><a href="../.././Mathlib/CategoryTheory/Whiskering.html">Mathlib.CategoryTheory.Whiskering</a></li><li><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html">Mathlib.CategoryTheory.Functor.FullyFaithful</a></li><li><a href="../.././Mathlib/Tactic/CategoryTheory/Slice.html">Mathlib.Tactic.CategoryTheory.Slice</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Equivalence" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.«term_≌_»"><span class="name">CategoryTheory</span>.<span class="name">«term_≌_»</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functor_unit_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functor_unit_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv_functor_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv_functor_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_app_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counit_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit_app_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit_inverse_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit_inverse_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inverse_counitInv_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inverse_counitInv_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_app_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unitInv_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv_app_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fun_inv_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inv_fun_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.adjointifyη"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointifyη</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.adjointify_η_ε_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.adjointify_η_ε"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mk"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.instInhabitedEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instInhabitedEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.funInvIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.funInvIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.funInvIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.invFunIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.invFunIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.invFunIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unitInv_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counit_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unit_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counitInv_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unit_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counitInv_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.powNat"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">powNat</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.instPowEquivalenceInt"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instPowEquivalenceInt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow_zero"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_zero</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_one</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow_neg_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_neg_one</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.functor_unitIso_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">functor_unitIso_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.ofEquivalence"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.ofEquivalenceInverse"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofEquivalenceInverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.mk"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.asEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalenceRefl"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalenceRefl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalenceInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalenceInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.asEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.asEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.asEquivalence_unit"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_unit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.asEquivalence_counit"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_counit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.inv_inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalenceTrans"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalenceTrans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instIsEquivalenceFunctorCategoryFunctorCategoryObjFunctorToQuiverToCategoryStructCategoryFunctorToQuiverToCategoryStructCategoryToPrefunctorWhiskeringLeft"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceFunctorCategoryFunctorCategoryObjFunctorToQuiverToCategoryStructCategoryFunctorToQuiverToCategoryStructCategoryToPrefunctorWhiskeringLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instIsEquivalenceFunctorCategoryFunctorCategoryObjFunctorToQuiverToCategoryStructCategoryFunctorToQuiverToCategoryStructCategoryToPrefunctorWhiskeringRight"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceFunctorCategoryFunctorCategoryObjFunctorToQuiverToCategoryStructCategoryFunctorToQuiverToCategoryStructCategoryToPrefunctorWhiskeringRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functor_inv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inverse_inv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.isEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.isEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functor_asEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_asEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inverse_asEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_asEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">fun_inv_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">inv_fun_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.ofIso_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_unitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.ofIso_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_unitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.ofIso_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_counitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.ofIso_inverse"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.ofIso_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_counitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.ofIso"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.ofIso_trans"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.ofIso_refl"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.equivOfIso_symm_apply"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">equivOfIso_symm_apply</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.equivOfIso_apply"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">equivOfIso_apply</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.equivOfIso"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">equivOfIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.cancelCompRight"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">cancelCompRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsEquivalence.cancelCompLeft"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">cancelCompLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.essSurj_of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurj_of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.faithfulOfEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">faithfulOfEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fullOfEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullOfEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullyFaithfullyEssSurj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functor_map_inj_iff"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_map_inj_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inverse_map_inj_iff"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_map_inj_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.essSurjInducedFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurjInducedFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inducedFunctorOfEquiv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inducedFunctorOfEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fullyFaithfulToEssImage"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulToEssImage</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInvIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInvIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInvIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInvIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInvIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInvIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInverseIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInverseIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInverseIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInv_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInv_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInv_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInv_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInv"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInverse_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInverse_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.invCompIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">invCompIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.invCompIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">invCompIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.invCompIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">invCompIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.inverseCompIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.inverseCompIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.inverseCompIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInvComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInvComp_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInvComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInvComp_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInvComp"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInvComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseComp"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.compInvIso"><span class="name">CategoryTheory</span>.<span class="name">compInvIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isoCompInv"><span class="name">CategoryTheory</span>.<span class="name">isoCompInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.invCompIso"><span class="name">CategoryTheory</span>.<span class="name">invCompIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isoInvComp"><span class="name">CategoryTheory</span>.<span class="name">isoInvComp</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Equivalence-of-categories">Equivalence of categories <a class="hover-link" href="#Equivalence-of-categories">#</a></h1><p>An equivalence of categories <code>C</code> and <code>D</code> is a pair of functors <code>F : C ⥤ D</code> and <code>G : D ⥤ C</code> such
that <code>η : 𝟭 C ≅ F ⋙ G</code> and <code>ε : G ⋙ F ≅ 𝟭 D</code>. In many situations, equivalences are a better
notion of "sameness" of categories than the stricter isomorphism of categories.</p><p>Recall that one way to express that two functors <code>F : C ⥤ D</code> and <code>G : D ⥤ C</code> are adjoint is using
two natural transformations <code>η : 𝟭 C ⟶ F ⋙ G</code> and <code>ε : G ⋙ F ⟶ 𝟭 D</code>, called the unit and the
counit, such that the compositions <code>F ⟶ FGF ⟶ F</code> and <code>G ⟶ GFG ⟶ G</code> are the identity. Unfortunately,
it is not the case that the natural isomorphisms <code>η</code> and <code>ε</code> in the definition of an equivalence
automatically give an adjunction. However, it is true that</p><ul>
<li>if one of the two compositions is the identity, then so is the other, and</li>
<li>given an equivalence of categories, it is always possible to refine <code>η</code> in such a way that the
identities are satisfied.</li>
</ul><p>For this reason, in mathlib we define an equivalence to be a "half-adjoint equivalence", which is
a tuple <code>(F, G, η, ε)</code> as in the first paragraph such that the composite <code>F ⟶ FGF ⟶ F</code> is the
identity. By the remark above, this already implies that the tuple is an "adjoint equivalence",
i.e., that the composite <code>G ⟶ GFG ⟶ G</code> is also the identity.</p><p>We also define essentially surjective functors and show that a functor is an equivalence if and only
if it is full, faithful and essentially surjective.</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../.././Init/Core.html#Equivalence">Equivalence</a></code>: bundled (half-)adjoint equivalences of categories</li>
<li><code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">IsEquivalence</a></code>: type class on a functor <code>F</code> containing the data of the inverse <code>G</code> as well as
the natural isomorphisms <code>η</code> and <code>ε</code>.</li>
<li><code>EssSurj</code>: type class on a functor <code>F</code> containing the data of the preimages and the isomorphisms
<code>F.obj (preimage d) ≅ d</code>.</li>
</ul><h2 class="markdown-heading" id="Main-results">Main results <a class="hover-link" href="#Main-results">#</a></h2><ul>
<li><code><a href="../.././Init/Core.html#Equivalence.mk">Equivalence.mk</a></code>: upgrade an equivalence to a (half-)adjoint equivalence</li>
<li><code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.equivOfIso">IsEquivalence.equivOfIso</a></code>: when <code>F</code> and <code>G</code> are isomorphic functors, <code>F</code> is an equivalence
iff <code>G</code> is.</li>
<li><code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj">Equivalence.ofFullyFaithfullyEssSurj</a></code>: a fully faithful essentially surjective functor is an
equivalence.</li>
</ul><h2 class="markdown-heading" id="Notations">Notations <a class="hover-link" href="#Notations">#</a></h2><p>We write <code>C ≌ D</code> (<code>\backcong</code>, not to be confused with <code>≅</code>/<code>\cong</code>) for a bundled equivalence.</p></div><div class="decl" id="CategoryTheory.Equivalence"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L79-L91">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="decl_args">
<span class="fn">(D : <a href="../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max (max (max u₁ u₂) v₁) v₂)</div></div><p>We define an equivalence as a (half)-adjoint equivalence, a pair of functors with
a unit and counit which are natural isomorphisms and the triangle law <code>Fη ≫ εF = 1</code>, or in other
words the composite <code>F ⟶ FGF ⟶ F</code> is the identity.</p><p>In <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_inverse_comp">unit_inverse_comp</a></code>, we show that this is actually an adjoint equivalence, i.e., that the
composite <code>G ⟶ GFG ⟶ G</code> is also the identity.</p><p>The triangle equation is written as a family of equalities between morphisms, it is more
complicated if we write it as an equality of natural transformations, because then we would have
to insert natural transformations like <code>F ⟶ F1</code>.</p><p>See <https://stacks.math.columbia.edu/tag/001J></p><ul class="structure_ext"><li id="CategoryTheory.Equivalence.mk'" class="structure_ext_ctor">mk' :: (</li><ul class="structure_ext_fields"><li id="CategoryTheory.Equivalence.functor" class="structure_field"><div class="structure_field_info">functor : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span></div><div class="structure_field_doc"><p>A functor in one direction</p></div></li><li id="CategoryTheory.Equivalence.inverse" class="structure_field"><div class="structure_field_info">inverse : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>A functor in the other direction</p></div></li><li id="CategoryTheory.Equivalence.unitIso" class="structure_field"><div class="structure_field_info">unitIso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">self</span>.functor</span> <span class="fn"><span class="fn">self</span>.inverse</span></span></span></div><div class="structure_field_doc"><p>The composition <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ⋙ <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></code> is isomorphic to the identity</p></div></li><li id="CategoryTheory.Equivalence.counitIso" class="structure_field"><div class="structure_field_info">counitIso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">self</span>.inverse</span> <span class="fn"><span class="fn">self</span>.functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span></div><div class="structure_field_doc"><p>The composition <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ⋙ <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code> is also isomorphic to the identity</p></div></li><li id="CategoryTheory.Equivalence.functor_unitIso_comp" class="structure_field"><div class="structure_field_info">functor_unitIso_comp : <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
  <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.unitIso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.counitIso</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.functor</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.functor</span>.obj</span> <span class="fn">X</span></span>)</span></span></span></span></div><div class="structure_field_doc"><p>The natural isomorphisms compose to the identity.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-CategoryTheory.Equivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.«term_≌_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L97-L98">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.«term_≌_»"><span class="name">CategoryTheory</span>.<span class="name">«term_≌_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>We infix the usual notation for an equivalence</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.«term_≌_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.unit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L105-L106">source</a></div><div class="attributes">@[inline, reducible]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn"><span class="fn">e</span>.inverse</span></span></span></div></div><p>The unit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.unitIso</span>.hom</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.unit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.counit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L110-L111">source</a></div><div class="attributes">@[inline, reducible]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">e</span>.inverse</span> <span class="fn"><span class="fn">e</span>.functor</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span></div></div><p>The counit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.counitIso</span>.hom</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.counit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.unitInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L115-L116">source</a></div><div class="attributes">@[inline, reducible]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn"><span class="fn">e</span>.inverse</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span></span></div></div><p>The inverse of the unit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.unitIso</span>.inv</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.unitInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L120-L121">source</a></div><div class="attributes">@[inline, reducible]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">e</span>.inverse</span> <span class="fn"><span class="fn">e</span>.functor</span></span></span></div></div><p>The inverse of the counit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.counitIso</span>.inv</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.counitInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_unit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L127-L129">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(functor : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(inverse : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(unit_iso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">functor</span> <span class="fn">inverse</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(counit_iso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">inverse</span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
  <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">unit_iso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">counit_iso</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.obj</span> <span class="fn">X</span></span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">{ <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> }</span>.unit</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">unit_iso</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_counit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L133-L135">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(functor : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(inverse : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(unit_iso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">functor</span> <span class="fn">inverse</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(counit_iso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">inverse</span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
  <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">unit_iso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">counit_iso</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.obj</span> <span class="fn">X</span></span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">{ <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> }</span>.counit</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">counit_iso</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_unitInv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L139-L141">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(functor : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(inverse : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(unit_iso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">functor</span> <span class="fn">inverse</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(counit_iso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">inverse</span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
  <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">unit_iso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">counit_iso</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.obj</span> <span class="fn">X</span></span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">{ <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> }</span>.unitInv</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">unit_iso</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_counitInv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L145-L147">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(functor : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(inverse : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(unit_iso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">functor</span> <span class="fn">inverse</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(counit_iso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">inverse</span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
  <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">unit_iso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">counit_iso</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">functor</span>.obj</span> <span class="fn">X</span></span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">{ <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> }</span>.counitInv</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">counit_iso</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.functor_unit_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L150-L150">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor_unit_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.functor_unit_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L151-L153">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor_unit_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv_functor_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L156-L156">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv_functor_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv_functor_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L157-L161">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv_functor_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv_app_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L164-L168">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_app_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">X</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counit_app_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L171-L174">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit_app_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">X</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span>.app</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unit_inverse_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L179-L179">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_inverse_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unit_inverse_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L180-L201">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_inverse_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span>)</span></span></span></div></div><p>The other triangle equality. The proof follows the following proof in Globular:
http://globular.science/1905.001</p></div></div><div class="decl" id="CategoryTheory.Equivalence.inverse_counitInv_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L204-L204">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse_counitInv_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span>)</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inverse_counitInv_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L205-L209">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse_counitInv_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unit_app_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L212-L215">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_app_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">Y</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unitInv_app_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L218-L222">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv_app_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span>.app</span> <span class="fn">Y</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.fun_inv_map_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L225-L225">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fun_inv_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span>.app</span> <span class="fn">X</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">Y</span></span>)</span> <span class="fn">h</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.fun_inv_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L226-L228">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">f</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span>.app</span> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inv_fun_map_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L231-L231">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inv_fun_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">Y</span></span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span>.app</span> <span class="fn">X</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">Y</span></span>)</span> <span class="fn">h</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inv_fun_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L232-L234">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">f</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span>.app</span> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.adjointifyη"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L245-L253">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointifyη</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(η : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ε : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span></span></div></div><p>If <code>η : 𝟭 C ≅ F ⋙ G</code> is part of a (not necessarily half-adjoint) equivalence, we can upgrade it
to a refined natural isomorphism <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">adjointifyη</a> η : 𝟭 C ≅ F ⋙ G</code> which exhibits the properties
required for a half-adjoint equivalence. See <code><a href="../.././Init/Core.html#Equivalence.mk">Equivalence.mk</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.adjointifyη" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.adjointify_η_ε_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L256-L256">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointify_η_ε_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(η : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ε : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">CategoryTheory.Equivalence.adjointifyη</a> <span class="fn">η</span> <span class="fn">ε</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">ε</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.adjointify_η_ε"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L257-L265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointify_η_ε"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(η : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ε : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">CategoryTheory.Equivalence.adjointifyη</a> <span class="fn">η</span> <span class="fn">ε</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">ε</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L273-L274">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(η : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ε : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span></div></div><p>Every equivalence of categories consisting of functors <code>F</code> and <code>G</code> such that <code>F ⋙ G</code> and
<code>G ⋙ F</code> are naturally isomorphic to identity functors can be transformed into a half-adjoint
equivalence without changing <code>F</code> or <code>G</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk">CategoryTheory.Equivalence.mk</a> <span class="fn">F</span> <span class="fn">G</span> <span class="fn">η</span> <span class="fn">ε</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">functor</span> := <span class="fn">F</span>, <span class="fn">inverse</span> := <span class="fn">G</span>, <span class="fn">unitIso</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">CategoryTheory.Equivalence.adjointifyη</a> <span class="fn">η</span> <span class="fn">ε</span></span>, <span class="fn">counitIso</span> := <span class="fn">ε</span>,
    <span class="fn">functor_unitIso_comp</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L278-L278">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.Equivalence.refl</span>.counitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L278-L278">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.Equivalence.refl</span>.inverse</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L278-L278">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.Equivalence.refl</span>.unitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L278-L278">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.Equivalence.refl</span>.functor</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.refl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L279-L280">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span></div></div><p>Equivalence of categories is reflexive.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.refl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.instInhabitedEquivalence"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L283-L284">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.instInhabitedEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instInhabitedEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Equivalence.instInhabitedEquivalence</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">CategoryTheory.Equivalence.refl</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L287-L287">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.symm</span>.counitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.unitIso</span>.symm</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L287-L287">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.symm</span>.unitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.counitIso</span>.symm</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L287-L287">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.symm</span>.inverse</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.functor</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L287-L287">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.symm</span>.functor</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.inverse</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.symm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L288-L289">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span></div></div><p>Equivalence of categories is symmetric.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.symm</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">functor</span> := <span class="fn"><span class="fn">e</span>.inverse</span>, <span class="fn">inverse</span> := <span class="fn"><span class="fn">e</span>.functor</span>, <span class="fn">unitIso</span> := <span class="fn"><span class="fn"><span class="fn">e</span>.counitIso</span>.symm</span>, <span class="fn">counitIso</span> := <span class="fn"><span class="fn"><span class="fn">e</span>.unitIso</span>.symm</span>,
    <span class="fn">functor_unitIso_comp</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.symm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L295-L295">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.trans</span> <span class="fn">f</span></span>)</span>.functor</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn"><span class="fn">f</span>.functor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L295-L295">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.trans</span> <span class="fn">f</span></span>)</span>.unitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">e</span>.unitIso</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a> <span class="fn"><span class="fn">f</span>.unitIso</span> <span class="fn"><span class="fn">e</span>.inverse</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L295-L295">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.trans</span> <span class="fn">f</span></span>)</span>.counitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn"><span class="fn">f</span>.inverse</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a> <span class="fn"><span class="fn">e</span>.counitIso</span> <span class="fn"><span class="fn">f</span>.functor</span></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">f</span>.counitIso</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L295-L295">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.trans</span> <span class="fn">f</span></span>)</span>.inverse</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">f</span>.inverse</span> <span class="fn"><span class="fn">e</span>.inverse</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L296-L313">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span></div></div><p>Equivalence of categories is transitive.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.trans" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.funInvIdAssoc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L318-L319">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">e</span>.inverse</span> <span class="fn">F</span></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span></div></div><p>Composing a functor with both functors of an equivalence yields a naturally isomorphic
functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.funInvIdAssoc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.funInvIdAssoc_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L323-L326">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc">CategoryTheory.Equivalence.funInvIdAssoc</a> <span class="fn">e</span> <span class="fn">F</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span>.app</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.funInvIdAssoc_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L330-L333">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc">CategoryTheory.Equivalence.funInvIdAssoc</a> <span class="fn">e</span> <span class="fn">F</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.invFunIdAssoc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L338-L339">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">e</span>.inverse</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn">F</span></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span></div></div><p>Composing a functor with both functors of an equivalence yields a naturally isomorphic
functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.invFunIdAssoc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.invFunIdAssoc_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L343-L346">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">CategoryTheory.Equivalence.invFunIdAssoc</a> <span class="fn">e</span> <span class="fn">F</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span>.app</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.invFunIdAssoc_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L350-L353">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">CategoryTheory.Equivalence.invFunIdAssoc</a> <span class="fn">e</span> <span class="fn">F</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L357-L357">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">CategoryTheory.Equivalence.congrLeft</a> <span class="fn">e</span></span>)</span>.counitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>) =&gt; <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">CategoryTheory.Equivalence.invFunIdAssoc</a> <span class="fn">e</span> <span class="fn">F</span></span></span>)</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L357-L357">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">CategoryTheory.Equivalence.congrLeft</a> <span class="fn">e</span></span>)</span>.inverse</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringLeft">CategoryTheory.whiskeringLeft</a> <span class="fn">C</span> <span class="fn">D</span> <span class="fn">E</span></span>)</span>.obj</span> <span class="fn"><span class="fn">e</span>.functor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L357-L357">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">CategoryTheory.Equivalence.congrLeft</a> <span class="fn">e</span></span>)</span>.unitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">CategoryTheory.Equivalence.adjointifyη</a>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
      <span class="fn">(<span class="fn">fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc">CategoryTheory.Equivalence.funInvIdAssoc</a> <span class="fn">e</span> <span class="fn">F</span></span>)</span>.symm</span></span>)</span> <span class="fn">⋯</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
      <span class="fn">(<span class="fn">fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>) =&gt; <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">CategoryTheory.Equivalence.invFunIdAssoc</a> <span class="fn">e</span> <span class="fn">F</span></span></span>)</span> <span class="fn">⋯</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L357-L357">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">CategoryTheory.Equivalence.congrLeft</a> <span class="fn">e</span></span>)</span>.functor</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringLeft">CategoryTheory.whiskeringLeft</a> <span class="fn">D</span> <span class="fn">C</span> <span class="fn">E</span></span>)</span>.obj</span> <span class="fn"><span class="fn">e</span>.inverse</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L358-L361">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span></span></div></div><p>If <code>C</code> is equivalent to <code>D</code>, then <code>C ⥤ E</code> is equivalent to <code>D ⥤ E</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.congrLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L365-L365">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">CategoryTheory.Equivalence.congrRight</a> <span class="fn">e</span></span>)</span>.unitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">CategoryTheory.Equivalence.adjointifyη</a>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
      <span class="fn">(<span class="fn">fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">E</span> <span class="fn">C</span></span>) =&gt;
        <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.rightUnitor">CategoryTheory.Functor.rightUnitor</a> <span class="fn">F</span></span>)</span>.symm</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>           <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn">F</span> <span class="fn"><span class="fn">e</span>.unitIso</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">CategoryTheory.Functor.associator</a> <span class="fn">F</span> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn"><span class="fn">e</span>.inverse</span></span></span></span></span>)</span>
      <span class="fn">⋯</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
      <span class="fn">(<span class="fn">fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">E</span> <span class="fn">D</span></span>) =&gt;
        <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">CategoryTheory.Functor.associator</a> <span class="fn">F</span> <span class="fn"><span class="fn">e</span>.inverse</span> <span class="fn"><span class="fn">e</span>.functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>           <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn">F</span> <span class="fn"><span class="fn">e</span>.counitIso</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.rightUnitor">CategoryTheory.Functor.rightUnitor</a> <span class="fn">F</span></span></span></span></span>)</span>
      <span class="fn">⋯</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L365-L365">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">CategoryTheory.Equivalence.congrRight</a> <span class="fn">e</span></span>)</span>.inverse</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringRight">CategoryTheory.whiskeringRight</a> <span class="fn">E</span> <span class="fn">D</span> <span class="fn">C</span></span>)</span>.obj</span> <span class="fn"><span class="fn">e</span>.inverse</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L365-L365">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">CategoryTheory.Equivalence.congrRight</a> <span class="fn">e</span></span>)</span>.functor</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringRight">CategoryTheory.whiskeringRight</a> <span class="fn">E</span> <span class="fn">C</span> <span class="fn">D</span></span>)</span>.obj</span> <span class="fn"><span class="fn">e</span>.functor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L365-L365">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">CategoryTheory.Equivalence.congrRight</a> <span class="fn">e</span></span>)</span>.counitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">E</span> <span class="fn">D</span></span>) =&gt;
      <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">CategoryTheory.Functor.associator</a> <span class="fn">F</span> <span class="fn"><span class="fn">e</span>.inverse</span> <span class="fn"><span class="fn">e</span>.functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>         <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn">F</span> <span class="fn"><span class="fn">e</span>.counitIso</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.rightUnitor">CategoryTheory.Functor.rightUnitor</a> <span class="fn">F</span></span></span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L366-L371">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">E</span> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">E</span> <span class="fn">D</span></span></span></div></div><p>If <code>C</code> is equivalent to <code>D</code>, then <code>E ⥤ C</code> is equivalent to <code>E ⥤ D</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.congrRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unit_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L384-L385">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">Y</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">Y</span></span>)</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unitInv_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L389-L390">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unitInv_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">Y</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">Y</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span>.app</span> <span class="fn">Y</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitInv</span>.app</span> <span class="fn">Y</span></span>)</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counit_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L394-L395">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counit_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.obj</span> <span class="fn">Y</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span>.app</span> <span class="fn">Y</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counit</span>.app</span> <span class="fn">Y</span></span>)</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counitInv_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L399-L400">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">Y</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">Y</span></span>)</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unit_right_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L404-L406">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unit_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{W : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X' : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g' : <span class="fn"><span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">g'</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counitInv_right_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L410-L412">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counitInv_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{W : <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X' : <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g' : <span class="fn"><span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">g'</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unit_right_assoc'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L416-L419">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unit_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{W : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X' : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y' : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g' : <span class="fn"><span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><span class="fn">Y'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span>
      <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">Z</span></span>)</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span>
      <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unit</span>.app</span> <span class="fn">Z</span></span>)</span></span>)</span></span>)</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">h'</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counitInv_right_assoc'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L423-L426">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counitInv_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{W : <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X' : <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y' : <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g' : <span class="fn"><span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><span class="fn">Y'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span>
      <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">Z</span></span>)</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span>
      <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitInv</span>.app</span> <span class="fn">Z</span></span>)</span></span>)</span></span>)</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">h'</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.powNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L437-L440">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">powNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn">(<span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span>)</span></span></div></div><p>Natural number powers of an auto-equivalence.  Use <code>(^)</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">CategoryTheory.Equivalence.powNat</a> <span class="fn">e</span> <span class="fn">0</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.Equivalence.refl</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">CategoryTheory.Equivalence.powNat</a> <span class="fn">e</span> <span class="fn">1</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">CategoryTheory.Equivalence.powNat</a> <span class="fn">e</span> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.trans</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">CategoryTheory.Equivalence.powNat</a> <span class="fn">e</span> <span class="fn">(<span class="fn"><span class="fn">n</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.powNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.pow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L444-L446">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a> → <span class="fn">(<span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span>)</span></span></div></div><p>Powers of an auto-equivalence.  Use <code>(^)</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow">CategoryTheory.Equivalence.pow</a> <span class="fn">e</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn"><a href="../.././Init/Data/Int/Basic.html#Int.negSucc">Int.ofNat</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">CategoryTheory.Equivalence.powNat</a> <span class="fn">e</span> <span class="fn">n</span></span>
  | <span class="fn"><a href="../.././Init/Data/Int/Basic.html#Int.negSucc">Int.negSucc</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">CategoryTheory.Equivalence.powNat</a> <span class="fn"><span class="fn">e</span>.symm</span> <span class="fn">(<span class="fn"><span class="fn">n</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.pow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.instPowEquivalenceInt"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L449-L450">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.instPowEquivalenceInt"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instPowEquivalenceInt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Pow">Pow</a> <span class="fn">(<span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span>)</span> <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Equivalence.instPowEquivalenceInt</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pow</span> := <span class="fn">CategoryTheory.Equivalence.pow</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.pow_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L453-L454">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow_zero"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span> <a href="../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">0</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.Equivalence.refl</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.pow_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L458-L459">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span> <a href="../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">1</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.pow_neg_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L463-L464">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow_neg_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_neg_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span> <a href="../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">(<span class="fn">-<span class="fn">1</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.symm</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L474-L486">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max (max (max u₁ u₂) v₁) v₂)</div></div><p>A functor that is part of a (half) adjoint equivalence</p><ul class="structure_ext"><li id="CategoryTheory.IsEquivalence.mk'" class="structure_ext_ctor">mk' :: (</li><ul class="structure_ext_fields"><li id="CategoryTheory.IsEquivalence.inverse" class="structure_field"><div class="structure_field_info">inverse : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>The inverse functor to <code>F</code></p></div></li><li id="CategoryTheory.IsEquivalence.unitIso" class="structure_field"><div class="structure_field_info">unitIso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.inverse">CategoryTheory.IsEquivalence.inverse</a> <span class="fn">F</span></span>)</span></span></span></div><div class="structure_field_doc"><p>Composition <code>F ⋙ <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></code> is isomorphic to the identity.</p></div></li><li id="CategoryTheory.IsEquivalence.counitIso" class="structure_field"><div class="structure_field_info">counitIso : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.inverse">CategoryTheory.IsEquivalence.inverse</a> <span class="fn">F</span></span>)</span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span></div><div class="structure_field_doc"><p>Composition <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ⋙ F</code> is isomorphic to the identity.</p></div></li><li id="CategoryTheory.IsEquivalence.functor_unitIso_comp" class="structure_field"><div class="structure_field_info">functor_unitIso_comp : <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
  <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.unitIso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.counitIso</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span></span>)</span></span></span></span></div><div class="structure_field_doc"><p>The natural isomorphisms are inverse.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsEquivalence" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsEquivalence.functor_unitIso_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L492-L492">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.functor_unitIso_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">functor_unitIso_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.unitIso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.counitIso</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence.ofEquivalence"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L496-L497">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofEquivalence"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn"><span class="fn">F</span>.functor</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofEquivalence">CategoryTheory.IsEquivalence.ofEquivalence</a> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">inverse</span> := <span class="fn"><span class="fn">F</span>.inverse</span>, <span class="fn">unitIso</span> := <span class="fn"><span class="fn">F</span>.unitIso</span>, <span class="fn">counitIso</span> := <span class="fn"><span class="fn">F</span>.counitIso</span>, <span class="fn">functor_unitIso_comp</span> := <span class="fn">⋯</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.IsEquivalence.ofEquivalenceInverse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L500-L501">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofEquivalenceInverse"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofEquivalenceInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn"><span class="fn">F</span>.inverse</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofEquivalenceInverse">CategoryTheory.IsEquivalence.ofEquivalenceInverse</a> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofEquivalence">CategoryTheory.IsEquivalence.ofEquivalence</a> <span class="fn"><span class="fn">F</span>.symm</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.IsEquivalence.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L508-L509">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.mk"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(η : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ε : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">D</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span></div></div><p>To see that a functor is an equivalence, it suffices to provide an inverse functor <code>G</code> such that
<code>F ⋙ G</code> and <code>G ⋙ F</code> are naturally isomorphic to identity functors.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.mk">CategoryTheory.IsEquivalence.mk</a> <span class="fn">G</span> <span class="fn">η</span> <span class="fn">ε</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">inverse</span> := <span class="fn">G</span>, <span class="fn">unitIso</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">CategoryTheory.Equivalence.adjointifyη</a> <span class="fn">η</span> <span class="fn">ε</span></span>, <span class="fn">counitIso</span> := <span class="fn">ε</span>, <span class="fn">functor_unitIso_comp</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsEquivalence.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.asEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L517-L519">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span></div></div><p>Interpret a functor that is an equivalence as an equivalence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Functor.asEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalenceRefl"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L522-L523">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalenceRefl"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalenceRefl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Functor.isEquivalenceRefl</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofEquivalence">CategoryTheory.IsEquivalence.ofEquivalence</a> <span class="fn">CategoryTheory.Equivalence.refl</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.inv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L527-L528">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span></div></div><p>The inverse functor of a functor that is an equivalence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.inverse">CategoryTheory.IsEquivalence.inverse</a> <span class="fn">F</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.inv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalenceInv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L531-L532">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalenceInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalenceInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">F</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalenceInv">CategoryTheory.Functor.isEquivalenceInv</a> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofEquivalence">CategoryTheory.IsEquivalence.ofEquivalence</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">F</span></span>)</span>.symm</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.asEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L536-L537">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">F</span></span>)</span>.functor</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">F</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.asEquivalence_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L541-L542">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">F</span></span>)</span>.inverse</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">F</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.asEquivalence_unit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L546-L548">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence_unit"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_unit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">F</span></span>)</span>.unitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.IsEquivalence.unitIso</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.asEquivalence_counit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L552-L554">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence_counit"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_counit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">F</span></span>)</span>.counitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.IsEquivalence.counitIso</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.inv_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L558-L559">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv_inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">F</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">F</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalenceTrans"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L564-L566">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalenceTrans"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalenceTrans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalenceTrans">CategoryTheory.Functor.isEquivalenceTrans</a> <span class="fn">F</span> <span class="fn">G</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofEquivalence">CategoryTheory.IsEquivalence.ofEquivalence</a>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">F</span></span>)</span>.trans</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">G</span></span>)</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.instIsEquivalenceFunctorCategoryFunctorCategoryObjFunctorToQuiverToCategoryStructCategoryFunctorToQuiverToCategoryStructCategoryToPrefunctorWhiskeringLeft"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L569-L570">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.instIsEquivalenceFunctorCategoryFunctorCategoryObjFunctorToQuiverToCategoryStructCategoryFunctorToQuiverToCategoryStructCategoryToPrefunctorWhiskeringLeft"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceFunctorCategoryFunctorCategoryObjFunctorToQuiverToCategoryStructCategoryFunctorToQuiverToCategoryStructCategoryToPrefunctorWhiskeringLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringLeft">CategoryTheory.whiskeringLeft</a> <span class="fn">C</span> <span class="fn">D</span> <span class="fn">E</span></span>)</span>.obj</span> <span class="fn">F</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.instIsEquivalenceFunctorCategoryFunctorCategoryObjFunctorToQuiverToCategoryStructCategoryFunctorToQuiverToCategoryStructCategoryToPrefunctorWhiskeringRight"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L572-L573">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.instIsEquivalenceFunctorCategoryFunctorCategoryObjFunctorToQuiverToCategoryStructCategoryFunctorToQuiverToCategoryStructCategoryToPrefunctorWhiskeringRight"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceFunctorCategoryFunctorCategoryObjFunctorToQuiverToCategoryStructCategoryFunctorToQuiverToCategoryStructCategoryToPrefunctorWhiskeringRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringRight">CategoryTheory.whiskeringRight</a> <span class="fn">E</span> <span class="fn">C</span> <span class="fn">D</span></span>)</span>.obj</span> <span class="fn">F</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.functor_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L580-L581">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor_inv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn"><span class="fn">E</span>.functor</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">E</span>.inverse</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inverse_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L585-L586">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse_inv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn"><span class="fn">E</span>.inverse</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">E</span>.functor</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.isEquivalence_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L590-L591">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.isEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.unitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">E</span>.unitIso</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.isEquivalence_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L594-L595">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.isEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.counitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">E</span>.counitIso</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.functor_asEquivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L598-L600">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor_asEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_asEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn"><span class="fn">E</span>.functor</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">E</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inverse_asEquivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L604-L606">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse_asEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_asEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn"><span class="fn">E</span>.inverse</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">E</span>.symm</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence.fun_inv_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L614-L617">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">fun_inv_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">F</span></span>)</span>.counit</span>.app</span> <span class="fn">X</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">F</span></span>)</span>.counitInv</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence.inv_fun_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L621-L624">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">inv_fun_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">f</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">F</span></span>)</span>.unitInv</span>.app</span> <span class="fn">X</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">F</span></span>)</span>.unit</span>.app</span> <span class="fn">Y</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence.ofIso_unitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L629-L629">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_unitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.unitIso</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.inverse">CategoryTheory.IsEquivalence.inverse</a> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.unitIso</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence.ofIso_unitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L629-L629">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_unitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.unitIso</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.unitIso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.inverse">CategoryTheory.IsEquivalence.inverse</a> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence.ofIso_counitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L629-L629">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_counitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.counitIso</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.counitIso</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.inverse">CategoryTheory.IsEquivalence.inverse</a> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence.ofIso_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L629-L629">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso_inverse"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.inverse">CategoryTheory.IsEquivalence.inverse</a> <span class="fn">G</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.inverse">CategoryTheory.IsEquivalence.inverse</a> <span class="fn">F</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence.ofIso_counitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L629-L629">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_counitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.counitIso</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.inverse">CategoryTheory.IsEquivalence.inverse</a> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.counitIso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence.ofIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L630-L644">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span></div></div><p>When a functor <code>F</code> is an equivalence of categories, and <code>G</code> is isomorphic to <code>F</code>, then
<code>G</code> is also an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsEquivalence.ofIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsEquivalence.ofIso_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L648-L653">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso_trans"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e' : <span class="fn"><span class="fn">G</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso">CategoryTheory.IsEquivalence.ofIso</a> <span class="fn">e'</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso">CategoryTheory.IsEquivalence.ofIso</a> <span class="fn">e</span> <span class="fn">hF</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso">CategoryTheory.IsEquivalence.ofIso</a> <span class="fn">(<span class="fn"><span class="fn">e</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn">e'</span></span>)</span> <span class="fn">hF</span></span></span></div></div><p>Compatibility of <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso">ofIso</a></code> with the composition of isomorphisms of functors</p></div></div><div class="decl" id="CategoryTheory.IsEquivalence.ofIso_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L657-L662">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso_refl"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">ofIso_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso">CategoryTheory.IsEquivalence.ofIso</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">F</span></span>)</span> <span class="fn">hF</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">hF</span></span></div></div><p>Compatibility of <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso">ofIso</a></code> with identity isomorphisms of functors</p></div></div><div class="decl" id="CategoryTheory.IsEquivalence.equivOfIso_symm_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L666-L666">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.equivOfIso_symm_apply"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">equivOfIso_symm_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.equivOfIso">CategoryTheory.IsEquivalence.equivOfIso</a> <span class="fn">e</span></span>)</span>.symm</span> <span class="fn">hF</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso">CategoryTheory.IsEquivalence.ofIso</a> <span class="fn"><span class="fn">e</span>.symm</span> <span class="fn">hF</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence.equivOfIso_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L666-L666">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.equivOfIso_apply"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">equivOfIso_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.equivOfIso">CategoryTheory.IsEquivalence.equivOfIso</a> <span class="fn">e</span></span>)</span> <span class="fn">hF</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso">CategoryTheory.IsEquivalence.ofIso</a> <span class="fn">e</span> <span class="fn">hF</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsEquivalence.equivOfIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L667-L672">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.equivOfIso"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">equivOfIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span></span></div></div><p>When <code>F</code> and <code>G</code> are two isomorphic functors, then <code>F</code> is an equivalence iff <code>G</code> is.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.equivOfIso">CategoryTheory.IsEquivalence.equivOfIso</a> <span class="fn">e</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">toFun</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso">CategoryTheory.IsEquivalence.ofIso</a> <span class="fn">e</span></span>, <span class="fn">invFun</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.ofIso">CategoryTheory.IsEquivalence.ofIso</a> <span class="fn"><span class="fn">e</span>.symm</span></span>, <span class="fn">left_inv</span> := <span class="fn">⋯</span>,
    <span class="fn">right_inv</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsEquivalence.equivOfIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsEquivalence.cancelCompRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L677-L680">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.cancelCompRight"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">cancelCompRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hG : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span></span> → <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span></span></div></div><p>If <code>G</code> and <code>F ⋙ G</code> are equivalence of categories, then <code>F</code> is also an equivalence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsEquivalence.cancelCompRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsEquivalence.cancelCompLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L685-L689">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence.cancelCompLeft"><span class="name">CategoryTheory</span>.<span class="name">IsEquivalence</span>.<span class="name">cancelCompLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span></span> → <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span></span></div></div><p>If <code>F</code> and <code>F ⋙ G</code> are equivalence of categories, then <code>G</code> is also an equivalence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsEquivalence.cancelCompLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.essSurj_of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L700-L701">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.essSurj_of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurj_of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">F</span></span></div></div><p>An equivalence is essentially surjective.</p><p>See <https://stacks.math.columbia.edu/tag/02C3>.</p></div></div><div class="decl" id="CategoryTheory.Equivalence.faithfulOfEquivalence"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L709-L712">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.faithfulOfEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">faithfulOfEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">F</span></span></div></div><p>An equivalence is faithful.</p><p>See <https://stacks.math.columbia.edu/tag/02C3>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.fullOfEquivalence"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L720-L726">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fullOfEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullOfEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Full">CategoryTheory.Full</a> <span class="fn">F</span></span></div></div><p>An equivalence is full.</p><p>See <https://stacks.math.columbia.edu/tag/02C3>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L744-L751">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullyFaithfullyEssSurj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Full">CategoryTheory.Full</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span></div></div><p>A functor which is full, faithful, and essentially surjective is an equivalence.</p><p>See <https://stacks.math.columbia.edu/tag/02C3>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.functor_map_inj_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L755-L757">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor_map_inj_iff"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_map_inj_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.map</span> <span class="fn">g</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inverse_map_inj_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L761-L763">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse_map_inj_iff"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_map_inj_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.map</span> <span class="fn">g</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.essSurjInducedFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L766-L767">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.essSurjInducedFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurjInducedFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C' : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C'</span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.inducedFunctor">CategoryTheory.inducedFunctor</a> <span class="fn">⇑<span class="fn">e</span></span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.inducedFunctorOfEquiv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L770-L772">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inducedFunctorOfEquiv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inducedFunctorOfEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C' : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C'</span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.inducedFunctor">CategoryTheory.inducedFunctor</a> <span class="fn">⇑<span class="fn">e</span></span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inducedFunctorOfEquiv">CategoryTheory.Equivalence.inducedFunctorOfEquiv</a> <span class="fn">e</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj">CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.inducedFunctor">CategoryTheory.inducedFunctor</a> <span class="fn">⇑<span class="fn">e</span></span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.fullyFaithfulToEssImage"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L775-L777">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fullyFaithfulToEssImage"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulToEssImage</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Full">CategoryTheory.Full</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.toEssImage">CategoryTheory.Functor.toEssImage</a> <span class="fn">F</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fullyFaithfulToEssImage">CategoryTheory.Equivalence.fullyFaithfulToEssImage</a> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj">CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.toEssImage">CategoryTheory.Functor.toEssImage</a> <span class="fn">F</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.compInvIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L787-L787">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInvIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInvIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">H</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInvIso">CategoryTheory.Iso.compInvIso</a> <span class="fn">i</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">H</span></span>)</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.unitIso</span>.inv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.compInvIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L787-L787">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInvIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInvIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">H</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInvIso">CategoryTheory.Iso.compInvIso</a> <span class="fn">i</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.unitIso</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">H</span></span>)</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.compInvIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L788-L790">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInvIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInvIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">H</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">H</span></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span></div></div><p>Construct an isomorphism <code>F ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a> ≅ G</code> from an isomorphism <code>F ≅ G ⋙ H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Iso.compInvIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.compInverseIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L794-L794">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn"><span class="fn">H</span>.functor</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso">CategoryTheory.Iso.compInverseIso</a> <span class="fn">i</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.unitIso</span>.inv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.compInverseIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L794-L794">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn"><span class="fn">H</span>.functor</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso">CategoryTheory.Iso.compInverseIso</a> <span class="fn">i</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.unitIso</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.compInverseIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L795-L796">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn"><span class="fn">H</span>.functor</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn"><span class="fn">H</span>.inverse</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span></div></div><p>Construct an isomorphism <code>F ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ≅ G</code> from an isomorphism <code>F ≅ G ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso">CategoryTheory.Iso.compInverseIso</a> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInvIso">CategoryTheory.Iso.compInvIso</a> <span class="fn">i</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.compInverseIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInv_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L799-L799">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInv_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInv_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">H</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInv">CategoryTheory.Iso.isoCompInv</a> <span class="fn">i</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.unitIso</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">H</span></span>)</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInv_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L799-L799">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInv_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInv_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">H</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInv">CategoryTheory.Iso.isoCompInv</a> <span class="fn">i</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">H</span></span>)</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.unitIso</span>.inv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L800-L801">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInv"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">H</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">H</span></span>)</span></span></span></div></div><p>Construct an isomorphism <code>G ≅ F ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a></code> from an isomorphism <code>G ⋙ H ≅ F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInv">CategoryTheory.Iso.isoCompInv</a> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInvIso">CategoryTheory.Iso.compInvIso</a> <span class="fn"><span class="fn">i</span>.symm</span></span>)</span>.symm</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoCompInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInverse_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L805-L805">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn"><span class="fn">H</span>.functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse">CategoryTheory.Iso.isoCompInverse</a> <span class="fn">i</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.unitIso</span>.inv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInverse_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L805-L805">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn"><span class="fn">H</span>.functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse">CategoryTheory.Iso.isoCompInverse</a> <span class="fn">i</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.unitIso</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.inverse</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L806-L807">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn"><span class="fn">H</span>.functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn"><span class="fn">H</span>.inverse</span></span></span></div></div><p>Construct an isomorphism <code>G ≅ F ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></code> from an isomorphism <code>G ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ≅ F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse">CategoryTheory.Iso.isoCompInverse</a> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInv">CategoryTheory.Iso.isoCompInv</a> <span class="fn">i</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoCompInverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.invCompIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L810-L810">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.invCompIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">invCompIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.invCompIso">CategoryTheory.Iso.invCompIso</a> <span class="fn">i</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">G</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.counitIso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.invCompIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L810-L810">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.invCompIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">invCompIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.invCompIso">CategoryTheory.Iso.invCompIso</a> <span class="fn">i</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.counitIso</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.inv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">G</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.invCompIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L811-L813">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.invCompIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">invCompIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">G</span></span>)</span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H</span></span></div></div><p>Construct an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a> ⋙ F ≅ H</code> from an isomorphism <code>F ≅ G ⋙ H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Iso.invCompIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.inverseCompIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L817-L817">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">G</span>.functor</span> <span class="fn">H</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso">CategoryTheory.Iso.inverseCompIso</a> <span class="fn">i</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.inverse</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.counitIso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.inverseCompIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L817-L817">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">G</span>.functor</span> <span class="fn">H</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso">CategoryTheory.Iso.inverseCompIso</a> <span class="fn">i</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.counitIso</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.inv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.inverse</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.inverseCompIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L818-L819">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">G</span>.functor</span> <span class="fn">H</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">G</span>.inverse</span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H</span></span></div></div><p>Construct an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ⋙ F ≅ H</code> from an isomorphism <code>F ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ⋙ H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso">CategoryTheory.Iso.inverseCompIso</a> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.invCompIso">CategoryTheory.Iso.invCompIso</a> <span class="fn">i</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.inverseCompIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoInvComp_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L822-L822">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInvComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInvComp_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInvComp">CategoryTheory.Iso.isoInvComp</a> <span class="fn">i</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.counitIso</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">G</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInvComp_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L822-L822">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInvComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInvComp_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInvComp">CategoryTheory.Iso.isoInvComp</a> <span class="fn">i</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.inv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">G</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.IsEquivalence.counitIso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInvComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L823-L824">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInvComp"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInvComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">H</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">G</span></span>)</span> <span class="fn">F</span></span></span></div></div><p>Construct an isomorphism <code>H ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a> ⋙ F</code> from an isomorphism <code>G ⋙ H ≅ F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInvComp">CategoryTheory.Iso.isoInvComp</a> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.invCompIso">CategoryTheory.Iso.invCompIso</a> <span class="fn"><span class="fn">i</span>.symm</span></span>)</span>.symm</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoInvComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseComp_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L828-L828">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">G</span>.functor</span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp">CategoryTheory.Iso.isoInverseComp</a> <span class="fn">i</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.inv</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.inverse</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.counitIso</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseComp_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L828-L828">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">G</span>.functor</span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp">CategoryTheory.Iso.isoInverseComp</a> <span class="fn">i</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.counitIso</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.hom</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.inverse</span>.obj</span> <span class="fn">X</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L829-L830">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">G</span>.functor</span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">H</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn"><span class="fn">G</span>.inverse</span> <span class="fn">F</span></span></span></div></div><p>Construct an isomorphism <code>H ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ⋙ F</code> from an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ⋙ H ≅ F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp">CategoryTheory.Iso.isoInverseComp</a> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInvComp">CategoryTheory.Iso.isoInvComp</a> <span class="fn">i</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoInverseComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.compInvIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L835-L835">source</a></div><div class="attributes">@[deprecated CategoryTheory.Iso.compInvIso]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.compInvIso"><span class="name">CategoryTheory</span>.<span class="name">compInvIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">H</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">H</span></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInvIso">CategoryTheory.Iso.compInvIso</a></code>.</p><hr></hr><p>Construct an isomorphism <code>F ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a> ≅ G</code> from an isomorphism <code>F ≅ G ⋙ H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.compInvIso">@<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.compInvIso">CategoryTheory.compInvIso</a></a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInvIso">@<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInvIso">CategoryTheory.Iso.compInvIso</a></a></span></li></ul></details><details id="instances-for-list-CategoryTheory.compInvIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.isoCompInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L836-L836">source</a></div><div class="attributes">@[deprecated CategoryTheory.Iso.isoCompInv]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.isoCompInv"><span class="name">CategoryTheory</span>.<span class="name">isoCompInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">H</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">H</span></span>)</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInv">CategoryTheory.Iso.isoCompInv</a></code>.</p><hr></hr><p>Construct an isomorphism <code>G ≅ F ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a></code> from an isomorphism <code>G ⋙ H ≅ F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.isoCompInv">@<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.isoCompInv">CategoryTheory.isoCompInv</a></a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInv">@<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInv">CategoryTheory.Iso.isoCompInv</a></a></span></li></ul></details><details id="instances-for-list-CategoryTheory.isoCompInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.invCompIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L837-L837">source</a></div><div class="attributes">@[deprecated CategoryTheory.Iso.invCompIso]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.invCompIso"><span class="name">CategoryTheory</span>.<span class="name">invCompIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">G</span></span>)</span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.invCompIso">CategoryTheory.Iso.invCompIso</a></code>.</p><hr></hr><p>Construct an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a> ⋙ F ≅ H</code> from an isomorphism <code>F ≅ G ⋙ H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.invCompIso">@<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.invCompIso">CategoryTheory.invCompIso</a></a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.invCompIso">@<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.invCompIso">CategoryTheory.Iso.invCompIso</a></a></span></li></ul></details><details id="instances-for-list-CategoryTheory.invCompIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.isoInvComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Equivalence.lean#L838-L838">source</a></div><div class="attributes">@[deprecated CategoryTheory.Iso.isoInvComp]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.isoInvComp"><span class="name">CategoryTheory</span>.<span class="name">isoInvComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">G</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">G</span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">H</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">CategoryTheory.Functor.inv</a> <span class="fn">G</span></span>)</span> <span class="fn">F</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInvComp">CategoryTheory.Iso.isoInvComp</a></code>.</p><hr></hr><p>Construct an isomorphism <code>H ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a> ⋙ F</code> from an isomorphism <code>G ⋙ H ≅ F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.isoInvComp">@<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.isoInvComp">CategoryTheory.isoInvComp</a></a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInvComp">@<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInvComp">CategoryTheory.Iso.isoInvComp</a></a></span></li></ul></details><details id="instances-for-list-CategoryTheory.isoInvComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>