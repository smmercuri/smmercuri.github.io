<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Filtered.Basic</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Filtered.Basic";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Filtered</span>.<span class="name">Basic</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/PEmpty.html">Mathlib.CategoryTheory.PEmpty</a></li><li><a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html">Mathlib.CategoryTheory.Adjunction.Basic</a></li><li><a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html">Mathlib.CategoryTheory.Category.Preorder</a></li><li><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html">Mathlib.CategoryTheory.Category.ULift</a></li><li><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html">Mathlib.CategoryTheory.FinCategory.Basic</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html">Mathlib.CategoryTheory.Limits.Cones</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.html">Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Filtered.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.cocone_objs"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">cocone_objs</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.cocone_maps"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">cocone_maps</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_semilatticeSup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_semilatticeSup_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_directed_le"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_directed_le</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_directed_le_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_directed_le_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredDiscretePUnit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.max"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.leftToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">leftToMax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.rightToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">rightToMax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeqHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeqHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_right_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_isRightAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_objs_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.toSup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.toSup_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup_commutes</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.cocone"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_right_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isRightAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_cocone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_hasFiniteColimits"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasFiniteColimits</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_isTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isTerminal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_hasTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasTerminal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.iff_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">iff_cocone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.max₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.firstToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">firstToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.secondToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">secondToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.thirdToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">thirdToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃Hom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃Hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₁"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₁</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₂"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₂</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.span"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">span</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">bowtie</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.tulip"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">tulip</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.cone_objs"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">cone_objs</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.cone_maps"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">cone_maps</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_semilatticeInf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_semilatticeInf_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_directed_ge</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_directed_ge_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_directed_ge_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredDiscretePUnit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.min"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">min</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.minToLeft"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.minToRight"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eqHom"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eqHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cospan</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.ranges_directed"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">ranges_directed</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_left_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_isLeftAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_objs_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.infTo"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.infTo_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo_commutes</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cone"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_left_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isLeftAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_cone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_hasFiniteLimits"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasFiniteLimits</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_isInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isInitial</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_hasInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasInitial</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cofiltered_of_hasFiniteLimits"><span class="name">CategoryTheory</span>.<span class="name">cofiltered_of_hasFiniteLimits</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.iff_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">iff_cone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_op_of_isFilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_op_of_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_of_isFiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_op_of_isCofilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_op_of_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_of_isCofiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_isFilteredOrEmpty_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_isCofilteredOrEmpty_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_isFiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_isFiltered_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_isCofiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_isCofiltered_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULift</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULift</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredAsSmall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredAsSmall</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Filtered-categories">Filtered categories <a class="hover-link" href="#Filtered-categories">#</a></h1><p>A category is filtered if every finite diagram admits a cocone.
We give a simple characterisation of this condition as</p><ol>
<li>for every pair of objects there exists another object &quot;to the right&quot;,</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><p>Filtered colimits are often better behaved than arbitrary colimits.
See <code>CategoryTheory/Limits/Types</code> for some details.</p><p>Filtered categories are nice because colimits indexed by filtered categories tend to be
easier to describe than general colimits (and more often preserved by functors).</p><p>In this file we show that any functor from a finite category to a filtered category admits a cocone:</p><ul>
<li><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone_nonempty">cocone_nonempty</a> [FinCategory J] [IsFiltered C] (F : J ⥤ C) : <a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> (Cocone F)</code>
More generally,
for any finite collection of objects and morphisms between them in a filtered category
(even if not closed under composition) there exists some object <code>Z</code> receiving maps from all of them,
so that all the triangles (one edge from the finite set, two from morphisms to <code>Z</code>) commute.
This formulation is often more useful in practice and is available via <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_exists">sup_exists</a></code>,
which takes a finset of objects, and an indexed family (indexed by source and target)
of finsets of morphisms.</li>
</ul><p>We also prove the converse of <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone_nonempty">cocone_nonempty</a></code> as <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_cocone_nonempty">of_cocone_nonempty</a></code>.</p><p>Furthermore, we give special support for two diagram categories: The <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie">bowtie</a></code> and the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip">tulip</a></code>.
This is because these shapes show up in the proofs that forgetful functors of algebraic categories
(e.g. <code>MonCat</code>, <code>CommRingCat</code>, ...) preserve filtered colimits.</p><p>All of the above API, except for the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie">bowtie</a></code> and the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip">tulip</a></code>, is also provided for cofiltered
categories.</p><h2 class="markdown-heading" id="See-also">See also <a class="hover-link" href="#See-also">#</a></h2><p>In <code>CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit</code> we show that filtered colimits
commute with finite limits.</p><p>There is another characterization of filtered categories, namely that whenever <code>F : J ⥤ C</code> is a
functor from a finite category, there is <code>X : C</code> such that <code><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> (limit (F.op ⋙ yoneda.obj X))</code>.
This is shown in <code>CategoryTheory.Limits.Filtered</code>.</p></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L74-L79">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a></code> if</p><ol>
<li>for every pair of objects there exists another object &quot;to the right&quot;, and</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal.</li>
</ol><ul class="structure_fields" id="CategoryTheory.IsFilteredOrEmpty.mk"><li id="CategoryTheory.IsFilteredOrEmpty.cocone_objs" class="structure_field"><div class="structure_field_info">cocone_objs : <span class="fn">∀ (<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>), <span class="fn">∃ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span></span></div><div class="structure_field_doc"><p>for every pair of objects there exists another object &quot;to the right&quot;</p></div></li><li id="CategoryTheory.IsFilteredOrEmpty.cocone_maps" class="structure_field"><div class="structure_field_info">cocone_maps : <span class="fn">∀ ⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄ (<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn">∃ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></span></span></div><div class="structure_field_doc"><p>for every pair of parallel morphisms there exists a morphism to the right
so the compositions are equal</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsFilteredOrEmpty" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.cocone_objs"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L76-L76">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.cocone_objs"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">cocone_objs</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span></div></div><p>for every pair of objects there exists another object &quot;to the right&quot;</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.cocone_maps"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L79-L79">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.cocone_maps"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">cocone_maps</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃X : <span class="fn">C</span>⦄</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃Y : <span class="fn">C</span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></span></div></div><p>for every pair of parallel morphisms there exists a morphism to the right
so the compositions are equal</p></div></div><div class="decl" id="CategoryTheory.IsFiltered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L89-L91">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code> if</p><ol>
<li>for every pair of objects there exists another object &quot;to the right&quot;,</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><p>See <a href="https://stacks.math.columbia.edu/tag/002V">https://stacks.math.columbia.edu/tag/002V</a>. (They also define a diagram being filtered.)</p><ul class="structure_fields" id="CategoryTheory.IsFiltered.mk"><li id="CategoryTheory.IsFiltered.cocone_objs" class="structure_field"><div class="structure_field_info">cocone_objs : <span class="fn">∀ (<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>), <span class="fn">∃ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span></span></div></li><li id="CategoryTheory.IsFiltered.cocone_maps" class="structure_field"><div class="structure_field_info">cocone_maps : <span class="fn">∀ ⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄ (<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn">∃ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></span></span></div></li><li id="CategoryTheory.IsFiltered.nonempty" class="structure_field"><div class="structure_field_info">nonempty : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>a filtered category must be non empty</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsFiltered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L91-L91">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">C</span></span></div></div><p>a filtered category must be non empty</p></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L93-L96">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_semilatticeSup</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeSup">SemilatticeSup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L98-L99">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_semilatticeSup_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeSup">SemilatticeSup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_directed_le"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L101-L106">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_directed_le"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_directed_le</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFiltered_of_directed_le_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L108-L109">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_directed_le_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_directed_le_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsFilteredDiscretePUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L116-L118">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredDiscretePUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{u_1 + 1}</a>     </span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredDiscretePUnit">CategoryTheory.instIsFilteredDiscretePUnit</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.max"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L139-L140">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code> is an arbitrary choice of object to the right of both <code>j</code> and <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.max" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.leftToMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L145-L146">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.leftToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">leftToMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j</span> <span class="fn">j'</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.leftToMax">leftToMax</a> j j'</code> is an arbitrary choice of morphism from <code>j</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.leftToMax">CategoryTheory.IsFiltered.leftToMax</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.leftToMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.rightToMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L151-L152">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">rightToMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j</span> <span class="fn">j'</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax">rightToMax</a> j j'</code> is an arbitrary choice of morphism from <code>j'</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax">CategoryTheory.IsFiltered.rightToMax</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.rightToMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L159-L160">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' : j' ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> : f ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">CategoryTheory.IsFiltered.coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeqHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L167-L168">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeqHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">CategoryTheory.IsFiltered.coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of morphism
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' : j' ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> : f ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeqHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq_condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L174-L174">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">CategoryTheory.IsFiltered.coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq_condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L175-L176">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is the proof that
<code>f ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L192-L198">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_right_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered or empty, and we have a functor <code>R : C ⥤ D</code> with a left adjoint, then <code>D</code> is
filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L202-L203">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_isRightAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">R</span>.IsRightAdjoint</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered or empty, and we have a right adjoint functor <code>R : C ⥤ D</code>, then <code>D</code> is
filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L206-L207">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>Being filtered or empty is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup_objs_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L222-L231">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_objs_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">S</span> : <span class="fn">C</span>), <span class="fn">∀ {<span class="fn">X</span> : <span class="fn">C</span>}, <span class="fn"><span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span></span>)</span></span></span></span></span></div></div><p>Any finite collection of objects in a filtered category has an object &quot;to the right&quot;.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L240-L269">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">S</span> : <span class="fn">C</span>) (<span class="fn">T</span> : <span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>} → <span class="fn"><span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span> → <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span></span>)</span></span></span>),
  <span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>} (<span class="fn">mX</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) (<span class="fn">mY</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) {<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>},
    <span class="fn"><span class="fn"><span class="fn">⟨<span class="fn">X</span>, <span class="fn">⟨<span class="fn">Y</span>, <span class="fn">⟨<span class="fn">mX</span>, <span class="fn">⟨<span class="fn">mY</span>, <span class="fn">f</span>⟩</span>⟩</span>⟩</span>⟩</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn">T</span> <span class="fn">mY</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">T</span> <span class="fn">mX</span></span></span></span></span></span></div></div><p>Given any <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code> of objects <code>{X, ...}</code> and
indexed collection of <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>s of morphisms <code>{f, ...}</code> in <code>C</code>,
there exists an object <code>S</code>, with a morphism <code>T X : X ⟶ S</code> from each <code>X</code>,
such that the triangles commute: <code>f ≫ T Y = T X</code>, for <code>f : X ⟶ Y</code> in the <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L275-L276">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>An arbitrary choice of object &quot;to the right&quot;
of a finite collection of objects <code>O</code> and morphisms <code>H</code>,
making all the triangles commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">CategoryTheory.IsFiltered.sup</a> <span class="fn">O</span> <span class="fn">H</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.sup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.toSup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L280-L281">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">CategoryTheory.IsFiltered.sup</a> <span class="fn">O</span> <span class="fn">H</span></span></span></div></div><p>The morphisms to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">sup</a> O H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup">CategoryTheory.IsFiltered.toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">⋯</span>.choose</span> <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.toSup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.toSup_commutes"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L285-L288">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup_commutes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mX : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(mY : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mf : <span class="fn"><span class="fn">⟨<span class="fn">X</span>, <span class="fn">⟨<span class="fn">Y</span>, <span class="fn">⟨<span class="fn">mX</span>, <span class="fn">⟨<span class="fn">mY</span>, <span class="fn">f</span>⟩</span>⟩</span>⟩</span>⟩</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup">CategoryTheory.IsFiltered.toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mY</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup">CategoryTheory.IsFiltered.toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mX</span></span></span></div></div><p>The triangles of consisting of a morphism in <code>H</code> and the maps to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">sup</a> O H</code> commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.cocone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L295-L310">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span></div></div><p>If we have <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> C</code>, then for any functor <code>F : J ⥤ C</code> with <code>FinCategory J</code>,
there exists a cocone over <code>F</code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.cocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L314-L315">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span></div></div><p>An arbitrary choice of cocone over <code>F : J ⥤ C</code>, for <code>FinCategory J</code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone">CategoryTheory.IsFiltered.cocone</a> <span class="fn">F</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.some</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.cocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_right_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L321-L323">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_right_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered, and we have a functor <code>R : C ⥤ D</code> with a left adjoint, then <code>D</code> is filtered.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_isRightAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L326-L327">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isRightAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">R</span>.IsRightAdjoint</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered, and we have a right adjoint functor <code>R : C ⥤ D</code>, then <code>D</code> is filtered.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L330-L331">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">D</span></span></div></div><p>Being filtered is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_cocone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L341-L357">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_cocone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]
  (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span></div></div><p>If every finite diagram in <code>C</code> admits a cocone, then <code>C</code> is filtered. It is sufficient to verify
this for diagrams whose shape lives in any one fixed universe.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_hasFiniteColimits"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L359-L360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_hasFiniteColimits"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasFiniteColimits</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.html#CategoryTheory.Limits.HasFiniteColimits">CategoryTheory.Limits.HasFiniteColimits</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_isTerminal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L362-L363">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_isTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isTerminal</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.IsTerminal">CategoryTheory.Limits.IsTerminal</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_hasTerminal"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L365-L366">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_hasTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasTerminal</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.HasTerminal">CategoryTheory.Limits.HasTerminal</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.iff_cocone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L370-L372">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.iff_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">iff_cocone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]
    (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span></span></span></div></div><p>For every universe <code>w</code>, <code>C</code> is filtered if and only if every finite diagram in <code>C</code> with shape
in <code>w</code> admits a cocone.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.max₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L384-L385">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code> is an arbitrary choice of object to the right of <code>j₁</code>, <code>j₂</code> and <code>j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j₁</span> <span class="fn">j₂</span></span>)</span> <span class="fn">j₃</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.max₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.firstToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L390-L391">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.firstToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">firstToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.firstToMax₃">firstToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₁</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.firstToMax₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.secondToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L396-L397">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.secondToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">secondToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.secondToMax₃">secondToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₂</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.secondToMax₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.thirdToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L402-L403">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.thirdToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">thirdToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₃</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.thirdToMax₃">thirdToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₃</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.thirdToMax₃">CategoryTheory.IsFiltered.thirdToMax₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax">CategoryTheory.IsFiltered.rightToMax</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j₁</span> <span class="fn">j₂</span></span>)</span> <span class="fn">j₃</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.thirdToMax₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L410-L412">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code>, for morphisms <code>f g h : j₁ ⟶ j₂</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> f g h : j₂ ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₁">coeq₃_condition₁</a></code>, <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₂">coeq₃_condition₂</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₃">coeq₃_condition₃</a></code> are satisfied.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeq₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃Hom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L418-L422">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃Hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">CategoryTheory.IsFiltered.coeq₃</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> f g h</code>, for morphisms <code>f g h : j₁ ⟶ j₂</code>, is an arbitrary choice of morphism
<code>j₂ ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code> such that <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₁">coeq₃_condition₁</a></code>, <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₂">coeq₃_condition₂</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₃">coeq₃_condition₃</a></code>
are satisfied. Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeq₃Hom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₁"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L424-L426">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₁"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L428-L434">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₂"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₃"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L436-L437">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.span"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L441-L445">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.span"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">span</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">k</span> : <span class="fn">C</span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k</span></span>) (<span class="fn">g'</span> : <span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">g'</span></span></span></span></div></div><p>For every span <code>j ⟵ i ⟶ j'</code>, there
exists a cocone <code>j ⟶ k ⟵ j'</code> such that the square commutes.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.bowtie"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L460-L465">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">bowtie</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f₁ : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₁ : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₂ : <span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₂ : <span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">s</span> : <span class="fn">C</span>) (<span class="fn">α</span> : <span class="fn"><span class="fn">k₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span></span>) (<span class="fn">β</span> : <span class="fn"><span class="fn">k₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₁</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g₁</span> <span class="fn">β</span></span></span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₂</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g₂</span> <span class="fn">β</span></span></span></span></span></div></div><p>Given a &quot;bowtie&quot; of morphisms</p><pre><code> j₁   j₂
 |\  /|
 | \/ |
 | /\ |
 |/  \∣
 vv  vv
 k₁  k₂
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and two morphisms from <code>k₁</code> and <code>k₂</code> to <code>s</code>,
making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.tulip"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L484-L491">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">tulip</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₃ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₂ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f₁ : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₂ : <span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₃ : <span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₄ : <span class="fn"><span class="fn">j₃</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₁ : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₂ : <span class="fn"><span class="fn">j₃</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">s</span> : <span class="fn">C</span>) (<span class="fn">α</span> : <span class="fn"><span class="fn">k₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span></span>) (<span class="fn">β</span> : <span class="fn"><span class="fn">l</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span></span>) (<span class="fn">γ</span> : <span class="fn"><span class="fn">k₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₁</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g₁</span> <span class="fn">β</span></span></span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₂</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₃</span> <span class="fn">γ</span></span></span> <a href="../../.././Init/Prelude.html#And">∧</a>       <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₄</span> <span class="fn">γ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g₂</span> <span class="fn">β</span></span></span></span></span></span></div></div><p>Given a &quot;tulip&quot; of morphisms</p><pre><code> j₁    j₂    j₃
 |\   / \   / |
 | \ /   \ /  |
 |  vv    vv  |
 \  k₁    k₂ /
  \         /
   \       /
    \     /
     \   /
      v v
       l
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and three morphisms from <code>k₁</code>, <code>k₂</code> and <code>l</code>
to <code>s</code>, making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L502-L507">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a></code> if</p><ol>
<li>for every pair of objects there exists another object &quot;to the left&quot;, and</li>
<li>for every pair of parallel morphisms there exists a morphism to the left so the compositions
are equal.</li>
</ol><ul class="structure_fields" id="CategoryTheory.IsCofilteredOrEmpty.mk"><li id="CategoryTheory.IsCofilteredOrEmpty.cone_objs" class="structure_field"><div class="structure_field_info">cone_objs : <span class="fn">∀ (<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>), <span class="fn">∃ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span></span></div><div class="structure_field_doc"><p>for every pair of objects there exists another object &quot;to the left&quot;</p></div></li><li id="CategoryTheory.IsCofilteredOrEmpty.cone_maps" class="structure_field"><div class="structure_field_info">cone_maps : <span class="fn">∀ ⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄ (<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn">∃ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></span></span></div><div class="structure_field_doc"><p>for every pair of parallel morphisms there exists a morphism to the left
so the compositions are equal</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsCofilteredOrEmpty" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.cone_objs"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L504-L504">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.cone_objs"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">cone_objs</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span></div></div><p>for every pair of objects there exists another object &quot;to the left&quot;</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.cone_maps"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L507-L507">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.cone_maps"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">cone_maps</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃X : <span class="fn">C</span>⦄</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃Y : <span class="fn">C</span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></span></div></div><p>for every pair of parallel morphisms there exists a morphism to the left
so the compositions are equal</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L517-L519">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code> if</p><ol>
<li>for every pair of objects there exists another object &quot;to the left&quot;,</li>
<li>for every pair of parallel morphisms there exists a morphism to the left so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><p>See <a href="https://stacks.math.columbia.edu/tag/04AZ">https://stacks.math.columbia.edu/tag/04AZ</a>.</p><ul class="structure_fields" id="CategoryTheory.IsCofiltered.mk"><li id="CategoryTheory.IsCofiltered.cone_objs" class="structure_field"><div class="structure_field_info">cone_objs : <span class="fn">∀ (<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>), <span class="fn">∃ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span></span></div></li><li id="CategoryTheory.IsCofiltered.cone_maps" class="structure_field"><div class="structure_field_info">cone_maps : <span class="fn">∀ ⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄ (<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn">∃ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></span></span></div></li><li id="CategoryTheory.IsCofiltered.nonempty" class="structure_field"><div class="structure_field_info">nonempty : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>a cofiltered category must be non empty</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsCofiltered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L519-L519">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">C</span></span></div></div><p>a cofiltered category must be non empty</p></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L521-L526">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_semilatticeInf</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeInf">SemilatticeInf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L528-L529">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_semilatticeInf_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeInf">SemilatticeInf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L531-L538">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_directed_ge</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_directed_ge_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L540-L541">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_directed_ge_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_directed_ge_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredDiscretePUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L548-L552">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredDiscretePUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{u_1 + 1}</a>     </span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredDiscretePUnit">CategoryTheory.instIsCofilteredDiscretePUnit</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.min"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L573-L574">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">min</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> is an arbitrary choice of object to the left of both <code>j</code> and <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">CategoryTheory.IsCofiltered.min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.min" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.minToLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L579-L580">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToLeft"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">CategoryTheory.IsCofiltered.min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToLeft">minToLeft</a> j j'</code> is an arbitrary choice of morphism from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> to <code>j</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToLeft">CategoryTheory.IsCofiltered.minToLeft</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.minToLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.minToRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L585-L586">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToRight"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">CategoryTheory.IsCofiltered.min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToRight">minToRight</a> j j'</code> is an arbitrary choice of morphism from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> to <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToRight">CategoryTheory.IsCofiltered.minToRight</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.minToRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L593-L594">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f' ⟶ j</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">CategoryTheory.IsCofiltered.eq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eqHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L601-L602">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eqHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">CategoryTheory.IsCofiltered.eq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of morphism
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f' ⟶ j</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.eqHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq_condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L608-L608">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq_condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L609-L610">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">f'</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is the proof that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cospan"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L614-L618">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cospan</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">k</span> : <span class="fn">C</span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">k</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span>) (<span class="fn">g'</span> : <span class="fn"><span class="fn">k</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">f'</span></span></span></span></div></div><p>For every cospan <code>j ⟶ i ⟵ j'</code>,
there exists a cone <code>j ⟵ k ⟶ j'</code> such that the square commutes.</p></div></div><div class="decl" id="CategoryTheory.Functor.ranges_directed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L620-L623">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.Functor.ranges_directed"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">ranges_directed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> u_1)</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Directed.html#Directed">Directed</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">j</span></span>)</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Core.html#Superset">⊇</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">fun (<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn"><span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span>)</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set.range">Set.range</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">f</span>.snd</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L639-L645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_left_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered or empty, and we have a functor <code>L : C ⥤ D</code> with a right adjoint,
then <code>D</code> is cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L649-L650">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_isLeftAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">L</span>.IsLeftAdjoint</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered or empty, and we have a left adjoint functor <code>L : C ⥤ D</code>, then <code>D</code> is
cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L653-L654">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>Being cofiltered or empty is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf_objs_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L669-L678">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_objs_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">S</span> : <span class="fn">C</span>), <span class="fn">∀ {<span class="fn">X</span> : <span class="fn">C</span>}, <span class="fn"><span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><span class="fn">S</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span></span></span></span></div></div><p>Any finite collection of objects in a cofiltered category has an object &quot;to the left&quot;.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L687-L716">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">S</span> : <span class="fn">C</span>) (<span class="fn">T</span> : <span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>} → <span class="fn"><span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span> → <span class="fn">(<span class="fn"><span class="fn">S</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span></span>),
  <span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>} (<span class="fn">mX</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) (<span class="fn">mY</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) {<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>},
    <span class="fn"><span class="fn"><span class="fn">⟨<span class="fn">X</span>, <span class="fn">⟨<span class="fn">Y</span>, <span class="fn">⟨<span class="fn">mX</span>, <span class="fn">⟨<span class="fn">mY</span>, <span class="fn">f</span>⟩</span>⟩</span>⟩</span>⟩</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">T</span> <span class="fn">mX</span></span>)</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">T</span> <span class="fn">mY</span></span></span></span></span></span></div></div><p>Given any <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code> of objects <code>{X, ...}</code> and
indexed collection of <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>s of morphisms <code>{f, ...}</code> in <code>C</code>,
there exists an object <code>S</code>, with a morphism <code>T X : S ⟶ X</code> from each <code>X</code>,
such that the triangles commute: <code>T X ≫ f = T Y</code>, for <code>f : X ⟶ Y</code> in the <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L722-L723">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>An arbitrary choice of object &quot;to the left&quot;
of a finite collection of objects <code>O</code> and morphisms <code>H</code>,
making all the triangles commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">CategoryTheory.IsCofiltered.inf</a> <span class="fn">O</span> <span class="fn">H</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.inf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.infTo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L727-L728">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">CategoryTheory.IsCofiltered.inf</a> <span class="fn">O</span> <span class="fn">H</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></div></div><p>The morphisms from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">inf</a> O H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo">CategoryTheory.IsCofiltered.infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">⋯</span>.choose</span> <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.infTo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.infTo_commutes"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L732-L735">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo_commutes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mX : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(mY : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mf : <span class="fn"><span class="fn">⟨<span class="fn">X</span>, <span class="fn">⟨<span class="fn">Y</span>, <span class="fn">⟨<span class="fn">mX</span>, <span class="fn">⟨<span class="fn">mY</span>, <span class="fn">f</span>⟩</span>⟩</span>⟩</span>⟩</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo">CategoryTheory.IsCofiltered.infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mX</span></span>)</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo">CategoryTheory.IsCofiltered.infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mY</span></span></span></div></div><p>The triangles consisting of a morphism in <code>H</code> and the maps from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">inf</a> O H</code> commute.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L742-L758">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span></div></div><p>If we have <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> C</code>, then for any functor <code>F : J ⥤ C</code> with <code>FinCategory J</code>,
there exists a cone over <code>F</code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L762-L763">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cone"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span></div></div><p>An arbitrary choice of cone over <code>F : J ⥤ C</code>, for <code>FinCategory J</code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cone">CategoryTheory.IsCofiltered.cone</a> <span class="fn">F</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.some</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.cone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_left_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L770-L772">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_left_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered, and we have a functor <code>L : C ⥤ D</code> with a right adjoint,
then <code>D</code> is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_isLeftAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L775-L776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isLeftAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">L</span>.IsLeftAdjoint</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered, and we have a left adjoint functor <code>L : C ⥤ D</code>, then <code>D</code> is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L779-L780">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">D</span></span></div></div><p>Being cofiltered is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_cone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L791-L807">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_cone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]
  (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span></div></div><p>If every finite diagram in <code>C</code> admits a cone, then <code>C</code> is cofiltered. It is sufficient to
verify this for diagrams whose shape lives in any one fixed universe.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_hasFiniteLimits"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L809-L810">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_hasFiniteLimits"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasFiniteLimits</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.html#CategoryTheory.Limits.HasFiniteLimits">CategoryTheory.Limits.HasFiniteLimits</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_isInitial"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L812-L813">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_isInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isInitial</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.IsInitial">CategoryTheory.Limits.IsInitial</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_hasInitial"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L815-L816">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_hasInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasInitial</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.HasInitial">CategoryTheory.Limits.HasInitial</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.cofiltered_of_hasFiniteLimits"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L818-L819">source</a></div><div class="attributes">@[deprecated CategoryTheory.IsCofiltered.of_hasFiniteLimits]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.cofiltered_of_hasFiniteLimits"><span class="name">CategoryTheory</span>.<span class="name">cofiltered_of_hasFiniteLimits</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.html#CategoryTheory.Limits.HasFiniteLimits">CategoryTheory.Limits.HasFiniteLimits</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_hasFiniteLimits">CategoryTheory.IsCofiltered.of_hasFiniteLimits</a></code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.iff_cone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L823-L825">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.iff_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">iff_cone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]
    (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span></span></span></div></div><p>For every universe <code>w</code>, <code>C</code> is filtered if and only if every finite diagram in <code>C</code> with shape
in <code>w</code> admits a cocone.</p></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L835-L844">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_op_of_isFilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofiltered_op_of_isFiltered"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L846-L847">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_op_of_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_of_isFiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L849-L858">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_op_of_isCofilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFiltered_op_of_isCofiltered"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L860-L861">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_op_of_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_of_isCofiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L864-L865">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_isFilteredOrEmpty_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is filtered or empty, then C is cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L868-L869">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_isCofilteredOrEmpty_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is cofiltered or empty, then C is filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_isFiltered_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L872-L873">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_isFiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_isFiltered_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is filtered, then C is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.isFiltered_of_isCofiltered_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L876-L877">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_isCofiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_isCofiltered_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is cofiltered, then C is filtered.</p></div></div><div class="decl" id="CategoryTheory.instIsFilteredULift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L883-L884">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULift</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#ULift">ULift.{u₂, u}</a>    <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredULift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L886-L887">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULift</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#ULift">ULift.{u₂, u}</a>    <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsFilteredULiftHom"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L889-L890">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftHom</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">CategoryTheory.ULiftHom</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredULiftHom"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L892-L893">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftHom</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">CategoryTheory.ULiftHom</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsFilteredAsSmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L895-L896">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredAsSmall</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">CategoryTheory.AsSmall</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredAsSmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Basic.lean#L898-L899">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredAsSmall</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">CategoryTheory.AsSmall</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>