<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.GradedObject</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.GradedObject";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">GradedObject</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Algebra/Group/Int.html">Mathlib.Algebra.Group.Int</a></li><li><a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html">Mathlib.CategoryTheory.ConcreteCategory.Basic</a></li><li><a href="../.././Mathlib/CategoryTheory/Shift/Basic.html">Mathlib.CategoryTheory.Shift.Basic</a></li><li><a href="../.././Mathlib/Data/Set/Subsingleton.html">Mathlib.Data.Set.Subsingleton</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.GradedObject" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.inhabitedGradedObject"><span class="name">CategoryTheory</span>.<span class="name">inhabitedGradedObject</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObjectWithShift"><span class="name">CategoryTheory</span>.<span class="name">GradedObjectWithShift</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.categoryOfGradedObjects_id"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">categoryOfGradedObjects_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.categoryOfGradedObjects_comp"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">categoryOfGradedObjects_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.categoryOfGradedObjects"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">categoryOfGradedObjects</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.hom_ext"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hom_ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.eval_obj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">eval_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.eval_map"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">eval_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.eval"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">eval</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.isoMk_hom"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isoMk_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.isoMk_inv"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isoMk_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.isoMk"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isoMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.isIso_of_isIso_apply"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isIso_of_isIso_apply</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.isIso_apply_of_isIso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isIso_apply_of_isIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.hom_inv_id_eval_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">hom_inv_id_eval_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.hom_inv_id_eval"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">hom_inv_id_eval</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.inv_hom_id_eval_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inv_hom_id_eval_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.inv_hom_id_eval"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inv_hom_id_eval</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.map_hom_inv_id_eval_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_hom_inv_id_eval_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.map_hom_inv_id_eval"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_hom_inv_id_eval</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.map_inv_hom_id_eval_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_inv_hom_id_eval_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.map_inv_hom_id_eval"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_inv_hom_id_eval</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.map_hom_inv_id_eval_app_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_hom_inv_id_eval_app_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.map_hom_inv_id_eval_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_hom_inv_id_eval_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.map_inv_hom_id_eval_app_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_inv_hom_id_eval_app_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.map_inv_hom_id_eval_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_inv_hom_id_eval_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.comap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.eqToHom_proj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">eqToHom_proj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.comapEq_inv_app"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEq_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.comapEq_hom_app"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEq_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.comapEq"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.comapEq_symm"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEq_symm</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.comapEq_trans"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEq_trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.eqToHom_apply"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">eqToHom_apply</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.comapEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEquiv_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.comapEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEquiv_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.comapEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEquiv_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.comapEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEquiv_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.comapEquiv"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.hasShift"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hasShift</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.shiftFunctor_obj_apply"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">shiftFunctor_obj_apply</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.shiftFunctor_map_apply"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">shiftFunctor_map_apply</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.instZeroHomOfHasZeroMorphisms"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">instZeroHomOfHasZeroMorphisms</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.zero_apply"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">zero_apply</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.hasZeroMorphisms"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hasZeroMorphisms</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.hasZeroObject"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hasZeroObject</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.total"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">total</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.instFaithfulTotal"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">instFaithfulTotal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.instConcreteCategory"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">instConcreteCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.instHasForget₂"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">instHasForget₂</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.mapObjFun"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapObjFun</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.HasMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">HasMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.hasMap_of_iso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hasMap_of_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.mapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.ιMapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.CofanMapObjFun"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.CofanMapObjFun.mk"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.cofanMapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">cofanMapObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.isColimitCofanMapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isColimitCofanMapObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.mapObj_ext"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapObj_ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.descMapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">descMapObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.ι_descMapObj_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ι_descMapObj_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.ι_descMapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ι_descMapObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.CofanMapObjFun.hasMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">hasMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.CofanMapObjFun.iso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.CofanMapObjFun.inj_iso_hom_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">inj_iso_hom_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.CofanMapObjFun.inj_iso_hom"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">inj_iso_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.CofanMapObjFun.ιMapObj_iso_inv_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">ιMapObj_iso_inv_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.CofanMapObjFun.ιMapObj_iso_inv"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">ιMapObj_iso_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.mapMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.ι_mapMap_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ι_mapMap_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.ι_mapMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ι_mapMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.congr_mapMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">congr_mapMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.mapMap_id"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapMap_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.mapMap_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapMap_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.mapMap_comp"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapMap_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.mapIso_inv"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapIso_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.mapIso_hom"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapIso_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.mapIso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.map_obj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">map_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.map_map"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">map_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.map"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.cofanMapObjComp"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">cofanMapObjComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.isColimitCofanMapObjComp"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isColimitCofanMapObjComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.hasMap_comp"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hasMap_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.ιMapObjOrZero"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObjOrZero</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.ιMapObjOrZero_eq"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObjOrZero_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.ιMapObjOrZero_eq_zero"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObjOrZero_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.ιMapObjOrZero_mapMap_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObjOrZero_mapMap_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.GradedObject.ιMapObjOrZero_mapMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObjOrZero_mapMap</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-category-of-graded-objects">The category of graded objects <a class="hover-link" href="#The-category-of-graded-objects">#</a></h1><p>For any type <code>β</code>, a <code>β</code>-graded object over some category <code>C</code> is just
a function <code>β → C</code> into the objects of <code>C</code>.
We put the &quot;pointwise&quot; category structure on these, as the non-dependent specialization of
<code>CategoryTheory.Pi</code>.</p><p>We describe the <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comap">comap</a></code> functors obtained by precomposing with functions <code>β → γ</code>.</p><p>As a consequence a fixed element (e.g. <code>1</code>) in an additive group <code>β</code> provides a shift
functor on <code>β</code>-graded objects</p><p>When <code>C</code> has coproducts we construct the <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.total">total</a></code> functor <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> β C ⥤ C</code>,
show that it is faithful, and deduce that when <code>C</code> is concrete so is <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> β C</code>.</p><p>A covariant functoriality of <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> β C</code> with respect to the index set <code>β</code> is also
introduced: if <code>p : I → J</code> is a map such that <code>C</code> has coproducts indexed by <code>p ⁻¹' {j}</code>, we
have a functor <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.map">map</a> : <a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> I C ⥤ <a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> J C</code>.</p></div><div class="decl" id="CategoryTheory.GradedObject"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L40-L41">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span></a></span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a> w)</span></span>
<span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max w u)</div></div><p>A type synonym for <code>β → C</code>, used for <code>β</code>-graded objects in a category <code>C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">β</span> → <span class="fn">C</span></span>)</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.inhabitedGradedObject"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L44-L46">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.inhabitedGradedObject"><span class="name">CategoryTheory</span>.<span class="name">inhabitedGradedObject</span></a></span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a> w)</span></span>
<span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.inhabitedGradedObject">CategoryTheory.inhabitedGradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObjectWithShift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L53-L54">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObjectWithShift"><span class="name">CategoryTheory</span>.<span class="name">GradedObjectWithShift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> (max w u)</span></span></div></div><p>A type synonym for <code>β → C</code>, used for <code>β</code>-graded objects in a category <code>C</code>
with a shift functor given by translation by <code>s</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObjectWithShift">CategoryTheory.GradedObjectWithShift</a> <span class="fn">x</span> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObjectWithShift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.categoryOfGradedObjects_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L60-L60">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.categoryOfGradedObjects_id"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">categoryOfGradedObjects_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a> w)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">(<span class="fn">i</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn">C</span></span>)</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">X</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.categoryOfGradedObjects_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L60-L60">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.categoryOfGradedObjects_comp"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">categoryOfGradedObjects_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a> w)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn">C</span></span>)</span> <span class="fn">i</span></span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>) (<span class="fn">i</span> : <span class="fn">β</span>),
  <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">g</span> <span class="fn">i</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.categoryOfGradedObjects"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L61-L62">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.categoryOfGradedObjects"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">categoryOfGradedObjects</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a> w)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{max w v, max u w}</a>               <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.categoryOfGradedObjects">CategoryTheory.GradedObject.categoryOfGradedObjects</a> <span class="fn">β</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Pi/Basic.html#CategoryTheory.pi">CategoryTheory.pi</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn">C</span></span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.hom_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L66-L68">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.hom_ext"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hom_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.eval_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L71-L71">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.eval_obj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">eval_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.eval">CategoryTheory.GradedObject.eval</a> <span class="fn">b</span></span>)</span>.obj</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.eval_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L71-L71">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.eval_map"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">eval_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.eval">CategoryTheory.GradedObject.eval</a> <span class="fn">b</span></span>)</span>.map</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.eval"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L72-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.eval"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span> <span class="fn">C</span></span></div></div><p>The projection of a graded object to its <code>i</code>-th component.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.eval" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.isoMk_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L81-L81">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.isoMk_hom"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isoMk_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn">(<span class="fn">i</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">Y</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.isoMk</span> <span class="fn">Y</span> <span class="fn">e</span></span>)</span>.hom</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span> <span class="fn">i</span></span>)</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.isoMk_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L81-L81">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.isoMk_inv"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isoMk_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn">(<span class="fn">i</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">Y</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.isoMk</span> <span class="fn">Y</span> <span class="fn">e</span></span>)</span>.inv</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span> <span class="fn">i</span></span>)</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.isoMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L82-L84">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.isoMk"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isoMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn">(<span class="fn">i</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">Y</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span></div></div><p>Constructor for isomorphisms in <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.isoMk</span> <span class="fn">Y</span> <span class="fn">e</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hom</span> := <span class="fn">fun (<span class="fn">i</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span> <span class="fn">i</span></span>)</span>.hom</span></span>, <span class="fn">inv</span> := <span class="fn">fun (<span class="fn">i</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span> <span class="fn">i</span></span>)</span>.inv</span></span>, <span class="fn">hom_inv_id</span> := <span class="fn">⋯</span>, <span class="fn">inv_hom_id</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.isoMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.isIso_of_isIso_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L89-L92">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.isIso_of_isIso_apply"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isIso_of_isIso_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hf : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">β</span>), <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.isIso_apply_of_isIso"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L94-L96">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.isIso_apply_of_isIso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isIso_apply_of_isIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.hom_inv_id_eval_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L107-L107">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.hom_inv_id_eval_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">hom_inv_id_eval_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">j</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.hom_inv_id_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L108-L111">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.hom_inv_id_eval"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">hom_inv_id_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.inv_hom_id_eval_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L113-L113">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.inv_hom_id_eval_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inv_hom_id_eval_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">Y</span> <span class="fn">j</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.inv_hom_id_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L114-L117">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.inv_hom_id_eval"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inv_hom_id_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">Y</span> <span class="fn">j</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.map_hom_inv_id_eval_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L119-L119">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.map_hom_inv_id_eval_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_hom_inv_id_eval_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_6, u_2}</a>      <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.map_hom_inv_id_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L120-L123">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.map_hom_inv_id_eval"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_hom_inv_id_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_6, u_2}</a>      <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.map_inv_hom_id_eval_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L125-L125">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.map_inv_hom_id_eval_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_inv_hom_id_eval_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_6, u_2}</a>      <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">Y</span> <span class="fn">j</span></span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.map_inv_hom_id_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L126-L129">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.map_inv_hom_id_eval"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_inv_hom_id_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_6, u_2}</a>      <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">Y</span> <span class="fn">j</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.map_hom_inv_id_eval_app_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L131-L131">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.map_hom_inv_id_eval_app_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_hom_inv_id_eval_app_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_7, u_2}</a>      <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_6, u_3}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span>)</span>.obj</span> <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span></span>)</span>.app</span> <span class="fn">Y</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span></span>)</span>.app</span> <span class="fn">Y</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.map_hom_inv_id_eval_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L132-L135">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.map_hom_inv_id_eval_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_hom_inv_id_eval_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_7, u_2}</a>      <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_6, u_3}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span></span>)</span>.app</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span></span>)</span>.app</span> <span class="fn">Y</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>)</span></span>)</span>.obj</span> <span class="fn">Y</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.map_inv_hom_id_eval_app_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L137-L137">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.map_inv_hom_id_eval_app_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_inv_hom_id_eval_app_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_7, u_2}</a>      <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_6, u_3}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">Y✝</span> <span class="fn">j</span></span>)</span></span>)</span>.obj</span> <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span></span>)</span>.app</span> <span class="fn">Y</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span></span>)</span>.app</span> <span class="fn">Y</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.map_inv_hom_id_eval_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L138-L141">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.Iso.map_inv_hom_id_eval_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">map_inv_hom_id_eval_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_7, u_2}</a>      <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_6, u_3}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">j</span></span>)</span></span>)</span>.app</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">j</span></span>)</span></span>)</span>.app</span> <span class="fn">Y</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">Y✝</span> <span class="fn">j</span></span>)</span></span>)</span>.obj</span> <span class="fn">Y</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.comap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L155-L156">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comap</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">J</span> → <span class="fn">I</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span></div></div><p>Pull back an <code>I</code>-graded object in <code>C</code> to a <code>J</code>-graded object along a function <code>J → I</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comap">CategoryTheory.GradedObject.comap</a> <span class="fn">C</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Pi/Basic.html#CategoryTheory.Pi.comap">CategoryTheory.Pi.comap</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn">I</span>) =&gt; <span class="fn">C</span></span>)</span> <span class="fn">h</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.comap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.eqToHom_proj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L160-L163">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.eqToHom_proj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">eqToHom_proj</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x' : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">h</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.comapEq_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L168-L168">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq_inv_app"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEq_inv_app</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">γ</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq">CategoryTheory.GradedObject.comapEq</a> <span class="fn">C</span> <span class="fn">h</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.comapEq_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L168-L168">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq_hom_app"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEq_hom_app</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">γ</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq">CategoryTheory.GradedObject.comapEq</a> <span class="fn">C</span> <span class="fn">h</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.comapEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L169-L171">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEq</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comap">CategoryTheory.GradedObject.comap</a> <span class="fn">C</span> <span class="fn">f</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comap">CategoryTheory.GradedObject.comap</a> <span class="fn">C</span> <span class="fn">g</span></span></span></div></div><p>The natural isomorphism comparing between
pulling back along two propositionally equal functions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.comapEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.comapEq_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L173-L174">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq_symm"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEq_symm</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq">CategoryTheory.GradedObject.comapEq</a> <span class="fn">C</span> <span class="fn">⋯</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq">CategoryTheory.GradedObject.comapEq</a> <span class="fn">C</span> <span class="fn">h</span></span>)</span>.symm</span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.comapEq_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L176-L177">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq_trans"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEq_trans</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(l : <span class="fn"><span class="fn">g</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq">CategoryTheory.GradedObject.comapEq</a> <span class="fn">C</span> <span class="fn">⋯</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq">CategoryTheory.GradedObject.comapEq</a> <span class="fn">C</span> <span class="fn">k</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq">CategoryTheory.GradedObject.comapEq</a> <span class="fn">C</span> <span class="fn">l</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.eqToHom_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L179-L182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.eqToHom_apply"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">eqToHom_apply</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><span class="fn">β</span> → <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><span class="fn">β</span> → <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">h</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.comapEquiv_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L187-L187">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEquiv_functor</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">β</span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">γ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEquiv">CategoryTheory.GradedObject.comapEquiv</a> <span class="fn">C</span> <span class="fn">e</span></span>)</span>.functor</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comap">CategoryTheory.GradedObject.comap</a> <span class="fn">C</span> <span class="fn">⇑<span class="fn"><span class="fn">e</span>.symm</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.comapEquiv_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L187-L187">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEquiv_inverse</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">β</span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">γ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEquiv">CategoryTheory.GradedObject.comapEquiv</a> <span class="fn">C</span> <span class="fn">e</span></span>)</span>.inverse</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comap">CategoryTheory.GradedObject.comap</a> <span class="fn">C</span> <span class="fn">⇑<span class="fn">e</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.comapEquiv_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L187-L187">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEquiv_unitIso</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">β</span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">γ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEquiv">CategoryTheory.GradedObject.comapEquiv</a> <span class="fn">C</span> <span class="fn">e</span></span>)</span>.unitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq">CategoryTheory.GradedObject.comapEq</a> <span class="fn">C</span> <span class="fn">⋯</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Pi/Basic.html#CategoryTheory.Pi.comapComp">CategoryTheory.Pi.comapComp</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn">C</span></span>)</span> <span class="fn">⇑<span class="fn">e</span></span> <span class="fn">⇑<span class="fn"><span class="fn">e</span>.symm</span></span></span>)</span>.symm</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.comapEquiv_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L187-L187">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEquiv_counitIso</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">β</span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">γ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEquiv">CategoryTheory.GradedObject.comapEquiv</a> <span class="fn">C</span> <span class="fn">e</span></span>)</span>.counitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Pi/Basic.html#CategoryTheory.Pi.comapComp">CategoryTheory.Pi.comapComp</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <span class="fn">C</span></span>)</span> <span class="fn">⇑<span class="fn"><span class="fn">e</span>.symm</span></span> <span class="fn">⇑<span class="fn">e</span></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEq">CategoryTheory.GradedObject.comapEq</a> <span class="fn">C</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.comapEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L188-L194">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.comapEquiv"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">comapEquiv</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">β</span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">γ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">γ</span> <span class="fn">C</span></span></span></div></div><p>The equivalence between β-graded objects and γ-graded objects,
given an equivalence between β and γ.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.comapEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.hasShift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L198-L203">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.hasShift"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hasShift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Shift/Basic.html#CategoryTheory.HasShift">CategoryTheory.HasShift</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObjectWithShift">CategoryTheory.GradedObjectWithShift</a> <span class="fn">s</span> <span class="fn">C</span></span>)</span> <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.shiftFunctor_obj_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L206-L208">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.shiftFunctor_obj_apply"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">shiftFunctor_obj_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">β</span> → <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Shift/Basic.html#CategoryTheory.shiftFunctor">CategoryTheory.shiftFunctor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObjectWithShift">CategoryTheory.GradedObjectWithShift</a> <span class="fn">s</span> <span class="fn">C</span></span>)</span> <span class="fn">n</span></span>)</span>.obj</span> <span class="fn">X</span> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X</span> <span class="fn">(<span class="fn"><span class="fn">t</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">n</span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">s</span></span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.shiftFunctor_map_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L211-L214">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.shiftFunctor_map_apply"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">shiftFunctor_map_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn">β</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObjectWithShift">CategoryTheory.GradedObjectWithShift</a> <span class="fn">s</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObjectWithShift">CategoryTheory.GradedObjectWithShift</a> <span class="fn">s</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Shift/Basic.html#CategoryTheory.shiftFunctor">CategoryTheory.shiftFunctor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObjectWithShift">CategoryTheory.GradedObjectWithShift</a> <span class="fn">s</span> <span class="fn">C</span></span>)</span> <span class="fn">n</span></span>)</span>.map</span> <span class="fn">f</span> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn">t</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">n</span> <a href="../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">s</span></span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.instZeroHomOfHasZeroMorphisms"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L216-L217">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.instZeroHomOfHasZeroMorphisms"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">instZeroHomOfHasZeroMorphisms</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a> w)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Algebra/Group/ZeroOne.html#Zero">Zero</a> <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.instZeroHomOfHasZeroMorphisms">CategoryTheory.GradedObject.instZeroHomOfHasZeroMorphisms</a> <span class="fn">β</span> <span class="fn">X</span> <span class="fn">Y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">zero</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn">0</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.zero_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L225-L227">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.zero_apply"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">zero_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a> w)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">0</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.hasZeroMorphisms"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L229-L230">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.hasZeroMorphisms"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hasZeroMorphisms</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a> w)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.hasZeroMorphisms">CategoryTheory.GradedObject.hasZeroMorphisms</a> <span class="fn">β</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms.mk">CategoryTheory.Limits.HasZeroMorphisms.mk</a> <span class="fn">⋯</span> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.hasZeroObject"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L236-L239">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.hasZeroObject"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hasZeroObject</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroObjects.html#CategoryTheory.Limits.HasZeroObject">CategoryTheory.Limits.HasZeroObject</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a> w)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroObjects.html#CategoryTheory.Limits.HasZeroObject">CategoryTheory.Limits.HasZeroObject</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.total"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L258-L260">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.total"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">total</span></a></span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproducts">CategoryTheory.Limits.HasCoproducts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span> <span class="fn">C</span></span></div></div><p>The total object of a graded object is the coproduct of the graded components.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.total" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.instFaithfulTotal"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L271-L277">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.instFaithfulTotal"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">instFaithfulTotal</span></a></span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproducts">CategoryTheory.Limits.HasCoproducts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.total">CategoryTheory.GradedObject.total</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span>.Faithful</span></div></div><p>The <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.total">total</a></code> functor taking a graded object to the coproduct of its graded components is faithful.
To prove this, we need to know that the coprojections into the coproduct are monomorphisms,
which follows from the fact we have zero morphisms and decidable equality for the grading.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.instConcreteCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L289-L289">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.instConcreteCategory"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">instConcreteCategory</span></a></span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> (u + 1))</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.LargeCategory">CategoryTheory.LargeCategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory">CategoryTheory.ConcreteCategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproducts">CategoryTheory.Limits.HasCoproducts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory">CategoryTheory.ConcreteCategory</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.instConcreteCategory">CategoryTheory.GradedObject.instConcreteCategory</a> <span class="fn">β</span> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory.mk">CategoryTheory.ConcreteCategory.mk</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.total">CategoryTheory.GradedObject.total</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget">CategoryTheory.forget</a> <span class="fn">C</span></span>)</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.instHasForget₂"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L291-L291">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.instHasForget₂"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">instHasForget₂</span></a></span><span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> (u + 1))</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.LargeCategory">CategoryTheory.LargeCategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory">CategoryTheory.ConcreteCategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproducts">CategoryTheory.Limits.HasCoproducts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.HasForget₂">CategoryTheory.HasForget₂</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">β</span> <span class="fn">C</span></span>)</span> <span class="fn">C</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.instHasForget₂">CategoryTheory.GradedObject.instHasForget₂</a> <span class="fn">β</span> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">forget₂</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.total">CategoryTheory.GradedObject.total</a> <span class="fn">β</span> <span class="fn">C</span></span>, <span class="fn">forget_comp</span> := <span class="fn">⋯</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.mapObjFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L304-L304">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObjFun"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapObjFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">↑<span class="fn">(<span class="fn"><span class="fn">p</span> <a href="../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn">{<span class="fn">j</span>}</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>If <code>X : <a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> I C</code> and <code>p : I → J</code>, <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObjFun">mapObjFun</a> p j</code> is the family of objects <code>X i</code>
for <code>i : I</code> such that <code>p i = j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.mapObjFun</span> <span class="fn">p</span> <span class="fn">j</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X</span> <span class="fn">↑<span class="fn">i</span></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.mapObjFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.HasMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L310-L310">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.HasMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">HasMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>Given <code>X : <a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> I C</code> and <code>p : I → J</code>, <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.HasMap">HasMap</a> p</code> is the condition that
for all <code>j : J</code>, the coproduct of all <code>X i</code> such <code>p i = j</code> exists.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">CategoryTheory.Limits.HasCoproduct</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.mapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.HasMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.hasMap_of_iso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L313-L316">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.hasMap_of_iso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hasMap_of_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.mapObj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L322-L322">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span></div></div><p>Given <code>X : <a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> I C</code> and <code>p : I → J</code>, <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p</code> is the graded object by <code>J</code>
which in degree <code>j</code> consists of the coproduct of the <code>X i</code> such that <code>p i = j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span> <span class="fn">j</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">∐</a> <span class="fn"><span class="fn"><span class="fn">X</span>.mapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.mapObj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.ιMapObj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L326-L327">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.ιMapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(hij : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span> <span class="fn">j</span></span></span></div></div><p>The canonical inclusion <code>X i ⟶ X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p j</code> when <code>i : I</code> and <code>j : J</code> are such
that <code>p i = j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hij</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.ι">CategoryTheory.Limits.Sigma.ι</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.mapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span> <span class="fn">⟨<span class="fn">i</span>, <span class="fn">hij</span>⟩</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.ιMapObj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.CofanMapObjFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L332-L332">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max (max u_4 u_5) u_1)</div></div><p>Given <code>X : <a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> I C</code>, <code>p : I → J</code> and <code>j : J</code>,
<code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun">CofanMapObjFun</a> X p j</code> is the type <code>Cofan (X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObjFun">mapObjFun</a> p j)</code>. The point object of
such colimits cofans are isomorphic to <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p j</code>, see <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.iso">CofanMapObjFun.iso</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Cofan">CategoryTheory.Limits.Cofan</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.mapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.CofanMapObjFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.CofanMapObjFun.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L338-L340">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.mk"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(pt : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(ι' : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">pt</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span></div></div><p>Constructor for <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun">CofanMapObjFun</a> X p j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.mk">CategoryTheory.GradedObject.CofanMapObjFun.mk</a> <span class="fn">X</span> <span class="fn">p</span> <span class="fn">j</span> <span class="fn">pt</span> <span class="fn">ι'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Cofan.mk">CategoryTheory.Limits.Cofan.mk</a> <span class="fn">pt</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">↑<span class="fn">(<span class="fn"><span class="fn">p</span> <a href="../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn">{<span class="fn">j</span>}</span></span>)</span></span>) =&gt;
    <span class="fn">match <span class="fn">x</span> with
    | <span class="fn">⟨<span class="fn">i</span>, <span class="fn">hi</span>⟩</span> =&gt; <span class="fn"><span class="fn">ι'</span> <span class="fn">i</span> <span class="fn">hi</span></span></span></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.CofanMapObjFun.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.cofanMapObj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L344-L345">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.cofanMapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">cofanMapObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span></div></div><p>The tautological cofan corresponding to the coproduct decomposition of <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.cofanMapObj</span> <span class="fn">p</span> <span class="fn">j</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.mk">CategoryTheory.GradedObject.CofanMapObjFun.mk</a> <span class="fn">X</span> <span class="fn">p</span> <span class="fn">j</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">I</span>) (<span class="fn">hi</span> : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hi</span></span></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.cofanMapObj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.isColimitCofanMapObj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L349-L350">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.isColimitCofanMapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isColimitCofanMapObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.cofanMapObj</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span></span></div></div><p>Given <code>X : <a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> I C</code>, <code>p : I → J</code> and <code>j : J</code>, <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p j</code> satisfies
the universal property of the coproduct of those <code>X i</code> such that <code>p i = j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.isColimitCofanMapObj</span> <span class="fn">p</span> <span class="fn">j</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.isColimit">CategoryTheory.Limits.colimit.isColimit</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor">CategoryTheory.Discrete.functor</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.mapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.isColimitCofanMapObj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.mapObj_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L353-L356">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj_ext"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapObj_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span> <span class="fn">j</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span> <span class="fn">j</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hfg : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">I</span>) (<span class="fn">hij</span> : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>),
  <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hij</span></span>)</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hij</span></span>)</span> <span class="fn">g</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.descMapObj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L360-L362">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.descMapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">descMapObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span> <span class="fn">j</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span></div></div><p>This is the morphism <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p j ⟶ A</code> constructed from a family of
morphisms <code>X i ⟶ A</code> for all <code>i : I</code> such that <code>p i = j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.descMapObj</span> <span class="fn">p</span> <span class="fn">φ</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Cofan.IsColimit.desc">CategoryTheory.Limits.Cofan.IsColimit.desc</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.isColimitCofanMapObj</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">↑<span class="fn">(<span class="fn"><span class="fn">p</span> <a href="../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn">{<span class="fn">j</span>}</span></span>)</span></span>) =&gt;
    <span class="fn">match <span class="fn">x</span> with
    | <span class="fn">⟨<span class="fn">i</span>, <span class="fn">hi</span>⟩</span> =&gt; <span class="fn"><span class="fn">φ</span> <span class="fn">i</span> <span class="fn">hi</span></span></span></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.descMapObj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.ι_descMapObj_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L364-L364">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.ι_descMapObj_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ι_descMapObj_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">A</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hi</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.descMapObj</span> <span class="fn">p</span> <span class="fn">φ</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">φ</span> <span class="fn">i</span> <span class="fn">hi</span></span>)</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.ι_descMapObj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L365-L368">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.ι_descMapObj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ι_descMapObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hi</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.descMapObj</span> <span class="fn">p</span> <span class="fn">φ</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">φ</span> <span class="fn">i</span> <span class="fn">hi</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.CofanMapObjFun.hasMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L372-L373">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.hasMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">hasMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">(<span class="fn">j</span> : <span class="fn">J</span>) → <span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hc : <span class="fn">(<span class="fn">j</span> : <span class="fn">J</span>) → <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">(<span class="fn"><span class="fn">c</span> <span class="fn">j</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.CofanMapObjFun.iso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L380-L381">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.iso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hc : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">c</span>.pt</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span> <span class="fn">j</span></span></span></div></div><p>If <code>c : <a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun">CofanMapObjFun</a> X p j</code> is a colimit cofan, this is the induced
isomorphism <code>c.pt ≅ X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.iso">CategoryTheory.GradedObject.CofanMapObjFun.iso</a> <span class="fn">hc</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">hc</span>.coconePointUniqueUpToIso</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.isColimitCofanMapObj</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.CofanMapObjFun.iso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.CofanMapObjFun.inj_iso_hom_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L383-L383">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.inj_iso_hom_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">inj_iso_hom_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hc : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span> <span class="fn">j</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Cofan.inj">CategoryTheory.Limits.Cofan.inj</a> <span class="fn">c</span> <span class="fn">⟨<span class="fn">i</span>, <span class="fn">hi</span>⟩</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.iso">CategoryTheory.GradedObject.CofanMapObjFun.iso</a> <span class="fn">hc</span></span>)</span>.hom</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hi</span></span>)</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.CofanMapObjFun.inj_iso_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L384-L386">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.inj_iso_hom"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">inj_iso_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hc : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Cofan.inj">CategoryTheory.Limits.Cofan.inj</a> <span class="fn">c</span> <span class="fn">⟨<span class="fn">i</span>, <span class="fn">hi</span>⟩</span></span>)</span>
    <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.iso">CategoryTheory.GradedObject.CofanMapObjFun.iso</a> <span class="fn">hc</span></span>)</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hi</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.CofanMapObjFun.ιMapObj_iso_inv_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L388-L388">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.ιMapObj_iso_inv_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">ιMapObj_iso_inv_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hc : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">c</span>.pt</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hi</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.iso">CategoryTheory.GradedObject.CofanMapObjFun.iso</a> <span class="fn">hc</span></span>)</span>.inv</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Cofan.inj">CategoryTheory.Limits.Cofan.inj</a> <span class="fn">c</span> <span class="fn">⟨<span class="fn">i</span>, <span class="fn">hi</span>⟩</span></span>)</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.CofanMapObjFun.ιMapObj_iso_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L389-L391">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.ιMapObj_iso_inv"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">CofanMapObjFun</span>.<span class="name">ιMapObj_iso_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hc : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hi</span></span>)</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun.iso">CategoryTheory.GradedObject.CofanMapObjFun.iso</a> <span class="fn">hc</span></span>)</span>.inv</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Cofan.inj">CategoryTheory.Limits.Cofan.inj</a> <span class="fn">c</span> <span class="fn">⟨<span class="fn">i</span>, <span class="fn">hi</span>⟩</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.mapMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L399-L400">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">Y</span>.mapObj</span> <span class="fn">p</span></span></span></div></div><p>The canonical morphism of <code>J</code>-graded objects <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p ⟶ Y.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p</code> induced by
a morphism <code>X ⟶ Y</code> of <code>I</code>-graded objects and a map <code>p : I → J</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">φ</span> <span class="fn">p</span> <span class="fn">j</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">X</span>.descMapObj</span> <span class="fn">p</span> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">I</span>) (<span class="fn">hi</span> : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>) =&gt; <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">φ</span> <span class="fn">i</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">Y</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hi</span></span>)</span></span></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.mapMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.ι_mapMap_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L402-L402">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.ι_mapMap_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ι_mapMap_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(hij : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">Y</span>.mapObj</span> <span class="fn">p</span> <span class="fn">j</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hij</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">φ</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">φ</span> <span class="fn">i</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">Y</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hij</span></span>)</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.ι_mapMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L403-L405">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.ι_mapMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ι_mapMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(hij : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hij</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">φ</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">φ</span> <span class="fn">i</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">Y</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">hij</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.congr_mapMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L407-L409">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.congr_mapMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">congr_mapMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(φ₁ : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(φ₂ : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">φ₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">φ₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">φ₁</span> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">φ₂</span> <span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.mapMap_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L414-L414">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap_id"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapMap_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">X</span></span>)</span> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.mapMap_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L418-L418">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapMap_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ψ : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z✝</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Z✝</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">Z✝</span>.mapObj</span> <span class="fn">p</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">φ</span> <span class="fn">ψ</span></span>)</span> <span class="fn">p</span></span>)</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">φ</span> <span class="fn">p</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">ψ</span> <span class="fn">p</span></span>)</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.mapMap_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L419-L419">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap_comp"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapMap_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ψ : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Z</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">φ</span> <span class="fn">ψ</span></span>)</span> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">φ</span> <span class="fn">p</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">ψ</span> <span class="fn">p</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.mapIso_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L423-L423">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapIso_inv"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapIso_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapIso">CategoryTheory.GradedObject.mapIso</a> <span class="fn">e</span> <span class="fn">p</span></span>)</span>.inv</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">p</span> <span class="fn">i</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.mapIso_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L423-L423">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapIso_hom"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapIso_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapIso">CategoryTheory.GradedObject.mapIso</a> <span class="fn">e</span> <span class="fn">p</span></span>)</span>.hom</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">p</span> <span class="fn">i</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.mapIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L424-L426">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapIso"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">mapIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">Y</span>.mapObj</span> <span class="fn">p</span></span></span></div></div><p>The isomorphism of <code>J</code>-graded objects <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p ≅ Y.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p</code> induced by an
isomorphism <code>X ≅ Y</code> of graded objects and a map <code>p : I → J</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapIso">CategoryTheory.GradedObject.mapIso</a> <span class="fn">e</span> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn"><span class="fn">e</span>.hom</span> <span class="fn">p</span></span>, <span class="fn">inv</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn"><span class="fn">e</span>.inv</span> <span class="fn">p</span></span>,
    <span class="fn">hom_inv_id</span> := <span class="fn">⋯</span>, <span class="fn">inv_hom_id</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.mapIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.map_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L433-L433">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.map_obj"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">map_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u_4)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimitsOfShape">CategoryTheory.Limits.HasColimitsOfShape</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <span class="fn">↑<span class="fn">(<span class="fn"><span class="fn">p</span> <a href="../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn">{<span class="fn">j</span>}</span></span>)</span></span></span>)</span> <span class="fn">C</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.map">CategoryTheory.GradedObject.map</a> <span class="fn">C</span> <span class="fn">p</span></span>)</span>.obj</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.map_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L433-L433">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.map_map"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">map_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u_4)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimitsOfShape">CategoryTheory.Limits.HasColimitsOfShape</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <span class="fn">↑<span class="fn">(<span class="fn"><span class="fn">p</span> <a href="../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn">{<span class="fn">j</span>}</span></span>)</span></span></span>)</span> <span class="fn">C</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>} (<span class="fn">φ</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) (<span class="fn">i</span> : <span class="fn">J</span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.map">CategoryTheory.GradedObject.map</a> <span class="fn">C</span> <span class="fn">p</span></span>)</span>.map</span> <span class="fn">φ</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">φ</span> <span class="fn">p</span> <span class="fn">i</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L434-L437">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.map"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u_4)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimitsOfShape">CategoryTheory.Limits.HasColimitsOfShape</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <span class="fn">↑<span class="fn">(<span class="fn"><span class="fn">p</span> <a href="../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn">{<span class="fn">j</span>}</span></span>)</span></span></span>)</span> <span class="fn">C</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span></div></div><p>Given a map <code>p : I → J</code>, this is the functor <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> I C ⥤ <a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> J C</code> which
sends an <code>I</code>-object <code>X</code> to the graded object <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p</code> which in degree <code>j : J</code> is given
by the coproduct of those <code>X i</code> such that <code>p i = j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.cofanMapObjComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L454-L457">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.cofanMapObjComp"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">cofanMapObjComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <span class="fn"><span class="fn">J</span> → <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">I</span> → <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpqr : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">I</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">(<span class="fn"><span class="fn">p</span> <span class="fn">i</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">r</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(k : <span class="fn">K</span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">(<span class="fn">j</span> : <span class="fn">J</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">j</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></span> → <span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c' : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Cofan">CategoryTheory.Limits.Cofan</a> <span class="fn">fun (<span class="fn">j</span> : <span class="fn">↑<span class="fn">(<span class="fn"><span class="fn">q</span> <a href="../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn">{<span class="fn">k</span>}</span></span>)</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span> <span class="fn">↑<span class="fn">j</span></span> <span class="fn">⋯</span></span>)</span>.pt</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">r</span> <span class="fn">k</span></span></div></div><p>Given maps <code>p : I → J</code>, <code>q : J → K</code> and <code>r : I → K</code> such that <code>q.comp p = r</code>,
<code>X : <a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> I C</code>, <code>k : K</code>, the datum of cofans <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun">CofanMapObjFun</a> p j</code> for all
<code>j : J</code> and of a cofan for all the points of these cofans, this is a cofan of
type <code>X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.CofanMapObjFun">CofanMapObjFun</a> r k</code>, which is a colimit (see <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.isColimitCofanMapObjComp">isColimitCofanMapObjComp</a></code>) if the
given cofans are.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.cofanMapObjComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.isColimitCofanMapObjComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L466-L482">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.isColimitCofanMapObjComp"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">isColimitCofanMapObjComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <span class="fn"><span class="fn">J</span> → <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">I</span> → <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpqr : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">I</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">(<span class="fn"><span class="fn">p</span> <span class="fn">i</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">r</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(k : <span class="fn">K</span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">(<span class="fn">j</span> : <span class="fn">J</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">j</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></span> → <span class="fn"><span class="fn"><span class="fn">X</span>.CofanMapObjFun</span> <span class="fn">p</span> <span class="fn">j</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hc : <span class="fn">(<span class="fn">j</span> : <span class="fn">J</span>) → <span class="fn">(<span class="fn">hj</span> : <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">j</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></span>) → <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">(<span class="fn"><span class="fn">c</span> <span class="fn">j</span> <span class="fn">hj</span></span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c' : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Cofan">CategoryTheory.Limits.Cofan</a> <span class="fn">fun (<span class="fn">j</span> : <span class="fn">↑<span class="fn">(<span class="fn"><span class="fn">q</span> <a href="../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn">{<span class="fn">k</span>}</span></span>)</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span> <span class="fn">↑<span class="fn">j</span></span> <span class="fn">⋯</span></span>)</span>.pt</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hc' : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">c'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.cofanMapObjComp</span> <span class="fn">p</span> <span class="fn">q</span> <span class="fn">r</span> <span class="fn">hpqr</span> <span class="fn">k</span> <span class="fn">c</span> <span class="fn">c'</span></span>)</span></span></div></div><p>Given maps <code>p : I → J</code>, <code>q : J → K</code> and <code>r : I → K</code> such that <code>q.comp p = r</code>,
<code>X : <a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">GradedObject</a> I C</code>, <code>k : K</code>, the cofan constructed by <code><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.cofanMapObjComp">cofanMapObjComp</a></code> is a colimit.
In other words, if we have, for all <code>j : J</code> such that <code>hj : q j = k</code>,
a colimit cofan <code>c j hj</code> which computes the coproduct of the <code>X i</code> such that <code>p i = j</code>,
and also a colimit cofan which computes the coproduct of the points of these <code>c j hj</code>, then
the point of this latter cofan computes the coproduct of the <code>X i</code> such that <code>r i = k</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.isColimitCofanMapObjComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.hasMap_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L484-L486">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.hasMap_comp"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">hasMap_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <span class="fn"><span class="fn">J</span> → <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">I</span> → <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpqr : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">I</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">(<span class="fn"><span class="fn">p</span> <span class="fn">i</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">r</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span></span>)</span>.HasMap</span> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.ιMapObjOrZero"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L497-L500">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.ιMapObjOrZero"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObjOrZero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">X</span>.mapObj</span> <span class="fn">p</span> <span class="fn">j</span></span></span></div></div><p>The canonical inclusion <code>X i ⟶ X.<a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapObj">mapObj</a> p j</code> when <code>p i = j</code>, the zero morphism otherwise.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObjOrZero</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span> then <span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">h</span></span> else <span class="fn">0</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.GradedObject.ιMapObjOrZero" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.GradedObject.ιMapObjOrZero_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L502-L502">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.ιMapObjOrZero_eq"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObjOrZero_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObjOrZero</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObj</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.ιMapObjOrZero_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L504-L504">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.ιMapObjOrZero_eq_zero"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObjOrZero_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">i</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObjOrZero</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.ιMapObjOrZero_mapMap_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L507-L507">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.ιMapObjOrZero_mapMap_assoc"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObjOrZero_mapMap_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">Y</span>.mapObj</span> <span class="fn">p</span> <span class="fn">j</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObjOrZero</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">φ</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">φ</span> <span class="fn">i</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">Y</span>.ιMapObjOrZero</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.GradedObject.ιMapObjOrZero_mapMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/GradedObject.lean#L508-L512">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.ιMapObjOrZero_mapMap"><span class="name">CategoryTheory</span>.<span class="name">GradedObject</span>.<span class="name">ιMapObjOrZero_mapMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_5, u_4}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject">CategoryTheory.GradedObject</a> <span class="fn">I</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">I</span> → <span class="fn">J</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">X</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">Y</span>.HasMap</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.html#CategoryTheory.Limits.HasZeroMorphisms">CategoryTheory.Limits.HasZeroMorphisms</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn">I</span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">X</span>.ιMapObjOrZero</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/GradedObject.html#CategoryTheory.GradedObject.mapMap">CategoryTheory.GradedObject.mapMap</a> <span class="fn">φ</span> <span class="fn">p</span> <span class="fn">j</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">φ</span> <span class="fn">i</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">Y</span>.ιMapObjOrZero</span> <span class="fn">p</span> <span class="fn">i</span> <span class="fn">j</span></span>)</span></span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>