<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Limits.Cones</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Limits.Cones";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html">Mathlib.CategoryTheory.DiscreteCategory</a></li><li><a href="../../.././Mathlib/CategoryTheory/Yoneda.html">Mathlib.CategoryTheory.Yoneda</a></li><li><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html">Mathlib.CategoryTheory.Functor.Const</a></li><li><a href="../../.././Mathlib/CategoryTheory/Functor/ReflectsIso.html">Mathlib.CategoryTheory.Functor.ReflectsIso</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Limits.Cones" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.cones_map_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cones_map_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.cones_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cones_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.cones"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cones</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.cocones_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cocones_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.cocones_map_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cocones_map_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.cocones"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cocones</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cones_map_app_app"><span class="name">CategoryTheory</span>.<span class="name">cones_map_app_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cones_obj_obj"><span class="name">CategoryTheory</span>.<span class="name">cones_obj_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cones_obj_map_app"><span class="name">CategoryTheory</span>.<span class="name">cones_obj_map_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cones"><span class="name">CategoryTheory</span>.<span class="name">cones</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cocones_map_app_app"><span class="name">CategoryTheory</span>.<span class="name">cocones_map_app_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cocones_obj_obj"><span class="name">CategoryTheory</span>.<span class="name">cocones_obj_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cocones_obj_map_app"><span class="name">CategoryTheory</span>.<span class="name">cocones_obj_map_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cocones"><span class="name">CategoryTheory</span>.<span class="name">cocones</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.inhabitedCone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">inhabitedCone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">w_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.w"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">w</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.inhabitedCocone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">inhabitedCocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">w_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.w"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">w</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.equiv_hom_snd"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">equiv_hom_snd</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.equiv_inv_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">equiv_inv_π</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.equiv_hom_fst"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">equiv_hom_fst</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.equiv_inv_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">equiv_inv_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.equiv"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">equiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.extensions_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">extensions_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.extensions"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">extensions</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.extend_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">extend_π</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.extend_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">extend_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.extend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">extend</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.whisker_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">whisker_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.whisker_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">whisker_π</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.whisker"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">whisker</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.equiv"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">equiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.extensions_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">extensions_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.extensions"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">extensions</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.extend_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">extend_ι</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.extend_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">extend_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.extend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">extend</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.whisker_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">whisker_ι</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.whisker_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">whisker_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.whisker"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">whisker</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.ConeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">ConeMorphism</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.ConeMorphism.w"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">ConeMorphism</span>.<span class="name">w</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.ConeMorphism.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">ConeMorphism</span>.<span class="name">w_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.inhabitedConeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">inhabitedConeMorphism</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.category_comp_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">category_comp_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.category_id_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">category_id_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.category"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">category</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.ConeMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">ConeMorphism</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.ext_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">ext_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.ext_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">ext_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.ext"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.eta_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">eta_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.eta_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">eta_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.eta"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">eta</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.cone_iso_of_hom_iso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">cone_iso_of_hom_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.extend_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extend_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.extend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extend</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.extendId_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendId_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.extendId_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendId_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.extendId"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.extendComp_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendComp_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.extendComp_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendComp_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.extendComp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.extendIso_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendIso_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.extendIso_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendIso_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.extendIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.instIsIsoConeExtend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">instIsIsoConeExtend</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcompose_obj_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcompose_obj_π</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcompose_obj_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcompose_obj_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcompose_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcompose_map_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcompose"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcompose</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcomposeComp_hom_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeComp_hom_app_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcomposeComp_inv_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeComp_inv_app_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcomposeComp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcomposeId_hom_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeId_hom_app_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcomposeId_inv_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeId_inv_app_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcomposeId"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcomposeEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeEquivalence_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcomposeEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeEquivalence_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcomposeEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcomposeEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeEquivalence_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.postcomposeEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.whiskering_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskering_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.whiskering_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskering_map_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.whiskering"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskering</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.whiskeringEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskeringEquivalence_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.whiskeringEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskeringEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.whiskeringEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskeringEquivalence_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.whiskeringEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskeringEquivalence_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.whiskeringEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskeringEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.equivalenceOfReindexing_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">equivalenceOfReindexing_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.equivalenceOfReindexing_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">equivalenceOfReindexing_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.equivalenceOfReindexing_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">equivalenceOfReindexing_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.equivalenceOfReindexing_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">equivalenceOfReindexing_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.equivalenceOfReindexing"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">equivalenceOfReindexing</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">forget_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">forget_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.forget"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.functoriality_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality_map_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.functoriality_obj_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality_obj_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.functoriality_obj_π_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality_obj_π_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.functoriality"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.functoriality_full"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality_full</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.functoriality_faithful"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.functorialityEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functorialityEquivalence_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.functorialityEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functorialityEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.functorialityEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functorialityEquivalence_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.functorialityEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functorialityEquivalence_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.functorialityEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functorialityEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cones.reflects_cone_isomorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">reflects_cone_isomorphism</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.CoconeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">CoconeMorphism</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.CoconeMorphism.w"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">CoconeMorphism</span>.<span class="name">w</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.inhabitedCoconeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">inhabitedCoconeMorphism</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.CoconeMorphism.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">CoconeMorphism</span>.<span class="name">w_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.category_id_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">category_id_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.category_comp_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">category_comp_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.category"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">category</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.CoconeMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">CoconeMorphism</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.ext_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">ext_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.ext_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">ext_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.ext"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.eta_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">eta_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.eta_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">eta_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.eta"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">eta</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.cocone_iso_of_hom_iso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">cocone_iso_of_hom_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.extend_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extend_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.extend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extend</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.extendId_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendId_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.extendId_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendId_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.extendId"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.extendComp_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendComp_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.extendComp_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendComp_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.extendComp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.extendIso_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendIso_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.extendIso_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendIso_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.extendIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.instIsIsoCoconeExtend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">instIsIsoCoconeExtend</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.precompose_obj_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precompose_obj_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.precompose_obj_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precompose_obj_ι</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.precompose_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precompose_map_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.precompose"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precompose</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.precomposeComp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.precomposeId"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.precomposeEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.precomposeEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeEquivalence_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.precomposeEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeEquivalence_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.precomposeEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeEquivalence_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.precomposeEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.whiskering_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskering_map_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.whiskering_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskering_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.whiskering"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskering</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.whiskeringEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskeringEquivalence_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.whiskeringEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskeringEquivalence_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.whiskeringEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskeringEquivalence_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.whiskeringEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskeringEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.whiskeringEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskeringEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.equivalenceOfReindexing_functor_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">equivalenceOfReindexing_functor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.equivalenceOfReindexing"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">equivalenceOfReindexing</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">forget_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">forget_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.forget"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.functoriality_obj_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality_obj_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.functoriality_obj_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality_obj_ι_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.functoriality_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality_map_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.functoriality"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.functoriality_full"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality_full</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.functoriality_faithful"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.functorialityEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functorialityEquivalence_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.functorialityEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functorialityEquivalence_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.functorialityEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functorialityEquivalence_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.functorialityEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functorialityEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.functorialityEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functorialityEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocones.reflects_cocone_isomorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">reflects_cocone_isomorphism</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCone_π_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCone_π_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCocone_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCocone_ι_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCocone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCocone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeMorphism</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeMorphism</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConeInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConeMapConeInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeMapConeInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConeInvMapCone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeInvMapCone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconeInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconeMapCoconeInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeMapCoconeInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconeInvMapCocone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeInvMapCocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.functorialityCompPostcompose_inv_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPostcompose_inv_app_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.functorialityCompPostcompose_hom_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPostcompose_hom_app_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.functorialityCompPostcompose"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPostcompose</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.postcomposeWhiskerLeftMapCone_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">postcomposeWhiskerLeftMapCone_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.postcomposeWhiskerLeftMapCone_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">postcomposeWhiskerLeftMapCone_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.postcomposeWhiskerLeftMapCone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">postcomposeWhiskerLeftMapCone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConePostcompose_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcompose_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConePostcompose_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcompose_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConePostcompose"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcompose</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcomposeEquivalenceFunctor_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcomposeEquivalenceFunctor_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcomposeEquivalenceFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.functorialityCompPrecompose_inv_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPrecompose_inv_app_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.functorialityCompPrecompose_hom_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPrecompose_hom_app_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.functorialityCompPrecompose"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPrecompose</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.precomposeWhiskerLeftMapCocone_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">precomposeWhiskerLeftMapCocone_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.precomposeWhiskerLeftMapCocone_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">precomposeWhiskerLeftMapCocone_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.precomposeWhiskerLeftMapCocone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">precomposeWhiskerLeftMapCocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconePrecompose_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecompose_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconePrecompose_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecompose_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconePrecompose"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecompose</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecomposeEquivalenceFunctor_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecomposeEquivalenceFunctor_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecomposeEquivalenceFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConeWhisker_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeWhisker_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConeWhisker_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeWhisker_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConeWhisker"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeWhisker</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconeWhisker_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeWhisker_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconeWhisker_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeWhisker_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconeWhisker"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeWhisker</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.op_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">op_π</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.op_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">op_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.op"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.op_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">op_ι</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.op_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">op_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.op"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.unop_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">unop_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.unop_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">unop_π</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cocone.unop"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.unop_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">unop_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.unop_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">unop_ι</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.Cone.unop"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeEquivalenceOpConeOp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeEquivalenceOpConeOp_inverse_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_inverse_map_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeEquivalenceOpConeOp_inverse_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_inverse_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeEquivalenceOpConeOp_functor_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_functor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeEquivalenceOpConeOp_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeEquivalenceOpConeOp_functor_map"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_functor_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeEquivalenceOpConeOp_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneOfCoconeLeftOp_π_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeLeftOp_π_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneOfCoconeLeftOp_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeLeftOp_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneOfCoconeLeftOp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeLeftOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeLeftOpOfCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeLeftOpOfCone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeLeftOpOfCone_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeLeftOpOfCone_ι_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeLeftOpOfCone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeLeftOpOfCone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeOfConeLeftOp_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeLeftOp_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeOfConeLeftOp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeLeftOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeOfConeLeftOp_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeLeftOp_ι_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneLeftOpOfCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneLeftOpOfCocone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneLeftOpOfCocone_π_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneLeftOpOfCocone_π_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneLeftOpOfCocone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneLeftOpOfCocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneOfCoconeRightOp_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeRightOp_π</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneOfCoconeRightOp_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeRightOp_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneOfCoconeRightOp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeRightOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeRightOpOfCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeRightOpOfCone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeRightOpOfCone_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeRightOpOfCone_ι</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeRightOpOfCone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeRightOpOfCone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeOfConeRightOp_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeRightOp_ι</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeOfConeRightOp_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeRightOp_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeOfConeRightOp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeRightOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneRightOpOfCocone_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneRightOpOfCocone_π</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneRightOpOfCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneRightOpOfCocone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneRightOpOfCocone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneRightOpOfCocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneOfCoconeUnop_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeUnop_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneOfCoconeUnop_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeUnop_π</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneOfCoconeUnop"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeUnop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeUnopOfCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeUnopOfCone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeUnopOfCone_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeUnopOfCone_ι</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeUnopOfCone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeUnopOfCone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeOfConeUnop_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeUnop_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeOfConeUnop_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeUnop_ι</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coconeOfConeUnop"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeUnop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneUnopOfCocone_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneUnopOfCocone_π</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneUnopOfCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneUnopOfCocone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.coneUnopOfCocone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneUnopOfCocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConeOp_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeOp_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConeOp_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeOp_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapConeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconeOp_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeOp_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconeOp_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeOp_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapCoconeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeOp</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Cones-and-cocones">Cones and cocones <a class="hover-link" href="#Cones-and-cocones">#</a></h1><p>We define <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> F</code>, a cone over a functor <code>F</code>,
and <code>F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cones">cones</a> : Cᵒᵖ ⥤ Type</code>, the functor associating to <code>X</code> the cones over <code>F</code> with cone point <code>X</code>.</p><p>A cone <code>c</code> is defined by specifying its cone point <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a></code> and a natural transformation <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.π">π</a></code>
from the constant <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a></code> valued functor to <code>F</code>.</p><p>We provide <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.w">w</a> f : c.π.app j ≫ F.map f = c.π.app j'</code> for any <code>f : j ⟶ j'</code>
as a wrapper for <code>c.π.naturality f</code> avoiding unneeded identity morphisms.</p><p>We define <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.extend">extend</a> f</code>, where <code>c : cone F</code> and <code>f : Y ⟶ c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a></code> for some other <code>Y</code>,
which replaces the cone point by <code>Y</code> and inserts <code>f</code> into each of the components of the cone.
Similarly we have <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker">whisker</a> F</code> producing a <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> (E ⋙ F)</code></p><p>We define morphisms of cones, and the category of cones.</p><p>We define <code>Cone.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">postcompose</a> α : cone F ⥤ cone G</code> for <code>α</code> a natural transformation <code>F ⟶ G</code>.</p><p>And, of course, we dualise all this to cocones as well.</p><p>For more results about the category of cones, see <code>cone_category.lean</code>.</p></div><div class="decl" id="CategoryTheory.Functor.cones_map_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L65-L65">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cones_map_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cones_map_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) (<span class="fn">a</span> : <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.yoneda</span>.obj</span> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.op</span>.obj</span> <span class="fn">X</span></span>)</span></span>) (<span class="fn">X_1</span> : <span class="fn">J</span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.cones</span>.map</span> <span class="fn">f</span> <span class="fn">a</span></span>)</span>.app</span> <span class="fn">X_1</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.unop</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span>.app</span> <span class="fn">X_1</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.cones_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L65-L65">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cones_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cones_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.cones</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">F</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.cones"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L66-L67">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cones"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cones</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> (max u₁ v₃))</a></span></div></div><p>If <code>F : J ⥤ C</code> then <code>F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cones">cones</a></code> is the functor assigning to an object <code>X : C</code> the
type of natural transformations from the constant functor with value <code>X</code> to <code>F</code>.
An object representing this functor is a limit of <code>F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">F</span>.cones</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.op</span>.comp</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.yoneda</span>.obj</span> <span class="fn">F</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.cones" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.cocones_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L73-L73">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cocones_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cocones_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.cocones</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.obj</span> <span class="fn">X</span></span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.cocones_map_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L73-L73">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cocones_map_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cocones_map_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) (<span class="fn">a</span> : <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.coyoneda</span>.obj</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">F</span></span>)</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span></span>)
  (<span class="fn">X_1</span> : <span class="fn">J</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.cocones</span>.map</span> <span class="fn">f</span> <span class="fn">a</span></span>)</span>.app</span> <span class="fn">X_1</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span>.app</span> <span class="fn">X_1</span></span>)</span> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.cocones"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L74-L75">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cocones"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">cocones</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> (max u₁ v₃))</a></span></div></div><p>If <code>F : J ⥤ C</code> then <code>F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cocones">cocones</a></code> is the functor assigning to an object <code>(X : C)</code>
the type of natural transformations from <code>F</code> to the constant functor with value <code>X</code>.
An object corepresenting this functor is a colimit of <code>F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">F</span>.cocones</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.coyoneda</span>.obj</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">F</span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.cocones" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.cones_map_app_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L86-L86">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cones_map_app_app"><span class="name">CategoryTheory</span>.<span class="name">cones_map_app_app</span></a></span><span class="decl_args">
<span class="fn">(J : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u₃)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) (<span class="fn">X_1</span> : <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)
  (<span class="fn">a</span> : <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.yoneda</span>.obj</span> <span class="fn">X</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.op</span>.obj</span> <span class="fn">X_1</span></span>)</span></span>) (<span class="fn">X_2</span> : <span class="fn">J</span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cones">CategoryTheory.cones</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.app</span> <span class="fn">X_1</span> <span class="fn">a</span></span>)</span>.app</span> <span class="fn">X_2</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span>.app</span> <span class="fn">X_2</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">f</span>.app</span> <span class="fn">X_2</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.cones_obj_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L86-L86">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cones_obj_obj"><span class="name">CategoryTheory</span>.<span class="name">cones_obj_obj</span></a></span><span class="decl_args">
<span class="fn">(J : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u₃)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cones">CategoryTheory.cones</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span>.obj</span> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">F</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.cones_obj_map_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L86-L86">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cones_obj_map_app"><span class="name">CategoryTheory</span>.<span class="name">cones_obj_map_app</span></a></span><span class="decl_args">
<span class="fn">(J : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u₃)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) (<span class="fn">a</span> : <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.yoneda</span>.obj</span> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.op</span>.obj</span> <span class="fn">X</span></span>)</span></span>) (<span class="fn">X_1</span> : <span class="fn">J</span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cones">CategoryTheory.cones</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span>.obj</span> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">f</span> <span class="fn">a</span></span>)</span>.app</span> <span class="fn">X_1</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.unop</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span>.app</span> <span class="fn">X_1</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.cones"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L87-L89">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cones"><span class="name">CategoryTheory</span>.<span class="name">cones</span></a></span><span class="decl_args">
<span class="fn">(J : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u₃)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> (max u₁ v₃))</a></span>)</span></span></div></div><p>Functorially associated to each functor <code>J ⥤ C</code>, we have the <code>C</code>-presheaf consisting of
cones with a given cone point.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.cones" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.cocones_map_app_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L94-L94">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cocones_map_app_app"><span class="name">CategoryTheory</span>.<span class="name">cocones_map_app_app</span></a></span><span class="decl_args">
<span class="fn">(J : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u₃)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) (<span class="fn">X_1</span> : <span class="fn">C</span>)
  (<span class="fn">a</span> : <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.coyoneda</span>.obj</span> <span class="fn">X</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.obj</span> <span class="fn">X_1</span></span>)</span></span>) (<span class="fn">X_2</span> : <span class="fn">J</span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cocones">CategoryTheory.cocones</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.app</span> <span class="fn">X_1</span> <span class="fn">a</span></span>)</span>.app</span> <span class="fn">X_2</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.unop</span>.app</span> <span class="fn">X_2</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span>.app</span> <span class="fn">X_2</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.cocones_obj_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L94-L94">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cocones_obj_obj"><span class="name">CategoryTheory</span>.<span class="name">cocones_obj_obj</span></a></span><span class="decl_args">
<span class="fn">(J : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u₃)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cocones">CategoryTheory.cocones</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span>.obj</span> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.obj</span> <span class="fn">X</span></span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.cocones_obj_map_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L94-L94">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cocones_obj_map_app"><span class="name">CategoryTheory</span>.<span class="name">cocones_obj_map_app</span></a></span><span class="decl_args">
<span class="fn">(J : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u₃)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)
  (<span class="fn">a</span> : <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.coyoneda</span>.obj</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">F</span></span>)</span></span>)</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.obj</span> <span class="fn">X</span></span>)</span></span>)
  (<span class="fn">X_1</span> : <span class="fn">J</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cocones">CategoryTheory.cocones</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span>.obj</span> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">f</span> <span class="fn">a</span></span>)</span>.app</span> <span class="fn">X_1</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span>.app</span> <span class="fn">X_1</span></span>)</span> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.cocones"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L95-L97">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.cocones"><span class="name">CategoryTheory</span>.<span class="name">cocones</span></a></span><span class="decl_args">
<span class="fn">(J : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u₃)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> (max u₁ v₃))</a></span>)</span></span></div></div><p>Contravariantly associated to each functor <code>J ⥤ C</code>, we have the <code>C</code>-copresheaf consisting of
cocones with a given cocone point.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.cocones" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cone"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L115-L119">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max (max u₁ u₃) v₃)</div></div><p>A <code>c : <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> F</code> is:</p><ul>
<li>an object <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a></code> and</li>
<li>a natural transformation <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.π">π</a> : c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a> ⟶ F</code> from the constant <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a></code> functor to <code>F</code>.</li>
</ul><p>Example: if <code>J</code> is a category coming from a poset then the data required to make
a term of type <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> F</code> is morphisms <code>πⱼ : c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a> ⟶ F j</code> for all <code>j : J</code> and,
for all <code>i ≤ j</code> in <code>J</code>, morphisms <code>πᵢⱼ : F i ⟶ F j</code> such that <code>πᵢ ≫ πᵢⱼ = πᵢ</code>.</p><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> F</code> is equivalent, via <code>cone.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.equiv">equiv</a></code> below, to <code>Σ X, F.cones.obj X</code>.</p><ul class="structure_fields" id="CategoryTheory.Limits.Cone.mk"><li id="CategoryTheory.Limits.Cone.pt" class="structure_field"><div class="structure_field_info">pt : <span class="fn">C</span></div><div class="structure_field_doc"><p>An object of <code>C</code></p></div></li><li id="CategoryTheory.Limits.Cone.π" class="structure_field"><div class="structure_field_info">π : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.obj</span> <span class="fn"><span class="fn">self</span>.pt</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">F</span></span></div><div class="structure_field_doc"><p>A natural transformation from the constant functor at <code>X</code> to <code>F</code></p></div></li></ul><details id="instances-for-list-CategoryTheory.Limits.Cone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.inhabitedCone"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L121-L130">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.inhabitedCone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">inhabitedCone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{u_1 + 1}</a>     </span>)</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cone.w_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L132-L132">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">w_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">j'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.π</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.π</span>.app</span> <span class="fn">j'</span></span>)</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.w"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L133-L136">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.w"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.π</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">f</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.π</span>.app</span> <span class="fn">j'</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L148-L152">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max (max u₁ u₃) v₃)</div></div><p>A <code>c : <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Cocone</a> F</code> is</p><ul>
<li>an object <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a></code> and</li>
<li>a natural transformation <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.ι">ι</a> : F ⟶ c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a></code> from <code>F</code> to the constant <code>c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a></code> functor.</li>
</ul><p>For example, if the source <code>J</code> of <code>F</code> is a partially ordered set, then to give
<code>c : <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Cocone</a> F</code> is to give a collection of morphisms <code>ιⱼ : F j ⟶ c.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a></code> and, for
all <code>j ≤ k</code> in <code>J</code>, morphisms <code>ιⱼₖ : F j ⟶ F k</code> such that <code>Fⱼₖ ≫ Fₖ = Fⱼ</code> for all <code>j ≤ k</code>.</p><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Cocone</a> F</code> is equivalent, via <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.equiv">Cone.equiv</a></code> below, to <code>Σ X, F.cocones.obj X</code>.</p><ul class="structure_fields" id="CategoryTheory.Limits.Cocone.mk"><li id="CategoryTheory.Limits.Cocone.pt" class="structure_field"><div class="structure_field_info">pt : <span class="fn">C</span></div><div class="structure_field_doc"><p>An object of <code>C</code></p></div></li><li id="CategoryTheory.Limits.Cocone.ι" class="structure_field"><div class="structure_field_info">ι : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.obj</span> <span class="fn"><span class="fn">self</span>.pt</span></span></span></div><div class="structure_field_doc"><p>A natural transformation from <code>F</code> to the constant functor at <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.pt">pt</a></code></p></div></li></ul><details id="instances-for-list-CategoryTheory.Limits.Cocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.inhabitedCocone"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L154-L163">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.inhabitedCocone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">inhabitedCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{u_1 + 1}</a>     </span>)</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.w_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L165-L165">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">w_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span>.obj</span> <span class="fn">j'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.ι</span>.app</span> <span class="fn">j'</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.ι</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.w"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L166-L169">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.w"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.ι</span>.app</span> <span class="fn">j'</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.ι</span>.app</span> <span class="fn">j</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.equiv_hom_snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L180-L180">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.equiv_hom_snd"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">equiv_hom_snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.equiv">CategoryTheory.Limits.Cone.equiv</a> <span class="fn">F</span></span>)</span>.hom</span> <span class="fn">c</span></span>)</span>.snd</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">c</span>.π</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.equiv_inv_π"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L180-L180">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.equiv_inv_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">equiv_inv_π</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">(<span class="fn">X</span> : <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>) × <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.cones</span>.obj</span> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.equiv">CategoryTheory.Limits.Cone.equiv</a> <span class="fn">F</span></span>)</span>.inv</span> <span class="fn">c</span></span>)</span>.π</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">c</span>.snd</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.equiv_hom_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L180-L180">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.equiv_hom_fst"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">equiv_hom_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.equiv">CategoryTheory.Limits.Cone.equiv</a> <span class="fn">F</span></span>)</span>.hom</span> <span class="fn">c</span></span>)</span>.fst</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.equiv_inv_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L180-L180">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.equiv_inv_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">equiv_inv_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">(<span class="fn">X</span> : <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>) × <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.cones</span>.obj</span> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.equiv">CategoryTheory.Limits.Cone.equiv</a> <span class="fn">F</span></span>)</span>.inv</span> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.fst</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.equiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L181-L193">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.equiv"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">equiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">(<span class="fn">X</span> : <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>) × <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.cones</span>.obj</span> <span class="fn">X</span></span></span></span></div></div><p>The isomorphism between a cone on <code>F</code> and an element of the functor <code>F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cones">cones</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cone.equiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cone.extensions_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L196-L196">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.extensions_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">extensions_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.yoneda</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span>.comp</span> <a href="../../.././Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor">CategoryTheory.uliftFunctor.{u₁, v₃}</a>    </span>)</span>.obj</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.extensions</span>.app</span> <span class="fn">X</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.map</span> <span class="fn"><span class="fn">f</span>.down</span></span>)</span> <span class="fn"><span class="fn">c</span>.π</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.extensions"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L197-L198">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.extensions"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">extensions</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.yoneda</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span>.comp</span> <a href="../../.././Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor">CategoryTheory.uliftFunctor.{u₁, v₃}</a>    </span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">F</span>.cones</span></span></div></div><p>A map to the vertex of a cone naturally induces a cone by composition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cone.extensions" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cone.extend_π"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L201-L201">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.extend_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">extend_π</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">c</span>.extend</span> <span class="fn">f</span></span>)</span>.π</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.extensions</span>.app</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span></span>)</span> <span class="fn">{ <span class="fn">down</span> := <span class="fn">f</span> }</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.extend_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L201-L201">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.extend_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">extend_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">c</span>.extend</span> <span class="fn">f</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.extend"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L202-L204">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.extend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">extend</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span></div></div><p>A map to the vertex of a cone induces a cone by composition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.extend</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn">X</span>, <span class="fn">π</span> := <span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.extensions</span>.app</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span></span>)</span> <span class="fn">{ <span class="fn">down</span> := <span class="fn">f</span> }</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cone.extend" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cone.whisker_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L207-L207">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">whisker_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker">CategoryTheory.Limits.Cone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">c</span>.pt</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.whisker_π"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L207-L207">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">whisker_π</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker">CategoryTheory.Limits.Cone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span>)</span>.π</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerLeft">CategoryTheory.whiskerLeft</a> <span class="fn">E</span> <span class="fn"><span class="fn">c</span>.π</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.whisker"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L208-L210">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">whisker</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">E</span>.comp</span> <span class="fn">F</span></span>)</span></span></div></div><p>Whisker a cone by precomposition of a functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker">CategoryTheory.Limits.Cone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><span class="fn">c</span>.pt</span>, <span class="fn">π</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerLeft">CategoryTheory.whiskerLeft</a> <span class="fn">E</span> <span class="fn"><span class="fn">c</span>.π</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cone.whisker" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.equiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L217-L229">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.equiv"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">equiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>) × <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.cocones</span>.obj</span> <span class="fn">X</span></span></span></span></div></div><p>The isomorphism between a cocone on <code>F</code> and an element of the functor <code>F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cocones">cocones</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocone.equiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.extensions_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L232-L232">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.extensions_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">extensions_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.coyoneda</span>.obj</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span>)</span>.comp</span> <a href="../../.././Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor">CategoryTheory.uliftFunctor.{u₁, v₃}</a>    </span>)</span>.obj</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.extensions</span>.app</span> <span class="fn">X</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">c</span>.ι</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">CategoryTheory.Functor.const</a> <span class="fn">J</span></span>)</span>.map</span> <span class="fn"><span class="fn">f</span>.down</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.extensions"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L233-L234">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.extensions"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">extensions</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">CategoryTheory.coyoneda</span>.obj</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span>)</span>.comp</span> <a href="../../.././Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor">CategoryTheory.uliftFunctor.{u₁, v₃}</a>    </span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">F</span>.cocones</span></span></div></div><p>A map from the vertex of a cocone naturally induces a cocone by composition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocone.extensions" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.extend_ι"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L237-L237">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.extend_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">extend_ι</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">c</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">c</span>.extend</span> <span class="fn">f</span></span>)</span>.ι</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.extensions</span>.app</span> <span class="fn">Y</span> <span class="fn">{ <span class="fn">down</span> := <span class="fn">f</span> }</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.extend_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L237-L237">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.extend_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">extend_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">c</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">c</span>.extend</span> <span class="fn">f</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Y</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.extend"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L238-L240">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.extend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">extend</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">c</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span></div></div><p>A map from the vertex of a cocone induces a cocone by composition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.extend</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn">Y</span>, <span class="fn">ι</span> := <span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.extensions</span>.app</span> <span class="fn">Y</span> <span class="fn">{ <span class="fn">down</span> := <span class="fn">f</span> }</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocone.extend" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.whisker_ι"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L245-L245">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.whisker_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">whisker_ι</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.whisker">CategoryTheory.Limits.Cocone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span>)</span>.ι</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerLeft">CategoryTheory.whiskerLeft</a> <span class="fn">E</span> <span class="fn"><span class="fn">c</span>.ι</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.whisker_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L245-L245">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.whisker_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">whisker_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.whisker">CategoryTheory.Limits.Cocone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">c</span>.pt</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.whisker"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L246-L248">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.whisker"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">whisker</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">E</span>.comp</span> <span class="fn">F</span></span>)</span></span></div></div><p>Whisker a cocone by precomposition of a functor. See <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering">whiskering</a></code> for a functorial
version.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.whisker">CategoryTheory.Limits.Cocone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><span class="fn">c</span>.pt</span>, <span class="fn">ι</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerLeft">CategoryTheory.whiskerLeft</a> <span class="fn">E</span> <span class="fn"><span class="fn">c</span>.ι</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocone.whisker" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.ConeMorphism"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L254-L258">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.ConeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">ConeMorphism</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> v₃</div></div><p>A cone morphism between two cones for the same diagram is a morphism of the cone points which
commutes with the cone legs.</p><ul class="structure_fields" id="CategoryTheory.Limits.ConeMorphism.mk"><li id="CategoryTheory.Limits.ConeMorphism.hom" class="structure_field"><div class="structure_field_info">hom : <span class="fn"><span class="fn"><span class="fn">A</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">B</span>.pt</span></span></div><div class="structure_field_doc"><p>A morphism between the two vertex objects of the cones</p></div></li><li id="CategoryTheory.Limits.ConeMorphism.w" class="structure_field"><div class="structure_field_info">w : <span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">self</span>.hom</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">B</span>.π</span>.app</span> <span class="fn">j</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">A</span>.π</span>.app</span> <span class="fn">j</span></span></span></span></div><div class="structure_field_doc"><p>The triangle consisting of the two natural transformations and <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.ConeMorphism.hom">hom</a></code> commutes</p></div></li></ul><details id="instances-for-list-CategoryTheory.Limits.ConeMorphism" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.ConeMorphism.w"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L258-L258">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.ConeMorphism.w"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">ConeMorphism</span>.<span class="name">w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.ConeMorphism">CategoryTheory.Limits.ConeMorphism</a> <span class="fn">A</span> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">self</span>.hom</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">B</span>.π</span>.app</span> <span class="fn">j</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">A</span>.π</span>.app</span> <span class="fn">j</span></span></span></div></div><p>The triangle consisting of the two natural transformations and <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.ConeMorphism.hom">hom</a></code> commutes</p></div></div><div class="decl" id="CategoryTheory.Limits.ConeMorphism.w_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L260-L260">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.ConeMorphism.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">ConeMorphism</span>.<span class="name">w_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.ConeMorphism">CategoryTheory.Limits.ConeMorphism</a> <span class="fn">A</span> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">j</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">self</span>.hom</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">B</span>.π</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">A</span>.π</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.inhabitedConeMorphism"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L262-L263">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.inhabitedConeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">inhabitedConeMorphism</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.ConeMorphism">CategoryTheory.Limits.ConeMorphism</a> <span class="fn">A</span> <span class="fn">A</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.inhabitedConeMorphism">CategoryTheory.Limits.inhabitedConeMorphism</a> <span class="fn">A</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">A</span>.pt</span></span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cone.category_comp_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L266-L266">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.category_comp_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">category_comp_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.category_id_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L266-L266">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.category_id_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">category_id_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">B</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.category"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L267-L270">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.category"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">category</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, max (max u₃ u₁) v₃}</a>                     <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span></div></div><p>The category of cones on a given diagram.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Limits.Cone.category</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category.mk">CategoryTheory.Category.mk</a> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.ConeMorphism.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L276-L279">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.ConeMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">ConeMorphism</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><span class="fn"><span class="fn">f</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.hom</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.ext_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L287-L287">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">ext_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn"><span class="fn">c</span>.pt</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">c'</span>.pt</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.π</span>.app</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">φ</span>.hom</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c'</span>.π</span>.app</span> <span class="fn">j</span></span>)</span></span></span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#_auto._@.Mathlib.CategoryTheory.Limits.Cones._hyg.1953">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">φ</span> <span class="fn">w</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">φ</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.ext_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L287-L287">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">ext_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn"><span class="fn">c</span>.pt</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">c'</span>.pt</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.π</span>.app</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">φ</span>.hom</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c'</span>.π</span>.app</span> <span class="fn">j</span></span>)</span></span></span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#_auto._@.Mathlib.CategoryTheory.Limits.Cones._hyg.1953">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">φ</span> <span class="fn">w</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">φ</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.ext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L288-L293">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn"><span class="fn">c</span>.pt</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">c'</span>.pt</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.π</span>.app</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">φ</span>.hom</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c'</span>.π</span>.app</span> <span class="fn">j</span></span>)</span></span></span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#_auto._@.Mathlib.CategoryTheory.Limits.Cones._hyg.1953">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">c'</span></span></div></div><p>To give an isomorphism between cones, it suffices to give an
isomorphism between their vertices which commutes with the cone
maps.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">φ</span> <span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">hom</span> := <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><span class="fn">φ</span>.hom</span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span>, <span class="fn">inv</span> := <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><span class="fn">φ</span>.inv</span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span>, <span class="fn">hom_inv_id</span> := <span class="fn">⋯</span>, <span class="fn">inv_hom_id</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.ext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.eta_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L296-L296">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.eta_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">eta_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.eta">CategoryTheory.Limits.Cones.eta</a> <span class="fn">c</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.eta_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L296-L296">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.eta_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">eta_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.eta">CategoryTheory.Limits.Cones.eta</a> <span class="fn">c</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.eta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L297-L298">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.eta"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">eta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><span class="fn">c</span>.pt</span>, <span class="fn">π</span> := <span class="fn"><span class="fn">c</span>.π</span> }</span></span></div></div><p>Eta rule for cones.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.eta">CategoryTheory.Limits.Cones.eta</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.eta" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.cone_iso_of_hom_iso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L303-L305">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.cone_iso_of_hom_iso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">cone_iso_of_hom_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">K</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">K</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">d</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[i : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn"><span class="fn">f</span>.hom</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">f</span></span></div></div><p>Given a cone morphism whose object part is an isomorphism, produce an
isomorphism of cones.</p></div></div><div class="decl" id="CategoryTheory.Limits.Cones.extend_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L308-L308">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extend_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extend_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extend">CategoryTheory.Limits.Cones.extend</a> <span class="fn">s</span> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.extend"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L309-L310">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extend</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn">f</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span></span></div></div><p>There is a morphism from an extended cone to the original cone.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extend">CategoryTheory.Limits.Cones.extend</a> <span class="fn">s</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hom</span> := <span class="fn">f</span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.extend" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.extendId_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L313-L313">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendId_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendId_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendId">CategoryTheory.Limits.Cones.extendId</a> <span class="fn">s</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">s</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.extendId_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L313-L313">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendId_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendId_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendId">CategoryTheory.Limits.Cones.extendId</a> <span class="fn">s</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">s</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.extendId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L314-L315">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendId"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">s</span></span></div></div><p>Extending a cone by the identity does nothing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendId">CategoryTheory.Limits.Cones.extendId</a> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.extendId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.extendComp_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L318-L318">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendComp_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendComp_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendComp">CategoryTheory.Limits.Cones.extendComp</a> <span class="fn">s</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.extendComp_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L318-L318">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendComp_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendComp_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendComp">CategoryTheory.Limits.Cones.extendComp</a> <span class="fn">s</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.extendComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L319-L321">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendComp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn">g</span></span>)</span>.extend</span> <span class="fn">f</span></span></span></div></div><p>Extending a cone by a composition is the same as extending the cone twice.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendComp">CategoryTheory.Limits.Cones.extendComp</a> <span class="fn">s</span> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.extendComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.extendIso_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L324-L324">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendIso_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendIso_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendIso">CategoryTheory.Limits.Cones.extendIso</a> <span class="fn">s</span> <span class="fn">f</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.extendIso_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L324-L324">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendIso_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendIso_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendIso">CategoryTheory.Limits.Cones.extendIso</a> <span class="fn">s</span> <span class="fn">f</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.extendIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L325-L327">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">extendIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn"><span class="fn">f</span>.hom</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">s</span></span></div></div><p>A cone extended by an isomorphism is isomorphic to the original cone.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extendIso">CategoryTheory.Limits.Cones.extendIso</a> <span class="fn">s</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">hom</span> := <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><span class="fn">f</span>.hom</span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span>, <span class="fn">inv</span> := <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><span class="fn">f</span>.inv</span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span>, <span class="fn">hom_inv_id</span> := <span class="fn">⋯</span>, <span class="fn">inv_hom_id</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.extendIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.instIsIsoConeExtend"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L329-L330">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.instIsIsoConeExtend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">instIsIsoConeExtend</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.extend">CategoryTheory.Limits.Cones.extend</a> <span class="fn">s</span> <span class="fn">f</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcompose_obj_π"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L335-L335">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose_obj_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcompose_obj_π</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">α</span></span>)</span>.obj</span> <span class="fn">c</span></span>)</span>.π</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">c</span>.π</span> <span class="fn">α</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcompose_obj_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L335-L335">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose_obj_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcompose_obj_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">α</span></span>)</span>.obj</span> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">c</span>.pt</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcompose_map_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L335-L335">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcompose_map_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">α</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcompose"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L336-L340">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcompose</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">G</span></span>)</span></span></div></div><p>Functorially postcompose a cone for <code>F</code> by a natural transformation <code>F ⟶ G</code> to give a cone for <code>G</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.postcompose" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcomposeComp_hom_app_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L344-L344">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeComp_hom_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeComp_hom_app_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">H</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeComp">CategoryTheory.Limits.Cones.postcomposeComp</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">X</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcomposeComp_inv_app_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L344-L344">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeComp_inv_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeComp_inv_app_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">H</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeComp">CategoryTheory.Limits.Cones.postcomposeComp</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">X</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcomposeComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L345-L347">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeComp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">α</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">β</span></span>)</span></span></span></div></div><p>Postcomposing a cone by the composite natural transformation <code>α ≫ β</code> is the same as
postcomposing by <code>α</code> and then by <code>β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.postcomposeComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcomposeId_hom_app_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L350-L350">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeId_hom_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeId_hom_app_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.Limits.Cones.postcomposeId</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">X</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcomposeId_inv_app_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L350-L350">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeId_inv_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeId_inv_app_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">CategoryTheory.Limits.Cones.postcomposeId</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">X</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcomposeId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L351-L352">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeId"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">F</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span></span></div></div><p>Postcomposing by the identity does not change the cone up to isomorphism.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.postcomposeId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcomposeEquivalence_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L357-L357">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeEquivalence_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence">CategoryTheory.Limits.Cones.postcomposeEquivalence</a> <span class="fn">α</span></span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">α</span>.inv</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcomposeEquivalence_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L357-L357">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeEquivalence_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence">CategoryTheory.Limits.Cones.postcomposeEquivalence</a> <span class="fn">α</span></span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>)</span>.obj</span> <span class="fn">s</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcomposeEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L357-L357">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence">CategoryTheory.Limits.Cones.postcomposeEquivalence</a> <span class="fn">α</span></span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">α</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcomposeEquivalence_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L357-L357">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeEquivalence_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence">CategoryTheory.Limits.Cones.postcomposeEquivalence</a> <span class="fn">α</span></span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">G</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a>
          <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">α</span>.inv</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">α</span>.hom</span></span>)</span></span>)</span>.obj</span>
              <span class="fn">s</span></span>)</span>.pt</span></span>)</span>
        <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.postcomposeEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L358-L362">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">postcomposeEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">G</span></span></span></div></div><p>If <code>F</code> and <code>G</code> are naturally isomorphic functors, then they have equivalent categories of
cones.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.postcomposeEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.whiskering_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L366-L366">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskering_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering">CategoryTheory.Limits.Cones.whiskering</a> <span class="fn">E</span></span>)</span>.obj</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker">CategoryTheory.Limits.Cone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.whiskering_map_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L366-L366">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskering_map_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering">CategoryTheory.Limits.Cones.whiskering</a> <span class="fn">E</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.whiskering"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L367-L369">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskering</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">E</span>.comp</span> <span class="fn">F</span></span>)</span></span>)</span></span></div></div><p>Whiskering on the left by <code>E : K ⥤ J</code> gives a functor from <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> F</code> to <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> (E ⋙ F)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.whiskering" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.whiskeringEquivalence_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L373-L373">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskeringEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskeringEquivalence_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskeringEquivalence">CategoryTheory.Limits.Cones.whiskeringEquivalence</a> <span class="fn">e</span></span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>)</span>.obj</span> <span class="fn">s</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.whiskeringEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L373-L373">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskeringEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskeringEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskeringEquivalence">CategoryTheory.Limits.Cones.whiskeringEquivalence</a> <span class="fn">e</span></span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering">CategoryTheory.Limits.Cones.whiskering</a> <span class="fn"><span class="fn">e</span>.functor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.whiskeringEquivalence_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L373-L373">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskeringEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskeringEquivalence_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskeringEquivalence">CategoryTheory.Limits.Cones.whiskeringEquivalence</a> <span class="fn">e</span></span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering">CategoryTheory.Limits.Cones.whiskering</a> <span class="fn"><span class="fn">e</span>.inverse</span></span>)</span>.comp</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.invFunIdAssoc</span> <span class="fn">F</span></span>)</span>.hom</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.whiskeringEquivalence_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L373-L373">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskeringEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskeringEquivalence_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskeringEquivalence">CategoryTheory.Limits.Cones.whiskeringEquivalence</a> <span class="fn">e</span></span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span>)</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a>
          <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering">CategoryTheory.Limits.Cones.whiskering</a> <span class="fn"><span class="fn">e</span>.inverse</span></span>)</span>.comp</span>
                      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.invFunIdAssoc</span> <span class="fn">F</span></span>)</span>.hom</span></span>)</span></span>)</span>.comp</span>
                  <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering">CategoryTheory.Limits.Cones.whiskering</a> <span class="fn"><span class="fn">e</span>.functor</span></span>)</span></span>)</span>.obj</span>
              <span class="fn">s</span></span>)</span>.pt</span></span>)</span>
        <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.whiskeringEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L374-L384">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskeringEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">whiskeringEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span>)</span></span></span></div></div><p>Whiskering by an equivalence gives an equivalence between categories of cones.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.whiskeringEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.equivalenceOfReindexing_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L389-L389">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.equivalenceOfReindexing_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">equivalenceOfReindexing_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.equivalenceOfReindexing">CategoryTheory.Limits.Cones.equivalenceOfReindexing</a> <span class="fn">e</span> <span class="fn">α</span></span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">α</span>.inv</span></span>)</span>.comp</span>
    <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering">CategoryTheory.Limits.Cones.whiskering</a> <span class="fn"><span class="fn">e</span>.inverse</span></span>)</span>.comp</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.invFunIdAssoc</span> <span class="fn">F</span></span>)</span>.hom</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.equivalenceOfReindexing_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L389-L389">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.equivalenceOfReindexing_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">equivalenceOfReindexing_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.equivalenceOfReindexing">CategoryTheory.Limits.Cones.equivalenceOfReindexing</a> <span class="fn">e</span> <span class="fn">α</span></span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering">CategoryTheory.Limits.Cones.whiskering</a> <span class="fn"><span class="fn">e</span>.functor</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">α</span>.hom</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.equivalenceOfReindexing_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L389-L389">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.equivalenceOfReindexing_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">equivalenceOfReindexing_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.equivalenceOfReindexing">CategoryTheory.Limits.Cones.equivalenceOfReindexing</a> <span class="fn">e</span> <span class="fn">α</span></span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">α</span>.inv</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
          <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span>)</span></span>) =&gt;
            <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
          <span class="fn">⋯</span></span>)</span>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">α</span>.hom</span></span>)</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
      <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">G</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.equivalenceOfReindexing_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L389-L389">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.equivalenceOfReindexing_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">equivalenceOfReindexing_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.equivalenceOfReindexing">CategoryTheory.Limits.Cones.equivalenceOfReindexing</a> <span class="fn">e</span> <span class="fn">α</span></span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
      <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span> <span class="fn">⋯</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering">CategoryTheory.Limits.Cones.whiskering</a> <span class="fn"><span class="fn">e</span>.functor</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
          <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span>)</span></span>) =&gt;
            <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
          <span class="fn">⋯</span></span>)</span>
        <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskering">CategoryTheory.Limits.Cones.whiskering</a> <span class="fn"><span class="fn">e</span>.inverse</span></span>)</span>.comp</span>
          <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.invFunIdAssoc</span> <span class="fn">F</span></span>)</span>.hom</span></span>)</span></span>)</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.equivalenceOfReindexing"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L390-L391">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.equivalenceOfReindexing"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">equivalenceOfReindexing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">G</span></span></span></div></div><p>The categories of cones over <code>F</code> and <code>G</code> are equivalent if <code>F</code> and <code>G</code> are naturally isomorphic
(possibly after changing the indexing category by an equivalence).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.equivalenceOfReindexing">CategoryTheory.Limits.Cones.equivalenceOfReindexing</a> <span class="fn">e</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.whiskeringEquivalence">CategoryTheory.Limits.Cones.whiskeringEquivalence</a> <span class="fn">e</span></span>)</span>.trans</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence">CategoryTheory.Limits.Cones.postcomposeEquivalence</a> <span class="fn">α</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.equivalenceOfReindexing" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.forget_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L398-L398">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">forget_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.forget">CategoryTheory.Limits.Cones.forget</a> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.forget_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L398-L398">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">forget_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.forget">CategoryTheory.Limits.Cones.forget</a> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span>.pt</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.forget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L399-L401">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.forget"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span> <span class="fn">C</span></span></div></div><p>Forget the cone structure and obtain just the cone point.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.forget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.functoriality_map_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L406-L406">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality_map_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">G</span>.map</span> <span class="fn"><span class="fn">f</span>.hom</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.functoriality_obj_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L406-L406">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality_obj_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality_obj_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.obj</span> <span class="fn">A</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn"><span class="fn">A</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.functoriality_obj_π_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L406-L406">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality_obj_π_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality_obj_π_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.obj</span> <span class="fn">A</span></span>)</span>.π</span>.app</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">G</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">A</span>.π</span>.app</span> <span class="fn">j</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.functoriality"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L407-L415">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">G</span></span>)</span></span>)</span></span></div></div><p>A functor <code>G : C ⥤ D</code> sends cones over <code>F</code> to cones over <code>F ⋙ G</code> functorially.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.functoriality" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.functoriality_full"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L417-L420">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality_full"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality_full</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">G</span>.Full</span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">G</span>.Faithful</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.Full</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.functoriality_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L422-L424">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality_faithful"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functoriality_faithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">G</span>.Faithful</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.functorialityEquivalence_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L429-L429">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functorialityEquivalence_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence">CategoryTheory.Limits.Cones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn">e</span></span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn"><span class="fn">e</span>.functor</span></span>)</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitIso</span>.app</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.functorialityEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L429-L429">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functorialityEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence">CategoryTheory.Limits.Cones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn">e</span></span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">F</span> <span class="fn"><span class="fn">e</span>.functor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.functorialityEquivalence_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L429-L429">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functorialityEquivalence_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence">CategoryTheory.Limits.Cones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn">e</span></span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn"><span class="fn">e</span>.functor</span></span>)</span> <span class="fn"><span class="fn">e</span>.inverse</span></span>)</span>.comp</span>
    <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence">CategoryTheory.Limits.Cones.postcomposeEquivalence</a>
        <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.associator</span> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn"><span class="fn">e</span>.inverse</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn">F</span> <span class="fn"><span class="fn"><span class="fn">e</span>.unitIso</span>.symm</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">F</span>.rightUnitor</span></span></span>)</span></span>)</span>.functor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.functorialityEquivalence_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L429-L429">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functorialityEquivalence_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence">CategoryTheory.Limits.Cones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn">e</span></span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a>
        <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitIso</span>.app</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>)</span>.obj</span> <span class="fn">c</span></span>)</span>.1</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cones.functorialityEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L430-L436">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">functorialityEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn"><span class="fn">e</span>.functor</span></span>)</span></span></span></div></div><p>If <code>e : C ≌ D</code> is an equivalence of categories, then <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">functoriality</a> F e.functor</code> induces an
equivalence between cones over <code>F</code> and cones over <code>F ⋙ e.functor</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cones.functorialityEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cones.reflects_cone_isomorphism"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L441-L448">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.reflects_cone_isomorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cones</span>.<span class="name">reflects_cone_isomorphism</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.ReflectsIsomorphisms</span>]</span></span>
</span><span class="decl_args">
<span class="fn">(K : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">K</span> <span class="fn">F</span></span>)</span>.ReflectsIsomorphisms</span></div></div><p>If <code>F</code> reflects isomorphisms, then <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">Cones.functoriality</a> F</code> reflects isomorphisms
as well.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.CoconeMorphism"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L456-L460">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.CoconeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">CoconeMorphism</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> v₃</div></div><p>A cocone morphism between two cocones for the same diagram is a morphism of the cocone points
which commutes with the cocone legs.</p><ul class="structure_fields" id="CategoryTheory.Limits.CoconeMorphism.mk"><li id="CategoryTheory.Limits.CoconeMorphism.hom" class="structure_field"><div class="structure_field_info">hom : <span class="fn"><span class="fn"><span class="fn">A</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">B</span>.pt</span></span></div><div class="structure_field_doc"><p>A morphism between the (co)vertex objects in <code>C</code></p></div></li><li id="CategoryTheory.Limits.CoconeMorphism.w" class="structure_field"><div class="structure_field_info">w : <span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">A</span>.ι</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn"><span class="fn">self</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">B</span>.ι</span>.app</span> <span class="fn">j</span></span></span></span></div><div class="structure_field_doc"><p>The triangle made from the two natural transformations and <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.ConeMorphism.hom">hom</a></code> commutes</p></div></li></ul><details id="instances-for-list-CategoryTheory.Limits.CoconeMorphism" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.CoconeMorphism.w"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L460-L460">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.CoconeMorphism.w"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">CoconeMorphism</span>.<span class="name">w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.CoconeMorphism">CategoryTheory.Limits.CoconeMorphism</a> <span class="fn">A</span> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">A</span>.ι</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn"><span class="fn">self</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">B</span>.ι</span>.app</span> <span class="fn">j</span></span></span></div></div><p>The triangle made from the two natural transformations and <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.ConeMorphism.hom">hom</a></code> commutes</p></div></div><div class="decl" id="CategoryTheory.Limits.inhabitedCoconeMorphism"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L462-L463">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.inhabitedCoconeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">inhabitedCoconeMorphism</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.CoconeMorphism">CategoryTheory.Limits.CoconeMorphism</a> <span class="fn">A</span> <span class="fn">A</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.inhabitedCoconeMorphism">CategoryTheory.Limits.inhabitedCoconeMorphism</a> <span class="fn">A</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">A</span>.pt</span></span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.CoconeMorphism.w_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L465-L465">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.CoconeMorphism.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">CoconeMorphism</span>.<span class="name">w_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.CoconeMorphism">CategoryTheory.Limits.CoconeMorphism</a> <span class="fn">A</span> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">B</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">A</span>.ι</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">self</span>.hom</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">B</span>.ι</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.category_id_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L467-L467">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.category_id_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">category_id_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">B</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.category_comp_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L467-L467">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.category_comp_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">category_comp_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.category"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L468-L471">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.category"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">category</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, max (max u₃ u₁) v₃}</a>                     <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Limits.Cocone.category</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category.mk">CategoryTheory.Category.mk</a> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.CoconeMorphism.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L477-L480">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.CoconeMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">CoconeMorphism</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><span class="fn"><span class="fn">f</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.hom</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.ext_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L488-L488">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">ext_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn"><span class="fn">c</span>.pt</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">c'</span>.pt</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.ι</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn"><span class="fn">φ</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">c'</span>.ι</span>.app</span> <span class="fn">j</span></span></span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#_auto._@.Mathlib.CategoryTheory.Limits.Cones._hyg.4652">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a> <span class="fn">φ</span> <span class="fn">w</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">φ</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.ext_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L488-L488">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">ext_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn"><span class="fn">c</span>.pt</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">c'</span>.pt</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.ι</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn"><span class="fn">φ</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">c'</span>.ι</span>.app</span> <span class="fn">j</span></span></span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#_auto._@.Mathlib.CategoryTheory.Limits.Cones._hyg.4652">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a> <span class="fn">φ</span> <span class="fn">w</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">φ</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.ext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L489-L494">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(φ : <span class="fn"><span class="fn"><span class="fn">c</span>.pt</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">c'</span>.pt</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../../.././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">(<span class="fn">∀ (<span class="fn">j</span> : <span class="fn">J</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.ι</span>.app</span> <span class="fn">j</span></span>)</span> <span class="fn"><span class="fn">φ</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">c'</span>.ι</span>.app</span> <span class="fn">j</span></span></span></span>)</span> <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#_auto._@.Mathlib.CategoryTheory.Limits.Cones._hyg.4652">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">c'</span></span></div></div><p>To give an isomorphism between cocones, it suffices to give an
isomorphism between their vertices which commutes with the cocone
maps.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a> <span class="fn">φ</span> <span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">hom</span> := <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><span class="fn">φ</span>.hom</span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span>, <span class="fn">inv</span> := <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><span class="fn">φ</span>.inv</span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span>, <span class="fn">hom_inv_id</span> := <span class="fn">⋯</span>, <span class="fn">inv_hom_id</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.ext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.eta_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L497-L497">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.eta_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">eta_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.eta">CategoryTheory.Limits.Cocones.eta</a> <span class="fn">c</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.eta_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L497-L497">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.eta_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">eta_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.eta">CategoryTheory.Limits.Cocones.eta</a> <span class="fn">c</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.eta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L498-L499">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.eta"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">eta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><span class="fn">c</span>.pt</span>, <span class="fn">ι</span> := <span class="fn"><span class="fn">c</span>.ι</span> }</span></span></div></div><p>Eta rule for cocones.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.eta">CategoryTheory.Limits.Cocones.eta</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.eta" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.cocone_iso_of_hom_iso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L504-L507">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.cocone_iso_of_hom_iso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">cocone_iso_of_hom_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">K</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">K</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">d</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[i : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn"><span class="fn">f</span>.hom</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">f</span></span></div></div><p>Given a cocone morphism whose object part is an isomorphism, produce an
isomorphism of cocones.</p></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.extend_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L510-L510">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extend_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extend_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">s</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extend">CategoryTheory.Limits.Cocones.extend</a> <span class="fn">s</span> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.extend"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L511-L512">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extend</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">s</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">s</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn">f</span></span></span></div></div><p>There is a morphism from a cocone to its extension.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extend">CategoryTheory.Limits.Cocones.extend</a> <span class="fn">s</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hom</span> := <span class="fn">f</span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.extend" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.extendId_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L515-L515">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendId_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendId_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendId">CategoryTheory.Limits.Cocones.extendId</a> <span class="fn">s</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">s</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.extendId_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L515-L515">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendId_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendId_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendId">CategoryTheory.Limits.Cocones.extendId</a> <span class="fn">s</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">s</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.extendId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L516-L517">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendId"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">s</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span></span></span></div></div><p>Extending a cocone by the identity does nothing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendId">CategoryTheory.Limits.Cocones.extendId</a> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">s</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.extendId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.extendComp_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L520-L520">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendComp_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendComp_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">s</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendComp">CategoryTheory.Limits.Cocones.extendComp</a> <span class="fn">s</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.extendComp_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L520-L520">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendComp_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendComp_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">s</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendComp">CategoryTheory.Limits.Cocones.extendComp</a> <span class="fn">s</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.extendComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L521-L523">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendComp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">s</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn">f</span></span>)</span>.extend</span> <span class="fn">g</span></span></span></div></div><p>Extending a cocone by a composition is the same as extending the cone twice.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendComp">CategoryTheory.Limits.Cocones.extendComp</a> <span class="fn">s</span> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.extendComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.extendIso_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L526-L526">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendIso_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendIso_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">s</span>.pt</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendIso">CategoryTheory.Limits.Cocones.extendIso</a> <span class="fn">s</span> <span class="fn">f</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.extendIso_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L526-L526">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendIso_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendIso_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">s</span>.pt</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendIso">CategoryTheory.Limits.Cocones.extendIso</a> <span class="fn">s</span> <span class="fn">f</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.extendIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L527-L529">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">extendIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">s</span>.pt</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">s</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">s</span>.extend</span> <span class="fn"><span class="fn">f</span>.hom</span></span></span></div></div><p>A cocone extended by an isomorphism is isomorphic to the original cone.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extendIso">CategoryTheory.Limits.Cocones.extendIso</a> <span class="fn">s</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">hom</span> := <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><span class="fn">f</span>.hom</span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span>, <span class="fn">inv</span> := <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><span class="fn">f</span>.inv</span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span>, <span class="fn">hom_inv_id</span> := <span class="fn">⋯</span>, <span class="fn">inv_hom_id</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.extendIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.instIsIsoCoconeExtend"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L531-L532">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.instIsIsoCoconeExtend"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">instIsIsoCoconeExtend</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">s</span>.pt</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.extend">CategoryTheory.Limits.Cocones.extend</a> <span class="fn">s</span> <span class="fn">f</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.precompose_obj_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L536-L536">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose_obj_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precompose_obj_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">α</span></span>)</span>.obj</span> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">c</span>.pt</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.precompose_obj_ι"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L536-L536">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose_obj_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precompose_obj_ι</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">α</span></span>)</span>.obj</span> <span class="fn">c</span></span>)</span>.ι</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">α</span> <span class="fn"><span class="fn">c</span>.ι</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.precompose_map_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L536-L536">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precompose_map_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">α</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.precompose"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L537-L541">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precompose</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">G</span></span>)</span></span></div></div><p>Functorially precompose a cocone for <code>F</code> by a natural transformation <code>G ⟶ F</code> to give a cocone
for <code>G</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.precompose" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.precomposeComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L545-L547">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeComp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">β</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">α</span></span>)</span></span></span></div></div><p>Precomposing a cocone by the composite natural transformation <code>α ≫ β</code> is the same as
precomposing by <code>β</code> and then by <code>α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.precomposeComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.precomposeId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L550-L551">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeId"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">F</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span></span></div></div><p>Precomposing by the identity does not change the cocone up to isomorphism.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.precomposeId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.precomposeEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L556-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence">CategoryTheory.Limits.Cocones.precomposeEquivalence</a> <span class="fn">α</span></span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn"><span class="fn">α</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.precomposeEquivalence_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L556-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeEquivalence_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence">CategoryTheory.Limits.Cocones.precomposeEquivalence</a> <span class="fn">α</span></span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>)</span>.obj</span> <span class="fn">s</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.precomposeEquivalence_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L556-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeEquivalence_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence">CategoryTheory.Limits.Cocones.precomposeEquivalence</a> <span class="fn">α</span></span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">G</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a>
          <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn"><span class="fn">α</span>.inv</span></span>)</span>.comp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn"><span class="fn">α</span>.hom</span></span>)</span></span>)</span>.obj</span>
              <span class="fn">s</span></span>)</span>.pt</span></span>)</span>
        <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.precomposeEquivalence_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L556-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeEquivalence_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence">CategoryTheory.Limits.Cocones.precomposeEquivalence</a> <span class="fn">α</span></span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn"><span class="fn">α</span>.inv</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.precomposeEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L557-L561">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">precomposeEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">G</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">G</span></span></span></div></div><p>If <code>F</code> and <code>G</code> are naturally isomorphic functors, then they have equivalent categories of
cocones.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.precomposeEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.whiskering_map_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L565-L565">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskering_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskering_map_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskering">CategoryTheory.Limits.Cocones.whiskering</a> <span class="fn">E</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.whiskering_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L565-L565">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskering_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskering_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskering">CategoryTheory.Limits.Cocones.whiskering</a> <span class="fn">E</span></span>)</span>.obj</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.whisker">CategoryTheory.Limits.Cocone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.whiskering"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L566-L568">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskering"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskering</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">E</span>.comp</span> <span class="fn">F</span></span>)</span></span>)</span></span></div></div><p>Whiskering on the left by <code>E : K ⥤ J</code> gives a functor from <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Cocone</a> F</code> to <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Cocone</a> (E ⋙ F)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.whiskering" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.whiskeringEquivalence_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L572-L572">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskeringEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskeringEquivalence_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskeringEquivalence">CategoryTheory.Limits.Cocones.whiskeringEquivalence</a> <span class="fn">e</span></span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskering">CategoryTheory.Limits.Cocones.whiskering</a> <span class="fn"><span class="fn">e</span>.inverse</span></span>)</span>.comp</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">F</span>.leftUnitor</span>.inv</span>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerRight">CategoryTheory.whiskerRight</a> <span class="fn"><span class="fn"><span class="fn">e</span>.counitIso</span>.inv</span> <span class="fn">F</span></span>)</span>
          <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.associator</span> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn">F</span></span>)</span>.inv</span></span>)</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.whiskeringEquivalence_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L572-L572">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskeringEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskeringEquivalence_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskeringEquivalence">CategoryTheory.Limits.Cocones.whiskeringEquivalence</a> <span class="fn">e</span></span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span>)</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a>
          <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskering">CategoryTheory.Limits.Cocones.whiskering</a> <span class="fn"><span class="fn">e</span>.inverse</span></span>)</span>.comp</span>
                      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a>
                        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">F</span>.leftUnitor</span>.inv</span>
                          <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerRight">CategoryTheory.whiskerRight</a> <span class="fn"><span class="fn"><span class="fn">e</span>.counitIso</span>.inv</span> <span class="fn">F</span></span>)</span>
                            <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inverse</span>.associator</span> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn">F</span></span>)</span>.inv</span></span>)</span></span>)</span></span>)</span></span>)</span>.comp</span>
                  <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskering">CategoryTheory.Limits.Cocones.whiskering</a> <span class="fn"><span class="fn">e</span>.functor</span></span>)</span></span>)</span>.obj</span>
              <span class="fn">s</span></span>)</span>.pt</span></span>)</span>
        <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.whiskeringEquivalence_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L572-L572">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskeringEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskeringEquivalence_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskeringEquivalence">CategoryTheory.Limits.Cocones.whiskeringEquivalence</a> <span class="fn">e</span></span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>)</span>.obj</span> <span class="fn">s</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.whiskeringEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L572-L572">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskeringEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskeringEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskeringEquivalence">CategoryTheory.Limits.Cocones.whiskeringEquivalence</a> <span class="fn">e</span></span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskering">CategoryTheory.Limits.Cocones.whiskering</a> <span class="fn"><span class="fn">e</span>.functor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.whiskeringEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L573-L582">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskeringEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">whiskeringEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span>)</span></span></span></div></div><p>Whiskering by an equivalence gives an equivalence between categories of cones.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.whiskeringEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.equivalenceOfReindexing_functor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L588-L588">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.equivalenceOfReindexing_functor_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">equivalenceOfReindexing_functor_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.equivalenceOfReindexing">CategoryTheory.Limits.Cocones.equivalenceOfReindexing</a> <span class="fn">e</span> <span class="fn">α</span></span>)</span>.functor</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn"><span class="fn">α</span>.inv</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.whisker">CategoryTheory.Limits.Cocone.whisker</a> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.equivalenceOfReindexing"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L589-L590">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.equivalenceOfReindexing"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">equivalenceOfReindexing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">K</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">J</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.functor</span>.comp</span> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">G</span></span></span></div></div><p>The categories of cocones over <code>F</code> and <code>G</code> are equivalent if <code>F</code> and <code>G</code> are naturally isomorphic
(possibly after changing the indexing category by an equivalence).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.equivalenceOfReindexing">CategoryTheory.Limits.Cocones.equivalenceOfReindexing</a> <span class="fn">e</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.whiskeringEquivalence">CategoryTheory.Limits.Cocones.whiskeringEquivalence</a> <span class="fn">e</span></span>)</span>.trans</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence">CategoryTheory.Limits.Cocones.precomposeEquivalence</a> <span class="fn"><span class="fn">α</span>.symm</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.equivalenceOfReindexing" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.forget_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L597-L597">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">forget_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.forget">CategoryTheory.Limits.Cocones.forget</a> <span class="fn">F</span></span>)</span>.obj</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span>.pt</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.forget_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L597-L597">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">forget_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.forget">CategoryTheory.Limits.Cocones.forget</a> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.forget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L598-L600">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.forget"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span> <span class="fn">C</span></span></div></div><p>Forget the cocone structure and obtain just the cocone point.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.forget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.functoriality_obj_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L605-L605">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality_obj_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality_obj_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.obj</span> <span class="fn">A</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn"><span class="fn">A</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.functoriality_obj_ι_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L605-L605">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality_obj_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality_obj_ι_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(A : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.obj</span> <span class="fn">A</span></span>)</span>.ι</span>.app</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">G</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">A</span>.ι</span>.app</span> <span class="fn">j</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.functoriality_map_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L605-L605">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality_map_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.map</span> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">G</span>.map</span> <span class="fn"><span class="fn">f</span>.hom</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.functoriality"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L606-L614">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">G</span></span>)</span></span>)</span></span></div></div><p>A functor <code>G : C ⥤ D</code> sends cocones over <code>F</code> to cocones over <code>F ⋙ G</code> functorially.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.functoriality" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.functoriality_full"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L616-L619">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality_full"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality_full</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">G</span>.Full</span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">G</span>.Faithful</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.Full</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.functoriality_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L621-L623">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality_faithful"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functoriality_faithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">G</span>.Faithful</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.functorialityEquivalence_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L628-L628">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functorialityEquivalence_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence">CategoryTheory.Limits.Cocones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn">e</span></span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a>
        <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.unitIso</span>.app</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>)</span>.obj</span> <span class="fn">c</span></span>)</span>.1</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.functorialityEquivalence_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L628-L628">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functorialityEquivalence_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence">CategoryTheory.Limits.Cocones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn">e</span></span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn"><span class="fn">e</span>.functor</span></span>)</span> <span class="fn"><span class="fn">e</span>.inverse</span></span>)</span>.comp</span>
    <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence">CategoryTheory.Limits.Cocones.precomposeEquivalence</a>
        <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.associator</span> <span class="fn"><span class="fn">e</span>.functor</span> <span class="fn"><span class="fn">e</span>.inverse</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>             <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn">F</span> <span class="fn"><span class="fn"><span class="fn">e</span>.unitIso</span>.symm</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">F</span>.rightUnitor</span></span></span>)</span>.symm</span></span>)</span>.functor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.functorialityEquivalence_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L628-L628">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functorialityEquivalence_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence">CategoryTheory.Limits.Cocones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn">e</span></span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn"><span class="fn">e</span>.functor</span></span>)</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.counitIso</span>.app</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.functorialityEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L628-L628">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functorialityEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence">CategoryTheory.Limits.Cocones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn">e</span></span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">F</span> <span class="fn"><span class="fn">e</span>.functor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.functorialityEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L629-L635">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">functorialityEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn"><span class="fn">e</span>.functor</span></span>)</span></span></span></div></div><p>If <code>e : C ≌ D</code> is an equivalence of categories, then <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">functoriality</a> F e.functor</code> induces an
equivalence between cocones over <code>F</code> and cocones over <code>F ⋙ e.functor</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocones.functorialityEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocones.reflects_cocone_isomorphism"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L640-L647">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.reflects_cocone_isomorphism"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocones</span>.<span class="name">reflects_cocone_isomorphism</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.ReflectsIsomorphisms</span>]</span></span>
</span><span class="decl_args">
<span class="fn">(K : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">K</span> <span class="fn">F</span></span>)</span>.ReflectsIsomorphisms</span></div></div><p>If <code>F</code> reflects isomorphisms, then <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">Cocones.functoriality</a> F</code> reflects isomorphisms
as well.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapCone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L662-L662">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCone_π_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L662-L662">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone_π_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCone_π_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">c</span></span>)</span>.π</span>.app</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">H</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.π</span>.app</span> <span class="fn">j</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L663-L664">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">H</span></span>)</span></span></div></div><p>The image of a cone in C under a functor G : C ⥤ D is a cone in D.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">F</span> <span class="fn">H</span></span>)</span>.obj</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapCone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapCocone_ι_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L667-L667">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCocone_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCocone_ι_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">c</span></span>)</span>.ι</span>.app</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">H</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.ι</span>.app</span> <span class="fn">j</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCocone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L667-L667">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCocone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L668-L669">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCocone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">H</span></span>)</span></span></div></div><p>The image of a cocone in C under a functor G : C ⥤ D is a cocone in D.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">F</span> <span class="fn">H</span></span>)</span>.obj</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapCocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapConeMorphism"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L672-L673">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeMorphism</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">c</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">c'</span></span></span></div></div><p>Given a cone morphism <code>c ⟶ c'</code>, construct a cone morphism on the mapped cones functorially.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConeMorphism</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">F</span> <span class="fn">H</span></span>)</span>.map</span> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapConeMorphism" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconeMorphism"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L677-L678">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeMorphism"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeMorphism</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">c</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">c'</span></span></span></div></div><p>Given a cocone morphism <code>c ⟶ c'</code>, construct a cocone morphism on the mapped cocones
functorially.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconeMorphism</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">F</span> <span class="fn">H</span></span>)</span>.map</span> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapCoconeMorphism" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapConeInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L682-L683">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">H</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">H</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span></div></div><p>If <code>H</code> is an equivalence, we invert <code>H.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></code> and get a cone for <code>F</code> from a cone
for <code>F ⋙ H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConeInv</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence">CategoryTheory.Limits.Cones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn"><span class="fn">H</span>.asEquivalence</span></span>)</span>.inverse</span>.obj</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapConeInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapConeMapConeInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L686-L689">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeMapConeInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeMapConeInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">H</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">H</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapConeInv</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">c</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></code> is the left inverse to <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeInv">mapConeInv</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeMapConeInv">CategoryTheory.Functor.mapConeMapConeInv</a> <span class="fn">H</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence">CategoryTheory.Limits.Cones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn"><span class="fn">H</span>.asEquivalence</span></span>)</span>.counitIso</span>.app</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapConeMapConeInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapConeInvMapCone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L692-L694">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeInvMapCone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeInvMapCone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">H</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConeInv</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">c</span></span></div></div><p><code>MapCone</code> is the right inverse to <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeInv">mapConeInv</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeInvMapCone">CategoryTheory.Functor.mapConeInvMapCone</a> <span class="fn">H</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functorialityEquivalence">CategoryTheory.Limits.Cones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn"><span class="fn">H</span>.asEquivalence</span></span>)</span>.unitIso</span>.symm</span>.app</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapConeInvMapCone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconeInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L698-L699">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">H</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">H</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span></div></div><p>If <code>H</code> is an equivalence, we invert <code>H.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></code> and get a cone for <code>F</code> from a cone
for <code>F ⋙ H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconeInv</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence">CategoryTheory.Limits.Cocones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn"><span class="fn">H</span>.asEquivalence</span></span>)</span>.inverse</span>.obj</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapCoconeInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconeMapCoconeInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L702-L705">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeMapCoconeInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeMapCoconeInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">H</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">H</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconeInv</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">c</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCocone">mapCocone</a></code> is the left inverse to <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeInv">mapCoconeInv</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeMapCoconeInv">CategoryTheory.Functor.mapCoconeMapCoconeInv</a> <span class="fn">H</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence">CategoryTheory.Limits.Cocones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn"><span class="fn">H</span>.asEquivalence</span></span>)</span>.counitIso</span>.app</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapCoconeMapCoconeInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconeInvMapCocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L708-L710">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeInvMapCocone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeInvMapCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">H</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconeInv</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">c</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCocone">mapCocone</a></code> is the right inverse to <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeInv">mapCoconeInv</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeInvMapCocone">CategoryTheory.Functor.mapCoconeInvMapCocone</a> <span class="fn">H</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functorialityEquivalence">CategoryTheory.Limits.Cocones.functorialityEquivalence</a> <span class="fn">F</span> <span class="fn"><span class="fn">H</span>.asEquivalence</span></span>)</span>.unitIso</span>.symm</span>.app</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapCoconeInvMapCocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.functorialityCompPostcompose_inv_app_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L713-L713">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPostcompose_inv_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPostcompose_inv_app_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPostcompose">CategoryTheory.Functor.functorialityCompPostcompose</a> <span class="fn">α</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">α</span>.inv</span>.app</span> <span class="fn"><span class="fn">X</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.functorialityCompPostcompose_hom_app_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L713-L713">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPostcompose_hom_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPostcompose_hom_app_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPostcompose">CategoryTheory.Functor.functorialityCompPostcompose</a> <span class="fn">α</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">α</span>.hom</span>.app</span> <span class="fn"><span class="fn">X</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.functorialityCompPostcompose"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L714-L716">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPostcompose"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPostcompose</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">F</span> <span class="fn">H</span></span>)</span>.comp</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerLeft">CategoryTheory.whiskerLeft</a> <span class="fn">F</span> <span class="fn"><span class="fn">α</span>.hom</span></span>)</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">CategoryTheory.Limits.Cones.functoriality</a> <span class="fn">F</span> <span class="fn">H'</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">functoriality</a> F _ ⋙ <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">postcompose</a> (whisker_left F _)</code> simplifies to <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">functoriality</a> F _</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPostcompose">CategoryTheory.Functor.functorialityCompPostcompose</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">α</span>.app</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.functorialityCompPostcompose" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.postcomposeWhiskerLeftMapCone_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L722-L722">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.postcomposeWhiskerLeftMapCone_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">postcomposeWhiskerLeftMapCone_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.postcomposeWhiskerLeftMapCone">CategoryTheory.Functor.postcomposeWhiskerLeftMapCone</a> <span class="fn">α</span> <span class="fn">c</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">α</span>.hom</span>.app</span> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.postcomposeWhiskerLeftMapCone_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L722-L722">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.postcomposeWhiskerLeftMapCone_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">postcomposeWhiskerLeftMapCone_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.postcomposeWhiskerLeftMapCone">CategoryTheory.Functor.postcomposeWhiskerLeftMapCone</a> <span class="fn">α</span> <span class="fn">c</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">α</span>.inv</span>.app</span> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.postcomposeWhiskerLeftMapCone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L723-L725">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.postcomposeWhiskerLeftMapCone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">postcomposeWhiskerLeftMapCone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerLeft">CategoryTheory.whiskerLeft</a> <span class="fn">F</span> <span class="fn"><span class="fn">α</span>.hom</span></span>)</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">H'</span>.mapCone</span> <span class="fn">c</span></span></span></div></div><p>For <code>F : J ⥤ C</code>, given a cone <code>c : <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> F</code>, and a natural isomorphism <code>α : H ≅ H'</code> for functors
<code>H H' : C ⥤ D</code>, the postcomposition of the cone <code>H.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></code> using the isomorphism <code>α</code> is
isomorphic to the cone <code>H'.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.postcomposeWhiskerLeftMapCone">CategoryTheory.Functor.postcomposeWhiskerLeftMapCone</a> <span class="fn">α</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPostcompose">CategoryTheory.Functor.functorialityCompPostcompose</a> <span class="fn">α</span></span>)</span>.app</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.postcomposeWhiskerLeftMapCone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapConePostcompose_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L732-L732">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConePostcompose_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcompose_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConePostcompose</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapConePostcompose_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L732-L732">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConePostcompose_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcompose_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConePostcompose</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapConePostcompose"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L733-L736">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConePostcompose"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcompose</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">α</span></span>)</span>.obj</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerRight">CategoryTheory.whiskerRight</a> <span class="fn">α</span> <span class="fn">H</span></span>)</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">c</span></span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></code> commutes with <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">postcompose</a></code>. In particular, for <code>F : J ⥤ C</code>, given a cone <code>c : <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> F</code>, a
natural transformation <code>α : F ⟶ G</code> and a functor <code>H : C ⥤ D</code>, we have two obvious ways of producing
a cone over <code>G ⋙ H</code>, and they are both isomorphic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConePostcompose</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose">CategoryTheory.Limits.Cones.postcompose</a> <span class="fn">α</span></span>)</span>.obj</span> <span class="fn">c</span></span>)</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapConePostcompose" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L740-L740">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcomposeEquivalenceFunctor_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConePostcomposeEquivalenceFunctor</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L740-L740">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcomposeEquivalenceFunctor_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConePostcomposeEquivalenceFunctor</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L741-L744">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConePostcomposeEquivalenceFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence">CategoryTheory.Limits.Cones.postcomposeEquivalence</a> <span class="fn">α</span></span>)</span>.functor</span>.obj</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence">CategoryTheory.Limits.Cones.postcomposeEquivalence</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a> <span class="fn">α</span> <span class="fn">H</span></span>)</span></span>)</span>.functor</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">c</span></span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></code> commutes with <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence">postcomposeEquivalence</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConePostcomposeEquivalenceFunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcomposeEquivalence">CategoryTheory.Limits.Cones.postcomposeEquivalence</a> <span class="fn">α</span></span>)</span>.functor</span>.obj</span> <span class="fn">c</span></span>)</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.functorialityCompPrecompose_inv_app_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L747-L747">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPrecompose_inv_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPrecompose_inv_app_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPrecompose">CategoryTheory.Functor.functorialityCompPrecompose</a> <span class="fn">α</span></span>)</span>.inv</span>.app</span> <span class="fn">X</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">α</span>.inv</span>.app</span> <span class="fn"><span class="fn">X</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.functorialityCompPrecompose_hom_app_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L747-L747">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPrecompose_hom_app_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPrecompose_hom_app_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPrecompose">CategoryTheory.Functor.functorialityCompPrecompose</a> <span class="fn">α</span></span>)</span>.hom</span>.app</span> <span class="fn">X</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">α</span>.hom</span>.app</span> <span class="fn"><span class="fn">X</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.functorialityCompPrecompose"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L748-L751">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPrecompose"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">functorialityCompPrecompose</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">F</span> <span class="fn">H</span></span>)</span>.comp</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerLeft">CategoryTheory.whiskerLeft</a> <span class="fn">F</span> <span class="fn"><span class="fn">α</span>.inv</span></span>)</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.functoriality">CategoryTheory.Limits.Cocones.functoriality</a> <span class="fn">F</span> <span class="fn">H'</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">functoriality</a> F _ ⋙ <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">precompose</a> (whiskerLeft F _)</code> simplifies to <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.functoriality">functoriality</a> F _</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPrecompose">CategoryTheory.Functor.functorialityCompPrecompose</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">α</span>.app</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.functorialityCompPrecompose" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.precomposeWhiskerLeftMapCocone_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L758-L758">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.precomposeWhiskerLeftMapCocone_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">precomposeWhiskerLeftMapCocone_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.precomposeWhiskerLeftMapCocone">CategoryTheory.Functor.precomposeWhiskerLeftMapCocone</a> <span class="fn">α</span> <span class="fn">c</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">α</span>.hom</span>.app</span> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.precomposeWhiskerLeftMapCocone_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L758-L758">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.precomposeWhiskerLeftMapCocone_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">precomposeWhiskerLeftMapCocone_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.precomposeWhiskerLeftMapCocone">CategoryTheory.Functor.precomposeWhiskerLeftMapCocone</a> <span class="fn">α</span> <span class="fn">c</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">α</span>.inv</span>.app</span> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.precomposeWhiskerLeftMapCocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L759-L761">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.precomposeWhiskerLeftMapCocone"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">precomposeWhiskerLeftMapCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{H' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">H</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerLeft">CategoryTheory.whiskerLeft</a> <span class="fn">F</span> <span class="fn"><span class="fn">α</span>.inv</span></span>)</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">H'</span>.mapCocone</span> <span class="fn">c</span></span></span></div></div><p>For <code>F : J ⥤ C</code>, given a cocone <code>c : <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Cocone</a> F</code>, and a natural isomorphism <code>α : H ≅ H'</code> for functors
<code>H H' : C ⥤ D</code>, the precomposition of the cocone <code>H.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCocone">mapCocone</a></code> using the isomorphism <code>α</code> is
isomorphic to the cocone <code>H'.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCocone">mapCocone</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.precomposeWhiskerLeftMapCocone">CategoryTheory.Functor.precomposeWhiskerLeftMapCocone</a> <span class="fn">α</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.functorialityCompPrecompose">CategoryTheory.Functor.functorialityCompPrecompose</a> <span class="fn">α</span></span>)</span>.app</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.precomposeWhiskerLeftMapCocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconePrecompose_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L767-L767">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconePrecompose_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecompose_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">G</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconePrecompose</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconePrecompose_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L767-L767">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconePrecompose_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecompose_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">G</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconePrecompose</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconePrecompose"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L768-L771">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconePrecompose"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecompose</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">G</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">α</span></span>)</span>.obj</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerRight">CategoryTheory.whiskerRight</a> <span class="fn">α</span> <span class="fn">H</span></span>)</span></span>)</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">c</span></span>)</span></span></span></div></div><p><code>map_cocone</code> commutes with <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">precompose</a></code>. In particular, for <code>F : J ⥤ C</code>, given a cocone
<code>c : <a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Cocone</a> F</code>, a natural transformation <code>α : F ⟶ G</code> and a functor <code>H : C ⥤ D</code>, we have two obvious
ways of producing a cocone over <code>G ⋙ H</code>, and they are both isomorphic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconePrecompose</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose">CategoryTheory.Limits.Cocones.precompose</a> <span class="fn">α</span></span>)</span>.obj</span> <span class="fn">c</span></span>)</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapCoconePrecompose" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L775-L775">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecomposeEquivalenceFunctor_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">G</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconePrecomposeEquivalenceFunctor</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L775-L775">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecomposeEquivalenceFunctor_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">G</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconePrecomposeEquivalenceFunctor</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L776-L779">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconePrecomposeEquivalenceFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">G</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence">CategoryTheory.Limits.Cocones.precomposeEquivalence</a> <span class="fn">α</span></span>)</span>.functor</span>.obj</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence">CategoryTheory.Limits.Cocones.precomposeEquivalence</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a> <span class="fn">α</span> <span class="fn">H</span></span>)</span></span>)</span>.functor</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">c</span></span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCocone">mapCocone</a></code> commutes with <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence">precomposeEquivalence</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconePrecomposeEquivalenceFunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precomposeEquivalence">CategoryTheory.Limits.Cocones.precomposeEquivalence</a> <span class="fn">α</span></span>)</span>.functor</span>.obj</span> <span class="fn">c</span></span>)</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapConeWhisker_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L783-L783">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeWhisker_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeWhisker_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConeWhisker</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapConeWhisker_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L783-L783">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeWhisker_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeWhisker_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConeWhisker</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapConeWhisker"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L784-L785">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeWhisker"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeWhisker</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker">CategoryTheory.Limits.Cone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker">CategoryTheory.Limits.Cone.whisker</a> <span class="fn">E</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">c</span></span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></code> commutes with <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker">whisker</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">H</span>.mapConeWhisker</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCone</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker">CategoryTheory.Limits.Cone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span>)</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapConeWhisker" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconeWhisker_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L789-L789">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeWhisker_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeWhisker_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconeWhisker</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconeWhisker_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L789-L789">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeWhisker_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeWhisker_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconeWhisker</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.obj</span> <span class="fn"><span class="fn">c</span>.pt</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconeWhisker"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L790-L792">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeWhisker"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeWhisker</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{K : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">K</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">K</span> <span class="fn">J</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.whisker">CategoryTheory.Limits.Cocone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.whisker">CategoryTheory.Limits.Cocone.whisker</a> <span class="fn">E</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">c</span></span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCocone">mapCocone</a></code> commutes with <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker">whisker</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">H</span>.mapCoconeWhisker</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.mapCocone</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.whisker">CategoryTheory.Limits.Cocone.whisker</a> <span class="fn">E</span> <span class="fn">c</span></span>)</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapCoconeWhisker" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.op_π"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L805-L805">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">op_π</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.op</span>.π</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">CategoryTheory.NatTrans.op</a> <span class="fn"><span class="fn">c</span>.ι</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.op_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L805-L805">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">op_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.op</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.op"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L806-L808">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.op</span></span></div></div><p>Change a <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Cocone</a> F</code> into a <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">op</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.op</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">π</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">CategoryTheory.NatTrans.op</a> <span class="fn"><span class="fn">c</span>.ι</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocone.op" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cone.op_ι"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L811-L811">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.op_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">op_ι</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.op</span>.ι</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">CategoryTheory.NatTrans.op</a> <span class="fn"><span class="fn">c</span>.π</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.op_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L811-L811">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.op_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">op_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.op</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.op"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L812-L814">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.op"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.op</span></span></div></div><p>Change a <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> F</code> into a <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Cocone</a> F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">op</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.op</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">ι</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">CategoryTheory.NatTrans.op</a> <span class="fn"><span class="fn">c</span>.π</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cone.op" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.unop_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L817-L817">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.unop_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">unop_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.op</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.unop</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.unop_π"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L817-L817">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.unop_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">unop_π</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.op</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.unop</span>.π</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeOp">CategoryTheory.NatTrans.removeOp</a> <span class="fn"><span class="fn">c</span>.ι</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cocone.unop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L818-L820">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.unop"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cocone</span>.<span class="name">unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.op</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span></div></div><p>Change a <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Cocone</a> F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">op</a></code> into a <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.unop</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">π</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeOp">CategoryTheory.NatTrans.removeOp</a> <span class="fn"><span class="fn">c</span>.ι</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cocone.unop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.Cone.unop_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L823-L823">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.unop_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">unop_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.op</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.unop</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.unop_ι"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L823-L823">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.unop_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">unop_ι</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.op</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.unop</span>.ι</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeOp">CategoryTheory.NatTrans.removeOp</a> <span class="fn"><span class="fn">c</span>.π</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.Cone.unop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L824-L826">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.unop"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Cone</span>.<span class="name">unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.op</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span></div></div><p>Change a <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Cone</a> F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">op</a></code> into a <code><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Cocone</a> F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.unop</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">ι</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeOp">CategoryTheory.NatTrans.removeOp</a> <span class="fn"><span class="fn">c</span>.π</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.Cone.unop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coconeEquivalenceOpConeOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L834-L865">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.op</span></span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><p>The category of cocones on <code>F</code>
is equivalent to the opposite category of
the category of cones on the opposite of <code>F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coconeEquivalenceOpConeOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coconeEquivalenceOpConeOp_inverse_map_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp_inverse_map_hom"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_inverse_map_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.op</span></span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.op</span></span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp">CategoryTheory.Limits.coconeEquivalenceOpConeOp</a> <span class="fn">F</span></span>)</span>.inverse</span>.map</span> <span class="fn">f</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.unop</span>.hom</span>.unop</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeEquivalenceOpConeOp_inverse_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp_inverse_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_inverse_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.op</span></span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp">CategoryTheory.Limits.coconeEquivalenceOpConeOp</a> <span class="fn">F</span></span>)</span>.inverse</span>.obj</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">c</span></span>)</span>.unop</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeEquivalenceOpConeOp_functor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp_functor_obj"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_functor_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp">CategoryTheory.Limits.coconeEquivalenceOpConeOp</a> <span class="fn">F</span></span>)</span>.functor</span>.obj</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.op</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeEquivalenceOpConeOp_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp">CategoryTheory.Limits.coconeEquivalenceOpConeOp</a> <span class="fn">F</span></span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">c</span> : <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.op</span></span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.rec'">Opposite.rec'</a>
        <span class="fn">(<span class="fn">fun (<span class="fn">X</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.op</span></span>) =&gt;
          <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">X</span>.pt</span></span>)</span> <span class="fn">⋯</span></span>)</span>.op</span></span>)</span>
        <span class="fn">c</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeEquivalenceOpConeOp_functor_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp_functor_map"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_functor_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp">CategoryTheory.Limits.coconeEquivalenceOpConeOp</a> <span class="fn">F</span></span>)</span>.functor</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">Quiver.Hom.op</a> <span class="fn">{ <span class="fn">hom</span> := <span class="fn"><span class="fn"><span class="fn">f</span>.hom</span>.op</span>, <span class="fn">w</span> := <span class="fn">⋯</span> }</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeEquivalenceOpConeOp_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeEquivalenceOpConeOp_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeEquivalenceOpConeOp">CategoryTheory.Limits.coconeEquivalenceOpConeOp</a> <span class="fn">F</span></span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(<span class="fn">fun (<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>)</span>.obj</span> <span class="fn">c</span></span>)</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneOfCoconeLeftOp_π_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L876-L876">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeLeftOp_π_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeLeftOp_π_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.leftOp</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeLeftOp">CategoryTheory.Limits.coneOfCoconeLeftOp</a> <span class="fn">c</span></span>)</span>.π</span>.app</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.ι</span>.app</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span></span>)</span></span>)</span>.op</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneOfCoconeLeftOp_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L876-L876">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeLeftOp_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeLeftOp_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.leftOp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeLeftOp">CategoryTheory.Limits.coneOfCoconeLeftOp</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneOfCoconeLeftOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L877-L879">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeLeftOp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeLeftOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.leftOp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span></div></div><p>Change a cocone on <code>F.leftOp : Jᵒᵖ ⥤ C</code> to a cocone on <code>F : J ⥤ Cᵒᵖ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeLeftOp">CategoryTheory.Limits.coneOfCoconeLeftOp</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">π</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeLeftOp">CategoryTheory.NatTrans.removeLeftOp</a> <span class="fn"><span class="fn">c</span>.ι</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coneOfCoconeLeftOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coconeLeftOpOfCone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L882-L882">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeLeftOpOfCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeLeftOpOfCone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeLeftOpOfCone">CategoryTheory.Limits.coconeLeftOpOfCone</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeLeftOpOfCone_ι_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L882-L882">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeLeftOpOfCone_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeLeftOpOfCone_ι_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeLeftOpOfCone">CategoryTheory.Limits.coconeLeftOpOfCone</a> <span class="fn">c</span></span>)</span>.ι</span>.app</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.π</span>.app</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span></span>)</span></span>)</span>.unop</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeLeftOpOfCone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L883-L885">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeLeftOpOfCone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeLeftOpOfCone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.leftOp</span></span></div></div><p>Change a cone on <code>F : J ⥤ Cᵒᵖ</code> to a cocone on <code>F.leftOp : Jᵒᵖ ⥤ C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeLeftOpOfCone">CategoryTheory.Limits.coconeLeftOpOfCone</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">ι</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">CategoryTheory.NatTrans.leftOp</a> <span class="fn"><span class="fn">c</span>.π</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coconeLeftOpOfCone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coconeOfConeLeftOp_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L891-L891">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeLeftOp_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeLeftOp_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.leftOp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeLeftOp">CategoryTheory.Limits.coconeOfConeLeftOp</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeOfConeLeftOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L892-L894">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeLeftOp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeLeftOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.leftOp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span></div></div><p>Change a cone on <code>F.leftOp : Jᵒᵖ ⥤ C</code> to a cocone on <code>F : J ⥤ Cᵒᵖ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeLeftOp">CategoryTheory.Limits.coconeOfConeLeftOp</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">ι</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeLeftOp">CategoryTheory.NatTrans.removeLeftOp</a> <span class="fn"><span class="fn">c</span>.π</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coconeOfConeLeftOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coconeOfConeLeftOp_ι_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L897-L900">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeLeftOp_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeLeftOp_ι_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.leftOp</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeLeftOp">CategoryTheory.Limits.coconeOfConeLeftOp</a> <span class="fn">c</span></span>)</span>.ι</span>.app</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.π</span>.app</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">j</span></span>)</span></span>)</span>.op</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneLeftOpOfCocone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L903-L903">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneLeftOpOfCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneLeftOpOfCocone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneLeftOpOfCocone">CategoryTheory.Limits.coneLeftOpOfCocone</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneLeftOpOfCocone_π_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L903-L903">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneLeftOpOfCocone_π_app"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneLeftOpOfCocone_π_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneLeftOpOfCocone">CategoryTheory.Limits.coneLeftOpOfCocone</a> <span class="fn">c</span></span>)</span>.π</span>.app</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.ι</span>.app</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span></span>)</span></span>)</span>.unop</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneLeftOpOfCocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L904-L906">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneLeftOpOfCocone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneLeftOpOfCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.leftOp</span></span></div></div><p>Change a cocone on <code>F : J ⥤ Cᵒᵖ</code> to a cone on <code>F.leftOp : Jᵒᵖ ⥤ C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneLeftOpOfCocone">CategoryTheory.Limits.coneLeftOpOfCocone</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">π</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">CategoryTheory.NatTrans.leftOp</a> <span class="fn"><span class="fn">c</span>.ι</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coneLeftOpOfCocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coneOfCoconeRightOp_π"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L915-L915">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeRightOp_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeRightOp_π</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.rightOp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeRightOp">CategoryTheory.Limits.coneOfCoconeRightOp</a> <span class="fn">c</span></span>)</span>.π</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeRightOp">CategoryTheory.NatTrans.removeRightOp</a> <span class="fn"><span class="fn">c</span>.ι</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneOfCoconeRightOp_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L915-L915">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeRightOp_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeRightOp_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.rightOp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeRightOp">CategoryTheory.Limits.coneOfCoconeRightOp</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneOfCoconeRightOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L916-L918">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeRightOp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeRightOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.rightOp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span></div></div><p>Change a cocone on <code>F.rightOp : J ⥤ Cᵒᵖ</code> to a cone on <code>F : Jᵒᵖ ⥤ C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeRightOp">CategoryTheory.Limits.coneOfCoconeRightOp</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">π</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeRightOp">CategoryTheory.NatTrans.removeRightOp</a> <span class="fn"><span class="fn">c</span>.ι</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coneOfCoconeRightOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coconeRightOpOfCone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L921-L921">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeRightOpOfCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeRightOpOfCone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeRightOpOfCone">CategoryTheory.Limits.coconeRightOpOfCone</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeRightOpOfCone_ι"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L921-L921">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeRightOpOfCone_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeRightOpOfCone_ι</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeRightOpOfCone">CategoryTheory.Limits.coconeRightOpOfCone</a> <span class="fn">c</span></span>)</span>.ι</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">CategoryTheory.NatTrans.rightOp</a> <span class="fn"><span class="fn">c</span>.π</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeRightOpOfCone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L922-L924">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeRightOpOfCone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeRightOpOfCone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.rightOp</span></span></div></div><p>Change a cone on <code>F : Jᵒᵖ ⥤ C</code> to a cocone on <code>F.rightOp : Jᵒᵖ ⥤ C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeRightOpOfCone">CategoryTheory.Limits.coconeRightOpOfCone</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">ι</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">CategoryTheory.NatTrans.rightOp</a> <span class="fn"><span class="fn">c</span>.π</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coconeRightOpOfCone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coconeOfConeRightOp_ι"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L927-L927">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeRightOp_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeRightOp_ι</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.rightOp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeRightOp">CategoryTheory.Limits.coconeOfConeRightOp</a> <span class="fn">c</span></span>)</span>.ι</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeRightOp">CategoryTheory.NatTrans.removeRightOp</a> <span class="fn"><span class="fn">c</span>.π</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeOfConeRightOp_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L927-L927">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeRightOp_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeRightOp_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.rightOp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeRightOp">CategoryTheory.Limits.coconeOfConeRightOp</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeOfConeRightOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L928-L930">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeRightOp"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeRightOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.rightOp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span></div></div><p>Change a cone on <code>F.rightOp : J ⥤ Cᵒᵖ</code> to a cocone on <code>F : Jᵒᵖ ⥤ C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeRightOp">CategoryTheory.Limits.coconeOfConeRightOp</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">ι</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeRightOp">CategoryTheory.NatTrans.removeRightOp</a> <span class="fn"><span class="fn">c</span>.π</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coconeOfConeRightOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coneRightOpOfCocone_π"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L933-L933">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneRightOpOfCocone_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneRightOpOfCocone_π</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneRightOpOfCocone">CategoryTheory.Limits.coneRightOpOfCocone</a> <span class="fn">c</span></span>)</span>.π</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">CategoryTheory.NatTrans.rightOp</a> <span class="fn"><span class="fn">c</span>.ι</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneRightOpOfCocone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L933-L933">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneRightOpOfCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneRightOpOfCocone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneRightOpOfCocone">CategoryTheory.Limits.coneRightOpOfCocone</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneRightOpOfCocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L934-L936">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneRightOpOfCocone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneRightOpOfCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.rightOp</span></span></div></div><p>Change a cocone on <code>F : Jᵒᵖ ⥤ C</code> to a cone on <code>F.rightOp : J ⥤ Cᵒᵖ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneRightOpOfCocone">CategoryTheory.Limits.coneRightOpOfCocone</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">π</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">CategoryTheory.NatTrans.rightOp</a> <span class="fn"><span class="fn">c</span>.ι</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coneRightOpOfCocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coneOfCoconeUnop_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L945-L945">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeUnop_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeUnop_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.unop</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeUnop">CategoryTheory.Limits.coneOfCoconeUnop</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneOfCoconeUnop_π"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L945-L945">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeUnop_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeUnop_π</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.unop</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeUnop">CategoryTheory.Limits.coneOfCoconeUnop</a> <span class="fn">c</span></span>)</span>.π</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeUnop">CategoryTheory.NatTrans.removeUnop</a> <span class="fn"><span class="fn">c</span>.ι</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneOfCoconeUnop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L946-L948">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeUnop"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneOfCoconeUnop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.unop</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span></div></div><p>Change a cocone on <code>F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.unop">unop</a> : J ⥤ C</code> into a cone on <code>F : Jᵒᵖ ⥤ Cᵒᵖ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneOfCoconeUnop">CategoryTheory.Limits.coneOfCoconeUnop</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">π</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeUnop">CategoryTheory.NatTrans.removeUnop</a> <span class="fn"><span class="fn">c</span>.ι</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coneOfCoconeUnop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coconeUnopOfCone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L951-L951">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeUnopOfCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeUnopOfCone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeUnopOfCone">CategoryTheory.Limits.coconeUnopOfCone</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeUnopOfCone_ι"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L951-L951">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeUnopOfCone_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeUnopOfCone_ι</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeUnopOfCone">CategoryTheory.Limits.coconeUnopOfCone</a> <span class="fn">c</span></span>)</span>.ι</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">CategoryTheory.NatTrans.unop</a> <span class="fn"><span class="fn">c</span>.π</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeUnopOfCone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L952-L954">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeUnopOfCone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeUnopOfCone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn"><span class="fn">F</span>.unop</span></span></div></div><p>Change a cone on <code>F : Jᵒᵖ ⥤ Cᵒᵖ</code> into a cocone on <code>F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.unop">unop</a> : J ⥤ C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeUnopOfCone">CategoryTheory.Limits.coconeUnopOfCone</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">ι</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">CategoryTheory.NatTrans.unop</a> <span class="fn"><span class="fn">c</span>.π</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coconeUnopOfCone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coconeOfConeUnop_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L957-L957">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeUnop_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeUnop_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.unop</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeUnop">CategoryTheory.Limits.coconeOfConeUnop</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeOfConeUnop_ι"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L957-L957">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeUnop_ι"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeUnop_ι</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.unop</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeUnop">CategoryTheory.Limits.coconeOfConeUnop</a> <span class="fn">c</span></span>)</span>.ι</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeUnop">CategoryTheory.NatTrans.removeUnop</a> <span class="fn"><span class="fn">c</span>.π</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coconeOfConeUnop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L958-L960">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeUnop"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coconeOfConeUnop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.unop</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span></div></div><p>Change a cone on <code>F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.unop">unop</a> : J ⥤ C</code> into a cocone on <code>F : Jᵒᵖ ⥤ Cᵒᵖ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coconeOfConeUnop">CategoryTheory.Limits.coconeOfConeUnop</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">ι</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeUnop">CategoryTheory.NatTrans.removeUnop</a> <span class="fn"><span class="fn">c</span>.π</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coconeOfConeUnop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.coneUnopOfCocone_π"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L963-L963">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneUnopOfCocone_π"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneUnopOfCocone_π</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneUnopOfCocone">CategoryTheory.Limits.coneUnopOfCocone</a> <span class="fn">c</span></span>)</span>.π</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">CategoryTheory.NatTrans.unop</a> <span class="fn"><span class="fn">c</span>.ι</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneUnopOfCocone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L963-L963">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneUnopOfCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneUnopOfCocone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneUnopOfCocone">CategoryTheory.Limits.coneUnopOfCocone</a> <span class="fn">c</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.coneUnopOfCocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L964-L966">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneUnopOfCocone"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">coneUnopOfCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">J</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn"><span class="fn">F</span>.unop</span></span></div></div><p>Change a cocone on <code>F : Jᵒᵖ ⥤ Cᵒᵖ</code> into a cone on <code>F.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.unop">unop</a> : J ⥤ C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.coneUnopOfCocone">CategoryTheory.Limits.coneUnopOfCocone</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn"><span class="fn">c</span>.pt</span></span>, <span class="fn">π</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">CategoryTheory.NatTrans.unop</a> <span class="fn"><span class="fn">c</span>.ι</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Limits.coneUnopOfCocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapConeOp_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L984-L984">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeOp_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeOp_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeOp">CategoryTheory.Functor.mapConeOp</a> <span class="fn">G</span> <span class="fn">t</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn"><span class="fn">t</span>.pt</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapConeOp_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L984-L984">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeOp_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeOp_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeOp">CategoryTheory.Functor.mapConeOp</a> <span class="fn">G</span> <span class="fn">t</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn"><span class="fn">t</span>.pt</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapConeOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L985-L986">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapConeOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.mapCone</span> <span class="fn">t</span></span>)</span>.op</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.op</span>.mapCocone</span> <span class="fn"><span class="fn">t</span>.op</span></span></span></div></div><p>The opposite cocone of the image of a cone is the image of the opposite cocone.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapConeOp">CategoryTheory.Functor.mapConeOp</a> <span class="fn">G</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.ext">CategoryTheory.Limits.Cocones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.mapCone</span> <span class="fn">t</span></span>)</span>.op</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapConeOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconeOp_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L990-L990">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeOp_hom_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeOp_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeOp">CategoryTheory.Functor.mapCoconeOp</a> <span class="fn">G</span></span>)</span>.hom</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn"><span class="fn">t</span>.pt</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconeOp_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L990-L990">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeOp_inv_hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeOp_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeOp">CategoryTheory.Functor.mapCoconeOp</a> <span class="fn">G</span></span>)</span>.inv</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn"><span class="fn">t</span>.pt</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapCoconeOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Cones.lean#L991-L992">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapCoconeOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₄}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₄, u₄}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.mapCocone</span> <span class="fn">t</span></span>)</span>.op</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.op</span>.mapCone</span> <span class="fn"><span class="fn">t</span>.op</span></span></span></div></div><p>The opposite cone of the image of a cocone is the image of the opposite cone.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCoconeOp">CategoryTheory.Functor.mapCoconeOp</a> <span class="fn">G</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.ext">CategoryTheory.Limits.Cones.ext</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.mapCocone</span> <span class="fn">t</span></span>)</span>.op</span>.pt</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.mapCoconeOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>