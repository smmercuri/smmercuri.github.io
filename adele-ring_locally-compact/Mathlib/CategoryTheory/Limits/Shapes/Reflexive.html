<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Limits.Shapes.Reflexive</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Limits.Shapes.Reflexive";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">Shapes</span>.<span class="name">Reflexive</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Init.html">Init</a></li><li><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html">Mathlib.CategoryTheory.Limits.Shapes.Equalizers</a></li><li><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/KernelPair.html">Mathlib.CategoryTheory.Limits.Shapes.KernelPair</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Limits.Shapes.Reflexive" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsReflexivePair"><span class="name">CategoryTheory</span>.<span class="name">IsReflexivePair</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsReflexivePair.common_section'"><span class="name">CategoryTheory</span>.<span class="name">IsReflexivePair</span>.<span class="name">common_section'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsReflexivePair.common_section"><span class="name">CategoryTheory</span>.<span class="name">IsReflexivePair</span>.<span class="name">common_section</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCoreflexivePair"><span class="name">CategoryTheory</span>.<span class="name">IsCoreflexivePair</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCoreflexivePair.common_retraction'"><span class="name">CategoryTheory</span>.<span class="name">IsCoreflexivePair</span>.<span class="name">common_retraction'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCoreflexivePair.common_retraction"><span class="name">CategoryTheory</span>.<span class="name">IsCoreflexivePair</span>.<span class="name">common_retraction</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsReflexivePair.mk'"><span class="name">CategoryTheory</span>.<span class="name">IsReflexivePair</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCoreflexivePair.mk'"><span class="name">CategoryTheory</span>.<span class="name">IsCoreflexivePair</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.commonSection"><span class="name">CategoryTheory</span>.<span class="name">commonSection</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.section_comp_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">section_comp_left_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.section_comp_left"><span class="name">CategoryTheory</span>.<span class="name">section_comp_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.section_comp_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">section_comp_right_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.section_comp_right"><span class="name">CategoryTheory</span>.<span class="name">section_comp_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.commonRetraction"><span class="name">CategoryTheory</span>.<span class="name">commonRetraction</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.left_comp_retraction_assoc"><span class="name">CategoryTheory</span>.<span class="name">left_comp_retraction_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.left_comp_retraction"><span class="name">CategoryTheory</span>.<span class="name">left_comp_retraction</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.right_comp_retraction_assoc"><span class="name">CategoryTheory</span>.<span class="name">right_comp_retraction_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.right_comp_retraction"><span class="name">CategoryTheory</span>.<span class="name">right_comp_retraction</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsKernelPair.isReflexivePair"><span class="name">CategoryTheory</span>.<span class="name">IsKernelPair</span>.<span class="name">isReflexivePair</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsReflexivePair.swap"><span class="name">CategoryTheory</span>.<span class="name">IsReflexivePair</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCoreflexivePair.swap"><span class="name">CategoryTheory</span>.<span class="name">IsCoreflexivePair</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsReflexivePairMapAppCounitObj"><span class="name">CategoryTheory</span>.<span class="name">instIsReflexivePairMapAppCounitObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.HasReflexiveCoequalizers"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">HasReflexiveCoequalizers</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.HasReflexiveCoequalizers.has_coeq"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">HasReflexiveCoequalizers</span>.<span class="name">has_coeq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.HasCoreflexiveEqualizers"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">HasCoreflexiveEqualizers</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.HasCoreflexiveEqualizers.has_eq"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">HasCoreflexiveEqualizers</span>.<span class="name">has_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.hasCoequalizer_of_common_section"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">hasCoequalizer_of_common_section</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.hasEqualizer_of_common_retraction"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">hasEqualizer_of_common_retraction</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.hasReflexiveCoequalizers_of_hasCoequalizers"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">hasReflexiveCoequalizers_of_hasCoequalizers</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Limits.hasCoreflexiveEqualizers_of_hasEqualizers"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">hasCoreflexiveEqualizers_of_hasEqualizers</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Reflexive-coequalizers">Reflexive coequalizers <a class="hover-link" href="#Reflexive-coequalizers">#</a></h1><p>We define reflexive pairs as a pair of morphisms which have a common section. We say a category has
reflexive coequalizers if it has coequalizers of all reflexive pairs.
Reflexive coequalizers often enjoy nicer properties than general coequalizers, and feature heavily
in some versions of the monadicity theorem.</p><p>We also give some examples of reflexive pairs: for an adjunction <code>F ⊣ G</code> with counit <code>ε</code>, the pair
<code>(FGε_B, ε_FGB)</code> is reflexive. If a pair <code>f,g</code> is a kernel pair for some morphism, then it is
reflexive.</p><h1 class="markdown-heading" id="TODO">TODO <a class="hover-link" href="#TODO">#</a></h1><ul>
<li>If <code>C</code> has binary coproducts and reflexive coequalizers, then it has all coequalizers.</li>
<li>If <code>T</code> is a monad on cocomplete category <code>C</code>, then <code>Algebra T</code> is cocomplete iff it has reflexive
coequalizers.</li>
<li>If <code>C</code> is locally cartesian closed and has reflexive coequalizers, then it has images: in fact
regular epi (and hence strong epi) images.</li>
</ul></div><div class="decl" id="CategoryTheory.IsReflexivePair"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L40-L41">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair"><span class="name">CategoryTheory</span>.<span class="name">IsReflexivePair</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Prop</a></div></div><p>The pair <code>f g : A ⟶ B</code> is reflexive if there is a morphism <code>B ⟶ A</code> which is a section for both.</p><ul class="structure_fields" id="CategoryTheory.IsReflexivePair.mk"><li id="CategoryTheory.IsReflexivePair.common_section'" class="structure_field"><div class="structure_field_info">common_section' : <span class="fn">∃ (<span class="fn">s</span> : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">s</span> <span class="fn">f</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span> <a href="../../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">s</span> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span></span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsReflexivePair" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsReflexivePair.common_section'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L41-L41">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair.common_section'"><span class="name">CategoryTheory</span>.<span class="name">IsReflexivePair</span>.<span class="name">common_section'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">s</span> : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">s</span> <span class="fn">f</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span> <a href="../../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">s</span> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsReflexivePair.common_section"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L43-L44">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair.common_section"><span class="name">CategoryTheory</span>.<span class="name">IsReflexivePair</span>.<span class="name">common_section</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">s</span> : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">s</span> <span class="fn">f</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span> <a href="../../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">s</span> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCoreflexivePair"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L49-L50">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair"><span class="name">CategoryTheory</span>.<span class="name">IsCoreflexivePair</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Prop</a></div></div><p>The pair <code>f g : A ⟶ B</code> is coreflexive if there is a morphism <code>B ⟶ A</code> which is a retraction for both.</p><ul class="structure_fields" id="CategoryTheory.IsCoreflexivePair.mk"><li id="CategoryTheory.IsCoreflexivePair.common_retraction'" class="structure_field"><div class="structure_field_info">common_retraction' : <span class="fn">∃ (<span class="fn">s</span> : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span> <a href="../../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span></span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsCoreflexivePair" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCoreflexivePair.common_retraction'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L50-L50">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair.common_retraction'"><span class="name">CategoryTheory</span>.<span class="name">IsCoreflexivePair</span>.<span class="name">common_retraction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">s</span> : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span> <a href="../../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCoreflexivePair.common_retraction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L52-L53">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair.common_retraction"><span class="name">CategoryTheory</span>.<span class="name">IsCoreflexivePair</span>.<span class="name">common_retraction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">s</span> : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span> <a href="../../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsReflexivePair.mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L55-L57">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair.mk'"><span class="name">CategoryTheory</span>.<span class="name">IsReflexivePair</span>.<span class="name">mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(sf : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">s</span> <span class="fn">f</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(sg : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">s</span> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCoreflexivePair.mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L59-L61">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair.mk'"><span class="name">CategoryTheory</span>.<span class="name">IsCoreflexivePair</span>.<span class="name">mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(fs : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(gs : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.commonSection"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L64-L65">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonSection"><span class="name">CategoryTheory</span>.<span class="name">commonSection</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span></div></div><p>Get the common section for a reflexive pair.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonSection">CategoryTheory.commonSection</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.commonSection" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.section_comp_left_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L67-L67">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.section_comp_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">section_comp_left_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonSection">CategoryTheory.commonSection</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.section_comp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L68-L69">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.section_comp_left"><span class="name">CategoryTheory</span>.<span class="name">section_comp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonSection">CategoryTheory.commonSection</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">f</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.section_comp_right_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L71-L71">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.section_comp_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">section_comp_right_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonSection">CategoryTheory.commonSection</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.section_comp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L72-L73">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.section_comp_right"><span class="name">CategoryTheory</span>.<span class="name">section_comp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonSection">CategoryTheory.commonSection</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.commonRetraction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L76-L77">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonRetraction"><span class="name">CategoryTheory</span>.<span class="name">commonRetraction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span></div></div><p>Get the common retraction for a coreflexive pair.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonRetraction">CategoryTheory.commonRetraction</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.choose</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.commonRetraction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.left_comp_retraction_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L79-L79">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.left_comp_retraction_assoc"><span class="name">CategoryTheory</span>.<span class="name">left_comp_retraction_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonRetraction">CategoryTheory.commonRetraction</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.left_comp_retraction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L80-L82">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.left_comp_retraction"><span class="name">CategoryTheory</span>.<span class="name">left_comp_retraction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonRetraction">CategoryTheory.commonRetraction</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.right_comp_retraction_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L84-L84">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.right_comp_retraction_assoc"><span class="name">CategoryTheory</span>.<span class="name">right_comp_retraction_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonRetraction">CategoryTheory.commonRetraction</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.right_comp_retraction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L85-L87">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.right_comp_retraction"><span class="name">CategoryTheory</span>.<span class="name">right_comp_retraction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.commonRetraction">CategoryTheory.commonRetraction</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsKernelPair.isReflexivePair"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L90-L92">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsKernelPair.isReflexivePair"><span class="name">CategoryTheory</span>.<span class="name">IsKernelPair</span>.<span class="name">isReflexivePair</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">R</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">R</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/KernelPair.html#CategoryTheory.IsKernelPair">CategoryTheory.IsKernelPair</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span></div></div><p>If <code>f,g</code> is a kernel pair for some morphism <code>q</code>, then it is reflexive.</p></div></div><div class="decl" id="CategoryTheory.IsReflexivePair.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L96-L97">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair.swap"><span class="name">CategoryTheory</span>.<span class="name">IsReflexivePair</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">g</span> <span class="fn">f</span></span></div></div><p>If <code>f,g</code> is reflexive, then <code>g,f</code> is reflexive.</p></div></div><div class="decl" id="CategoryTheory.IsCoreflexivePair.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L101-L102">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair.swap"><span class="name">CategoryTheory</span>.<span class="name">IsCoreflexivePair</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">g</span> <span class="fn">f</span></span></div></div><p>If <code>f,g</code> is coreflexive, then <code>g,f</code> is coreflexive.</p></div></div><div class="decl" id="CategoryTheory.instIsReflexivePairMapAppCounitObj"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L107-L113">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.instIsReflexivePairMapAppCounitObj"><span class="name">CategoryTheory</span>.<span class="name">instIsReflexivePairMapAppCounitObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{G : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(adj : <span class="fn"><span class="fn">F</span> <a href="../../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(B : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.map</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">adj</span>.counit</span>.app</span> <span class="fn">B</span></span>)</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">adj</span>.counit</span>.app</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">B</span></span>)</span></span>)</span></span>)</span></span></div></div><p>For an adjunction <code>F ⊣ G</code> with counit <code>ε</code>, the pair <code>(FGε_B, ε_FGB)</code> is reflexive.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.HasReflexiveCoequalizers"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L120-L121">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.HasReflexiveCoequalizers"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">HasReflexiveCoequalizers</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Prop</a></div></div><p><code>C</code> has reflexive coequalizers if it has coequalizers for every reflexive pair.</p><ul class="structure_fields" id="CategoryTheory.Limits.HasReflexiveCoequalizers.mk"><li id="CategoryTheory.Limits.HasReflexiveCoequalizers.has_coeq" class="structure_field"><div class="structure_field_info">has_coeq : <span class="fn">∀ ⦃<span class="fn">A </span><span class="fn">B</span> : <span class="fn">C</span>⦄ (<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>) [<span class="fn">inst</span> : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>], <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer">CategoryTheory.Limits.HasCoequalizer</a> <span class="fn">f</span> <span class="fn">g</span></span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Limits.HasReflexiveCoequalizers" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.HasReflexiveCoequalizers.has_coeq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L121-L121">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.HasReflexiveCoequalizers.has_coeq"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">HasReflexiveCoequalizers</span>.<span class="name">has_coeq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.HasReflexiveCoequalizers">CategoryTheory.Limits.HasReflexiveCoequalizers</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃A : <span class="fn">C</span>⦄</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃B : <span class="fn">C</span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsReflexivePair">CategoryTheory.IsReflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer">CategoryTheory.Limits.HasCoequalizer</a> <span class="fn">f</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.HasCoreflexiveEqualizers"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L124-L125">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.HasCoreflexiveEqualizers"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">HasCoreflexiveEqualizers</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Prop</a></div></div><p><code>C</code> has coreflexive equalizers if it has equalizers for every coreflexive pair.</p><ul class="structure_fields" id="CategoryTheory.Limits.HasCoreflexiveEqualizers.mk"><li id="CategoryTheory.Limits.HasCoreflexiveEqualizers.has_eq" class="structure_field"><div class="structure_field_info">has_eq : <span class="fn">∀ ⦃<span class="fn">A </span><span class="fn">B</span> : <span class="fn">C</span>⦄ (<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>) [<span class="fn">inst</span> : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>], <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer">CategoryTheory.Limits.HasEqualizer</a> <span class="fn">f</span> <span class="fn">g</span></span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Limits.HasCoreflexiveEqualizers" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.HasCoreflexiveEqualizers.has_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L125-L125">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.HasCoreflexiveEqualizers.has_eq"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">HasCoreflexiveEqualizers</span>.<span class="name">has_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.HasCoreflexiveEqualizers">CategoryTheory.Limits.HasCoreflexiveEqualizers</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃A : <span class="fn">C</span>⦄</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃B : <span class="fn">C</span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.IsCoreflexivePair">CategoryTheory.IsCoreflexivePair</a> <span class="fn">f</span> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer">CategoryTheory.Limits.HasEqualizer</a> <span class="fn">f</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.hasCoequalizer_of_common_section"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L131-L134">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.hasCoequalizer_of_common_section"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">hasCoequalizer_of_common_section</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.HasReflexiveCoequalizers">CategoryTheory.Limits.HasReflexiveCoequalizers</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(rf : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">r</span> <span class="fn">f</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(rg : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">r</span> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">B</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer">CategoryTheory.Limits.HasCoequalizer</a> <span class="fn">f</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.hasEqualizer_of_common_retraction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L136-L139">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.hasEqualizer_of_common_retraction"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">hasEqualizer_of_common_retraction</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.HasCoreflexiveEqualizers">CategoryTheory.Limits.HasCoreflexiveEqualizers</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">A</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">B</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(fr : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">r</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(gr : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">r</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">A</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer">CategoryTheory.Limits.HasEqualizer</a> <span class="fn">f</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Limits.hasReflexiveCoequalizers_of_hasCoequalizers"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L142-L143">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.hasReflexiveCoequalizers_of_hasCoequalizers"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">hasReflexiveCoequalizers_of_hasCoequalizers</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizers">CategoryTheory.Limits.HasCoequalizers</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.HasReflexiveCoequalizers">CategoryTheory.Limits.HasReflexiveCoequalizers</a> <span class="fn">C</span></span></div></div><p>If <code>C</code> has coequalizers, then it has reflexive coequalizers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Limits.hasCoreflexiveEqualizers_of_hasEqualizers"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean#L146-L147">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.hasCoreflexiveEqualizers_of_hasEqualizers"><span class="name">CategoryTheory</span>.<span class="name">Limits</span>.<span class="name">hasCoreflexiveEqualizers_of_hasEqualizers</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizers">CategoryTheory.Limits.HasEqualizers</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Shapes/Reflexive.html#CategoryTheory.Limits.HasCoreflexiveEqualizers">CategoryTheory.Limits.HasCoreflexiveEqualizers</a> <span class="fn">C</span></span></div></div><p>If <code>C</code> has equalizers, then it has coreflexive equalizers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>