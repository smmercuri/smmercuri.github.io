<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.SmallObject.Iteration</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.SmallObject.Iteration";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">SmallObject</span>.<span class="name">Iteration</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Order/IsWellOrderLimitElement.html">Mathlib.Order.IsWellOrderLimitElement</a></li><li><a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html">Mathlib.CategoryTheory.Category.Preorder</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html">Mathlib.CategoryTheory.Limits.IsLimit</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.SmallObject.Iteration" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.mapSucc'"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">mapSucc'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.restrictionLT"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">restrictionLT</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.restrictionLT_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">restrictionLT_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.restrictionLT_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">restrictionLT_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.coconeOfLE_Œπ_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">coconeOfLE_Œπ_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.coconeOfLE_pt"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">coconeOfLE_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.coconeOfLE"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">coconeOfLE</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.mapSucc'_eq"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">mapSucc'_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.mapSucc"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">mapSucc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.mapSucc_eq"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">mapSucc_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.Hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.Hom.natTrans_app_zero"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">natTrans_app_zero</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.Hom.natTrans_app_succ"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">natTrans_app_succ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.Hom.natTrans_app_zero_assoc"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">natTrans_app_zero_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.Hom.id_natTrans"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">id_natTrans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.Hom.id"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.Hom.ext'"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">ext'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.Hom.comp_natTrans"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">comp_natTrans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.Hom.comp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.Hom.instCategory"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">instCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.Iteration.Hom.instSubsingletonHom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">instSubsingletonHom</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Transfinite-iterations-of-a-functor">Transfinite iterations of a functor <a class="hover-link" href="#Transfinite-iterations-of-a-functor">#</a></h1><p>In this file, given a functor <code>Œ¶ : C ‚•§ C</code> and a natural transformation
<code>Œµ : ùü≠ C ‚ü∂ Œ¶</code>, we shall define the transfinite iterations of <code>Œ¶</code> (TODO).</p><p>Given <code>j : J</code> where <code>J</code> is a well ordered set, we first introduce
a category <code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">Iteration</a> Œµ j</code>. An object in this category consists of
a functor <code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.F">F</a> : { i // i ‚â§ j } ‚•§ C ‚•§ C</code> equipped with the data
which makes it the <code>i</code>th-iteration of <code>Œ¶</code> for all <code>i</code> such that <code>i ‚â§ j</code>.
Under suitable assumptions on <code>C</code>, we shall show that this category
<code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">Iteration</a> Œµ j</code> is equivalent to the punctual category (TODO).
We shall study morphisms in this category, showing first that
there is at most one morphism between two morphisms (done), and secondly,
that there does always exist a unique morphism between
two objects (TODO). Then, we shall show the existence of
an object (TODO). In these proofs, which are all done using
transfinite induction, we have to treat three cases separately:</p><ul>
<li>the case <code>j = ‚ä•</code>;</li>
<li>the case <code>j</code> is a successor;</li>
<li>the case <code>j</code> is a limit element.</li>
</ul></div><div class="decl" id="CategoryTheory.Functor.Iteration.mapSucc'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L50-L52">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.mapSucc'"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">mapSucc'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">{ <span class="fn">i</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span> }</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">‚ü®<span class="fn">i</span>, <span class="fn">‚ãØ</span>‚ü©</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">‚ü®<span class="fn"><a href="../../.././Mathlib/Order/IsWellOrderLimitElement.html#wellOrderSucc">wellOrderSucc</a> <span class="fn">i</span></span>, <span class="fn">‚ãØ</span>‚ü©</span></span></span></div></div><p>The map <code>F.obj ‚ü®i, _‚ü© ‚ü∂ F.obj ‚ü®wellOrderSucc i, _‚ü©</code> when <code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.F">F</a> : { i // i ‚â§ j } ‚•§ C</code>
and <code>i : J</code> is such that <code>i &lt; j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.mapSucc'">CategoryTheory.Functor.Iteration.mapSucc'</a> <span class="fn">F</span> <span class="fn">i</span> <span class="fn">hi</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">CategoryTheory.homOfLE</a> <span class="fn">‚ãØ</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.Iteration.mapSucc'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.restrictionLT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L58-L59">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.restrictionLT"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">restrictionLT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">{ <span class="fn">i</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span> }</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">{ <span class="fn">k</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">k</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">i</span></span> }</span> <span class="fn">C</span></span></div></div><p>The functor <code>{ k // k &lt; i } ‚•§ C</code> obtained by &quot;restriction&quot; of <code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.F">F</a> : { i // i ‚â§ j } ‚•§ C</code>
when <code>i ‚â§ j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.restrictionLT">CategoryTheory.Functor.Iteration.restrictionLT</a> <span class="fn">F</span> <span class="fn">hi</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">‚ãØ</span>.functor</span>.comp</span> <span class="fn">F</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.Iteration.restrictionLT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.restrictionLT_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L62-L63">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.restrictionLT_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">restrictionLT_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">{ <span class="fn">i</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span> }</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(k : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(hk : <span class="fn"><span class="fn">k</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.restrictionLT">CategoryTheory.Functor.Iteration.restrictionLT</a> <span class="fn">F</span> <span class="fn">hi</span></span>)</span>.obj</span> <span class="fn">‚ü®<span class="fn">k</span>, <span class="fn">hk</span>‚ü©</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">‚ü®<span class="fn">k</span>, <span class="fn">‚ãØ</span>‚ü©</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.restrictionLT_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L66-L67">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.restrictionLT_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">restrictionLT_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">{ <span class="fn">i</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span> }</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{k‚ÇÅ : <span class="fn">{ <span class="fn">k</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">k</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">i</span></span> }</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k‚ÇÇ : <span class="fn">{ <span class="fn">k</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">k</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">i</span></span> }</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(œÜ : <span class="fn"><span class="fn">k‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.restrictionLT">CategoryTheory.Functor.Iteration.restrictionLT</a> <span class="fn">F</span> <span class="fn">hi</span></span>)</span>.map</span> <span class="fn">œÜ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">CategoryTheory.homOfLE</a> <span class="fn">‚ãØ</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.coconeOfLE_Œπ_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L71-L71">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.coconeOfLE_Œπ_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">coconeOfLE_Œπ_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">{ <span class="fn">i</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span> }</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">{ <span class="fn">k</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">k</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">i</span></span> }</span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.coconeOfLE">CategoryTheory.Functor.Iteration.coconeOfLE</a> <span class="fn">F</span> <span class="fn">hi</span></span>)</span>.Œπ</span>.app</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn">match <span class="fn">x</span> with
    | <span class="fn">‚ü®<span class="fn">k</span>, <span class="fn">hk</span>‚ü©</span> =&gt; <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">CategoryTheory.homOfLE</a> <span class="fn">‚ãØ</span></span>)</span></span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.coconeOfLE_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L71-L71">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.coconeOfLE_pt"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">coconeOfLE_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">{ <span class="fn">i</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span> }</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.coconeOfLE">CategoryTheory.Functor.Iteration.coconeOfLE</a> <span class="fn">F</span> <span class="fn">hi</span></span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">‚ü®<span class="fn">i</span>, <span class="fn">hi</span>‚ü©</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.coconeOfLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L72-L77">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.coconeOfLE"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">coconeOfLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">{ <span class="fn">i</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span> }</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.restrictionLT">CategoryTheory.Functor.Iteration.restrictionLT</a> <span class="fn">F</span> <span class="fn">hi</span></span>)</span></span></div></div><p>Given <code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.F">F</a> : { i // i ‚â§ j } ‚•§ C</code>, <code>i : J</code> such that <code>hi : i ‚â§ j</code>, this is the
cocone consisting of all maps <code>F.obj ‚ü®k, hk‚ü© ‚ü∂ F.obj ‚ü®i, hi‚ü©</code> for <code>k : J</code> such that <code>k &lt; i</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Functor.Iteration.coconeOfLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.Iteration"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L86-L101">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">J</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max (max u u_1) u_2)</div></div><p>The category of <code>j</code>th iterations of a functor <code>Œ¶</code> equipped with a natural
transformation <code>Œµ : ùü≠ C ‚ü∂ Œ¶</code>. An object consists of the data of all iterations
of <code>Œ¶</code> for <code>i : J</code> such that <code>i ‚â§ j</code> (this is the field <code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.F">F</a></code>). Such objects are
equipped with data and properties which characterizes the iterations up to a unique
isomorphism for the three types of elements: <code>‚ä•</code>, successors, limit elements.</p><ul class="structure_fields" id="CategoryTheory.Functor.Iteration.mk"><li id="CategoryTheory.Functor.Iteration.F" class="structure_field"><div class="structure_field_info">F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">{ <span class="fn">i</span> : <span class="fn">J</span> // <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span> }</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>)</span></span></div><div class="structure_field_doc"><p>The data of all <code>i</code>th iterations for <code>i : J</code> such that <code>i ‚â§ j</code>.</p></div></li><li id="CategoryTheory.Functor.Iteration.isoZero" class="structure_field"><div class="structure_field_info">isoZero : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.F</span>.obj</span> <span class="fn">‚ü®<a href="../../.././Mathlib/Order/Notation.html#Bot.bot">‚ä•</a>, <span class="fn">‚ãØ</span>‚ü©</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span></span></div><div class="structure_field_doc"><p>The zeroth iteration is the identity functor.</p></div></li><li id="CategoryTheory.Functor.Iteration.isoSucc" class="structure_field"><div class="structure_field_info">isoSucc : <span class="fn">(<span class="fn">i</span> : <span class="fn">J</span>) ‚Üí <span class="fn">(<span class="fn">hi</span> : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span></span>) ‚Üí <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.F</span>.obj</span> <span class="fn">‚ü®<span class="fn"><a href="../../.././Mathlib/Order/IsWellOrderLimitElement.html#wellOrderSucc">wellOrderSucc</a> <span class="fn">i</span></span>, <span class="fn">‚ãØ</span>‚ü©</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.F</span>.obj</span> <span class="fn">‚ü®<span class="fn">i</span>, <span class="fn">‚ãØ</span>‚ü©</span></span>)</span>.comp</span> <span class="fn">Œ¶</span></span></span></span></span></div><div class="structure_field_doc"><p>The iteration on a successor element is obtained by composition of
the previous iteration with <code>Œ¶</code>.</p></div></li><li id="CategoryTheory.Functor.Iteration.mapSucc'_eq" class="structure_field"><div class="structure_field_info">mapSucc'_eq : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">J</span>) (<span class="fn">hi</span> : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span></span>),
  <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.mapSucc'">CategoryTheory.Functor.Iteration.mapSucc'</a> <span class="fn"><span class="fn">self</span>.F</span> <span class="fn">i</span> <span class="fn">hi</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerLeft">CategoryTheory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.F</span>.obj</span> <span class="fn">‚ü®<span class="fn">i</span>, <span class="fn">‚ãØ</span>‚ü©</span></span>)</span> <span class="fn">Œµ</span></span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.isoSucc</span> <span class="fn">i</span> <span class="fn">hi</span></span>)</span>.inv</span></span></span></span></div><div class="structure_field_doc"><p>The natural map from an iteration to its successor is induced by <code>Œµ</code>.</p></div></li><li id="CategoryTheory.Functor.Iteration.isColimit" class="structure_field"><div class="structure_field_info">isColimit : <span class="fn">(<span class="fn">i</span> : <span class="fn">J</span>) ‚Üí
  <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/Order/IsWellOrderLimitElement.html#IsWellOrderLimitElement">IsWellOrderLimitElement</a> <span class="fn">i</span></span>] ‚Üí
    <span class="fn">(<span class="fn">hi</span> : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn">j</span></span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.coconeOfLE">CategoryTheory.Functor.Iteration.coconeOfLE</a> <span class="fn"><span class="fn">self</span>.F</span> <span class="fn">hi</span></span>)</span></span></span></span></span></div><div class="structure_field_doc"><p>If <code>i</code> is a limit element, the <code>i</code>th iteration is the colimit
of <code>k</code>th iterations for <code>k &lt; i</code>.</p></div></li></ul><details id="instances-for-list-CategoryTheory.Functor.Iteration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.mapSucc'_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L96-L96">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.mapSucc'_eq"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">mapSucc'_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.mapSucc'">CategoryTheory.Functor.Iteration.mapSucc'</a> <span class="fn"><span class="fn">self</span>.F</span> <span class="fn">i</span> <span class="fn">hi</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerLeft">CategoryTheory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.F</span>.obj</span> <span class="fn">‚ü®<span class="fn">i</span>, <span class="fn">‚ãØ</span>‚ü©</span></span>)</span> <span class="fn">Œµ</span></span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.isoSucc</span> <span class="fn">i</span> <span class="fn">hi</span></span>)</span>.inv</span></span></span></div></div><p>The natural map from an iteration to its successor is induced by <code>Œµ</code>.</p></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.mapSucc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L114-L116">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.mapSucc"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">mapSucc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(iter : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">iter</span>.F</span>.obj</span> <span class="fn">‚ü®<span class="fn">i</span>, <span class="fn">‚ãØ</span>‚ü©</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">iter</span>.F</span>.obj</span> <span class="fn">‚ü®<span class="fn"><a href="../../.././Mathlib/Order/IsWellOrderLimitElement.html#wellOrderSucc">wellOrderSucc</a> <span class="fn">i</span></span>, <span class="fn">‚ãØ</span>‚ü©</span></span></span></div></div><p>For <code>iter : Œ¶.Iteration.Œµ j</code>, this is the map
<code>iter.F.obj ‚ü®i, _‚ü© ‚ü∂ iter.F.obj ‚ü®wellOrderSucc i, _‚ü©</code> if <code>i : J</code> is such that <code>i &lt; j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">iter</span>.mapSucc</span> <span class="fn">i</span> <span class="fn">hi</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.mapSucc'">CategoryTheory.Functor.Iteration.mapSucc'</a> <span class="fn"><span class="fn">iter</span>.F</span> <span class="fn">i</span> <span class="fn">hi</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.Iteration.mapSucc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.mapSucc_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L118-L120">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.mapSucc_eq"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">mapSucc_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(iter : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">iter</span>.mapSucc</span> <span class="fn">i</span> <span class="fn">hi</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerLeft">CategoryTheory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">iter</span>.F</span>.obj</span> <span class="fn">‚ü®<span class="fn">i</span>, <span class="fn">‚ãØ</span>‚ü©</span></span>)</span> <span class="fn">Œµ</span></span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">iter</span>.isoSucc</span> <span class="fn">i</span> <span class="fn">hi</span></span>)</span>.inv</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.Hom"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L131-L138">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(iter‚ÇÅ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(iter‚ÇÇ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max (max u u_1) u_2)</div></div><p>A morphism between two objects <code>iter‚ÇÅ</code> and <code>iter‚ÇÇ</code> in the
category <code>Œ¶.<a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">Iteration</a> Œµ j</code> of <code>j</code>th iterations of a functor <code>Œ¶</code>
equipped with a natural transformation <code>Œµ : ùü≠ C ‚ü∂ Œ¶</code> consists of a natural
transformation <code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.natTrans">natTrans</a> : iter‚ÇÅ.<a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.F">F</a> ‚ü∂ iter‚ÇÇ.<a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.F">F</a></code> which is compatible with the
isomorphisms <code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.isoZero">isoZero</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.isoSucc">isoSucc</a></code>.</p><ul class="structure_fields" id="CategoryTheory.Functor.Iteration.Hom.mk"><li id="CategoryTheory.Functor.Iteration.Hom.natTrans" class="structure_field"><div class="structure_field_info">natTrans : <span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><span class="fn">iter‚ÇÇ</span>.F</span></span></div><div class="structure_field_doc"><p>A natural transformation <code>iter‚ÇÅ.<a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.F">F</a> ‚ü∂ iter‚ÇÇ.<a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.F">F</a></code></p></div></li><li id="CategoryTheory.Functor.Iteration.Hom.natTrans_app_zero" class="structure_field"><div class="structure_field_info">natTrans_app_zero : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.natTrans</span>.app</span> <span class="fn">‚ü®<a href="../../.././Mathlib/Order/Notation.html#Bot.bot">‚ä•</a>, <span class="fn">‚ãØ</span>‚ü©</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.isoZero</span>.hom</span> <span class="fn"><span class="fn"><span class="fn">iter‚ÇÇ</span>.isoZero</span>.inv</span></span></span></div></li><li id="CategoryTheory.Functor.Iteration.Hom.natTrans_app_succ" class="structure_field"><div class="structure_field_info">natTrans_app_succ : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">J</span>) (<span class="fn">hi</span> : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.natTrans</span>.app</span> <span class="fn">‚ü®<span class="fn"><a href="../../.././Mathlib/Order/IsWellOrderLimitElement.html#wellOrderSucc">wellOrderSucc</a> <span class="fn">i</span></span>, <span class="fn">‚ãØ</span>‚ü©</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.isoSucc</span> <span class="fn">i</span> <span class="fn">hi</span></span>)</span>.hom</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerRight">CategoryTheory.whiskerRight</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.natTrans</span>.app</span> <span class="fn">‚ü®<span class="fn">i</span>, <span class="fn">‚ãØ</span>‚ü©</span></span>)</span> <span class="fn">Œ¶</span></span>)</span>
        <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">iter‚ÇÇ</span>.isoSucc</span> <span class="fn">i</span> <span class="fn">hi</span></span>)</span>.inv</span></span>)</span></span></span></span></div></li></ul><details id="instances-for-list-CategoryTheory.Functor.Iteration.Hom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.Hom.natTrans_app_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L134-L134">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.natTrans_app_zero"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">natTrans_app_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÅ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÇ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.Hom</span> <span class="fn">iter‚ÇÇ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.natTrans</span>.app</span> <span class="fn">‚ü®<a href="../../.././Mathlib/Order/Notation.html#Bot.bot">‚ä•</a>, <span class="fn">‚ãØ</span>‚ü©</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.isoZero</span>.hom</span> <span class="fn"><span class="fn"><span class="fn">iter‚ÇÇ</span>.isoZero</span>.inv</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.Hom.natTrans_app_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L136-L136">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.natTrans_app_succ"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">natTrans_app_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÅ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÇ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.Hom</span> <span class="fn">iter‚ÇÇ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn">J</span>)</span></span>
<span class="decl_args">
<span class="fn">(hi : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.natTrans</span>.app</span> <span class="fn">‚ü®<span class="fn"><a href="../../.././Mathlib/Order/IsWellOrderLimitElement.html#wellOrderSucc">wellOrderSucc</a> <span class="fn">i</span></span>, <span class="fn">‚ãØ</span>‚ü©</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.isoSucc</span> <span class="fn">i</span> <span class="fn">hi</span></span>)</span>.hom</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskerRight">CategoryTheory.whiskerRight</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.natTrans</span>.app</span> <span class="fn">‚ü®<span class="fn">i</span>, <span class="fn">‚ãØ</span>‚ü©</span></span>)</span> <span class="fn">Œ¶</span></span>)</span>
      <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">iter‚ÇÇ</span>.isoSucc</span> <span class="fn">i</span> <span class="fn">hi</span></span>)</span>.inv</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.Hom.natTrans_app_zero_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L142-L142">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.natTrans_app_zero_assoc"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">natTrans_app_zero_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÅ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÇ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.Hom</span> <span class="fn">iter‚ÇÇ</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">iter‚ÇÇ</span>.F</span>.obj</span> <span class="fn">‚ü®<a href="../../.././Mathlib/Order/Notation.html#Bot.bot">‚ä•</a>, <span class="fn">‚ãØ</span>‚ü©</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.natTrans</span>.app</span> <span class="fn">‚ü®<a href="../../.././Mathlib/Order/Notation.html#Bot.bot">‚ä•</a>, <span class="fn">‚ãØ</span>‚ü©</span></span>)</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.isoZero</span>.hom</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">iter‚ÇÇ</span>.isoZero</span>.inv</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.Hom.id_natTrans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L145-L145">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.id_natTrans"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">id_natTrans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(iter‚ÇÅ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.id">CategoryTheory.Functor.Iteration.Hom.id</a> <span class="fn">iter‚ÇÅ</span></span>)</span>.natTrans</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">iter‚ÇÅ</span>.F</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.Hom.id"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L146-L147">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.id"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(iter‚ÇÅ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.Hom</span> <span class="fn">iter‚ÇÅ</span></span></div></div><p>The identity morphism in the category <code>Œ¶.<a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">Iteration</a> Œµ j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.id">CategoryTheory.Functor.Iteration.Hom.id</a> <span class="fn">iter‚ÇÅ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">natTrans</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">iter‚ÇÅ</span>.F</span></span>, <span class="fn">natTrans_app_zero</span> := <span class="fn">‚ãØ</span>, <span class="fn">natTrans_app_succ</span> := <span class="fn">‚ãØ</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.Iteration.Hom.id" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.Hom.ext'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L153-L157">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.ext'"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">ext'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÅ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÇ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.Hom</span> <span class="fn">iter‚ÇÇ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.Hom</span> <span class="fn">iter‚ÇÇ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">f</span>.natTrans</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.natTrans</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.Hom.comp_natTrans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L162-L162">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.comp_natTrans"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">comp_natTrans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÅ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÇ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÉ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.Hom</span> <span class="fn">iter‚ÇÇ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn"><span class="fn">iter‚ÇÇ</span>.Hom</span> <span class="fn">iter‚ÇÉ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">f</span>.comp</span> <span class="fn">g</span></span>)</span>.natTrans</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.natTrans</span> <span class="fn"><span class="fn">g</span>.natTrans</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.Hom.comp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L163-L166">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.comp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÅ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÇ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÉ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.Hom</span> <span class="fn">iter‚ÇÇ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn"><span class="fn">iter‚ÇÇ</span>.Hom</span> <span class="fn">iter‚ÇÉ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">iter‚ÇÅ</span>.Hom</span> <span class="fn">iter‚ÇÉ</span></span></div></div><p>The composition of morphisms in the category <code>Œ¶.<a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">Iteration</a> Œµ j</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.comp</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">natTrans</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.natTrans</span> <span class="fn"><span class="fn">g</span>.natTrans</span></span>, <span class="fn">natTrans_app_zero</span> := <span class="fn">‚ãØ</span>,
    <span class="fn">natTrans_app_succ</span> := <span class="fn">‚ãØ</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.Iteration.Hom.comp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.Hom.instCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L168-L171">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.instCategory"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">instCategory</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{max (max u u_1) u_2, max (max u_2 u_1) u}</a>                                       <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Functor.Iteration.Hom.instCategory</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category.mk">CategoryTheory.Category.mk</a> <span class="fn">‚ãØ</span> <span class="fn">‚ãØ</span> <span class="fn">‚ãØ</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.Iteration.Hom.instSubsingletonHom"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/SmallObject/Iteration.lean#L173-L183">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration.Hom.instSubsingletonHom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">Iteration</span>.<span class="name">Hom</span>.<span class="name">instSubsingletonHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œ¶ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Œµ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Œ¶</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/RelClasses.html#IsWellOrder">IsWellOrder</a> <span class="fn">J</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">J</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder.html#OrderBot">OrderBot</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">J</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÅ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{iter‚ÇÇ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration.html#CategoryTheory.Functor.Iteration">CategoryTheory.Functor.Iteration</a> <span class="fn">Œµ</span> <span class="fn">j</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn"><span class="fn">iter‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">iter‚ÇÇ</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">‚ãØ</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">‚ãØ</span></span></li></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>