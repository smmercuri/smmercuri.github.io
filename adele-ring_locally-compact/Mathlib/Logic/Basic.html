<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Logic.Basic</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Logic.Basic";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Logic</span>.<span class="name">Basic</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Init/Function.html">Mathlib.Init.Function</a></li><li><a href="../.././Mathlib/Init/Logic.html">Mathlib.Init.Logic</a></li><li><a href="../.././Std/Util/LibraryNote.html">Std.Util.LibraryNote</a></li><li><a href="../.././Mathlib/Init/Algebra/Classes.html">Mathlib.Init.Algebra.Classes</a></li><li><a href="../.././Std/Tactic/Lint/Basic.html">Std.Tactic.Lint.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Logic.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#hidden"><span class="name">hidden</span></a></div><div class="nav_link"><a class="break_within" href="#decidableEq_of_subsingleton"><span class="name">decidableEq_of_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonSubtype"><span class="name">instSubsingletonSubtype</span></a></div><div class="nav_link"><a class="break_within" href="#congr_heq"><span class="name">congr_heq</span></a></div><div class="nav_link"><a class="break_within" href="#congr_arg_heq"><span class="name">congr_arg_heq</span></a></div><div class="nav_link"><a class="break_within" href="#ULift.down_injective"><span class="name">ULift</span>.<span class="name">down_injective</span></a></div><div class="nav_link"><a class="break_within" href="#ULift.down_inj"><span class="name">ULift</span>.<span class="name">down_inj</span></a></div><div class="nav_link"><a class="break_within" href="#PLift.down_injective"><span class="name">PLift</span>.<span class="name">down_injective</span></a></div><div class="nav_link"><a class="break_within" href="#PLift.down_inj"><span class="name">PLift</span>.<span class="name">down_inj</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_eq_cancel_left"><span class="name">eq_iff_eq_cancel_left</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_eq_cancel_right"><span class="name">eq_iff_eq_cancel_right</span></a></div><div class="nav_link"><a class="break_within" href="#ne_and_eq_iff_right"><span class="name">ne_and_eq_iff_right</span></a></div><div class="nav_link"><a class="break_within" href="#Fact"><span class="name">Fact</span></a></div><div class="nav_link"><a class="break_within" href="#Fact.elim"><span class="name">Fact</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#fact_iff"><span class="name">fact_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.swap₂"><span class="name">Function</span>.<span class="name">swap₂</span></a></div><div class="nav_link"><a class="break_within" href="#instIsReflPropIff"><span class="name">instIsReflPropIff</span></a></div><div class="nav_link"><a class="break_within" href="#instIsTransPropIff"><span class="name">instIsTransPropIff</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.imp"><span class="name">Iff</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#eq_true_eq_id"><span class="name">eq_true_eq_id</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_right_iff"><span class="name">imp_iff_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#and_or_imp"><span class="name">and_or_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.mt"><span class="name">Function</span>.<span class="name">mt</span></a></div><div class="nav_link"><a class="break_within" href="#dec_em"><span class="name">dec_em</span></a></div><div class="nav_link"><a class="break_within" href="#dec_em'"><span class="name">dec_em'</span></a></div><div class="nav_link"><a class="break_within" href="#em"><span class="name">em</span></a></div><div class="nav_link"><a class="break_within" href="#em'"><span class="name">em'</span></a></div><div class="nav_link"><a class="break_within" href="#or_not"><span class="name">or_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.eq_or_ne"><span class="name">Decidable</span>.<span class="name">eq_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.ne_or_eq"><span class="name">Decidable</span>.<span class="name">ne_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_or_ne"><span class="name">eq_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_or_eq"><span class="name">ne_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#by_contradiction"><span class="name">by_contradiction</span></a></div><div class="nav_link"><a class="break_within" href="#by_cases"><span class="name">by_cases</span></a></div><div class="nav_link"><a class="break_within" href="#by_contra"><span class="name">by_contra</span></a></div><div class="nav_link"><a class="break_within" href="#of_not_not"><span class="name">of_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_ne_iff"><span class="name">not_ne_iff</span></a></div><div class="nav_link"><a class="break_within" href="#of_not_imp"><span class="name">of_not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Not.decidable_imp_symm"><span class="name">Not</span>.<span class="name">decidable_imp_symm</span></a></div><div class="nav_link"><a class="break_within" href="#Not.imp_symm"><span class="name">Not</span>.<span class="name">imp_symm</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_comm"><span class="name">not_imp_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_self"><span class="name">not_imp_self</span></a></div><div class="nav_link"><a class="break_within" href="#Imp.swap"><span class="name">Imp</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not"><span class="name">Iff</span>.<span class="name">not</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not_left"><span class="name">Iff</span>.<span class="name">not_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not_right"><span class="name">Iff</span>.<span class="name">not_right</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne"><span class="name">Iff</span>.<span class="name">ne</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne_left"><span class="name">Iff</span>.<span class="name">ne_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne_right"><span class="name">Iff</span>.<span class="name">ne_right</span></a></div><div class="nav_link"><a class="break_within" href="#xor_true"><span class="name">xor_true</span></a></div><div class="nav_link"><a class="break_within" href="#xor_false"><span class="name">xor_false</span></a></div><div class="nav_link"><a class="break_within" href="#xor_comm"><span class="name">xor_comm</span></a></div><div class="nav_link"><a class="break_within" href="#instCommutativePropXor'"><span class="name">instCommutativePropXor'</span></a></div><div class="nav_link"><a class="break_within" href="#xor_self"><span class="name">xor_self</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_left"><span class="name">xor_not_left</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_right"><span class="name">xor_not_right</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_not"><span class="name">xor_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#Xor'.or"><span class="name">Xor'</span>.<span class="name">or</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.and"><span class="name">Iff</span>.<span class="name">and</span></a></div><div class="nav_link"><a class="break_within" href="#And.rotate"><span class="name">And</span>.<span class="name">rotate</span></a></div><div class="nav_link"><a class="break_within" href="#and_symm_right"><span class="name">and_symm_right</span></a></div><div class="nav_link"><a class="break_within" href="#and_symm_left"><span class="name">and_symm_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.or"><span class="name">Iff</span>.<span class="name">or</span></a></div><div class="nav_link"><a class="break_within" href="#Or.rotate"><span class="name">Or</span>.<span class="name">rotate</span></a></div><div class="nav_link"><a class="break_within" href="#or_of_or_of_imp_of_imp"><span class="name">or_of_or_of_imp_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#or_of_or_of_imp_left"><span class="name">or_of_or_of_imp_left</span></a></div><div class="nav_link"><a class="break_within" href="#or_of_or_of_imp_right"><span class="name">or_of_or_of_imp_right</span></a></div><div class="nav_link"><a class="break_within" href="#Or.elim3"><span class="name">Or</span>.<span class="name">elim3</span></a></div><div class="nav_link"><a class="break_within" href="#Or.imp3"><span class="name">Or</span>.<span class="name">imp3</span></a></div><div class="nav_link"><a class="break_within" href="#not_or_of_imp"><span class="name">not_or_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.or_not_of_imp"><span class="name">Decidable</span>.<span class="name">or_not_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#or_not_of_imp"><span class="name">or_not_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_not_or"><span class="name">imp_iff_not_or</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_or_not"><span class="name">imp_iff_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_not"><span class="name">not_imp_not</span></a></div><div class="nav_link"><a class="break_within" href="#imp_and_neg_imp_iff"><span class="name">imp_and_neg_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.mtr"><span class="name">Function</span>.<span class="name">mtr</span></a></div><div class="nav_link"><a class="break_within" href="#or_congr_left'"><span class="name">or_congr_left'</span></a></div><div class="nav_link"><a class="break_within" href="#or_congr_right'"><span class="name">or_congr_right'</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.iff"><span class="name">Iff</span>.<span class="name">iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_mpr_iff_true_intro"><span class="name">iff_mpr_iff_true_intro</span></a></div><div class="nav_link"><a class="break_within" href="#imp_or"><span class="name">imp_or</span></a></div><div class="nav_link"><a class="break_within" href="#imp_or'"><span class="name">imp_or'</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp"><span class="name">not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#peirce"><span class="name">peirce</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_not"><span class="name">not_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_comm"><span class="name">not_iff_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff"><span class="name">not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_not_comm"><span class="name">iff_not_comm</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_and_or_not_and_not"><span class="name">iff_iff_and_or_not_and_not</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_not_or_and_or_not"><span class="name">iff_iff_not_or_and_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_and_not_right"><span class="name">not_and_not_right</span></a></div><div class="nav_link"><a class="break_within" href="#not_and_or"><span class="name">not_and_or</span></a></div><div class="nav_link"><a class="break_within" href="#or_iff_not_and_not"><span class="name">or_iff_not_and_not</span></a></div><div class="nav_link"><a class="break_within" href="#and_iff_not_or_not"><span class="name">and_iff_not_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_xor"><span class="name">not_xor</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_not_iff"><span class="name">xor_iff_not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_iff_not"><span class="name">xor_iff_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_not_iff'"><span class="name">xor_iff_not_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_not_mem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_not_mem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem'</span></a></div><div class="nav_link"><a class="break_within" href="#ball_cond_comm"><span class="name">ball_cond_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ball_mem_comm"><span class="name">ball_mem_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_eq_of_ne"><span class="name">ne_of_eq_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_ne_of_eq"><span class="name">ne_of_ne_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.trans_ne"><span class="name">Eq</span>.<span class="name">trans_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.trans_eq"><span class="name">Ne</span>.<span class="name">trans_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_equivalence"><span class="name">eq_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#congr_refl_left"><span class="name">congr_refl_left</span></a></div><div class="nav_link"><a class="break_within" href="#congr_refl_right"><span class="name">congr_refl_right</span></a></div><div class="nav_link"><a class="break_within" href="#congr_arg_refl"><span class="name">congr_arg_refl</span></a></div><div class="nav_link"><a class="break_within" href="#congr_fun_rfl"><span class="name">congr_fun_rfl</span></a></div><div class="nav_link"><a class="break_within" href="#congr_fun_congr_arg"><span class="name">congr_fun_congr_arg</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.rec_eq_cast"><span class="name">Eq</span>.<span class="name">rec_eq_cast</span></a></div><div class="nav_link"><a class="break_within" href="#eqRec_heq'"><span class="name">eqRec_heq'</span></a></div><div class="nav_link"><a class="break_within" href="#rec_heq_of_heq"><span class="name">rec_heq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#rec_heq_iff_heq"><span class="name">rec_heq_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_rec_iff_heq"><span class="name">heq_rec_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#pi_congr"><span class="name">pi_congr</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_imp"><span class="name">forall₂_imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall₃_imp"><span class="name">forall₃_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Exists₂.imp"><span class="name">Exists₂</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#Exists₃.imp"><span class="name">Exists₃</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall_swap"><span class="name">forall_swap</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_swap"><span class="name">forall₂_swap</span></a></div><div class="nav_link"><a class="break_within" href="#imp_forall_iff"><span class="name">imp_forall_iff</span></a></div><div class="nav_link"><a class="break_within" href="#exists_swap"><span class="name">exists_swap</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall_not"><span class="name">not_forall_not</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_exists_not"><span class="name">forall_or_exists_not</span></a></div><div class="nav_link"><a class="break_within" href="#exists_or_forall_not"><span class="name">exists_or_forall_not</span></a></div><div class="nav_link"><a class="break_within" href="#forall_imp_iff_exists_imp"><span class="name">forall_imp_iff_exists_imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_iff"><span class="name">forall_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_iff'"><span class="name">forall_true_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_true_iff"><span class="name">forall₂_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#forall₃_true_iff"><span class="name">forall₃_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_iff_exists"><span class="name">exists_unique_iff_exists</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_const"><span class="name">exists_unique_const</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.and_forall_ne"><span class="name">Decidable</span>.<span class="name">and_forall_ne</span></a></div><div class="nav_link"><a class="break_within" href="#and_forall_ne"><span class="name">and_forall_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ne_or_ne"><span class="name">Ne</span>.<span class="name">ne_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_eq"><span class="name">exists_unique_eq</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_eq'"><span class="name">exists_unique_eq'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply'"><span class="name">exists_apply_eq_apply'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq"><span class="name">exists_apply_eq</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_and_eq_and"><span class="name">exists_exists_and_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_eq_and"><span class="name">exists_exists_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_and_exists_and_eq_and"><span class="name">exists_exists_and_exists_and_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_exists_and_eq"><span class="name">exists_exists_exists_and_eq</span></a></div><div class="nav_link"><a class="break_within" href="#exists_or_eq_left"><span class="name">exists_or_eq_left</span></a></div><div class="nav_link"><a class="break_within" href="#exists_or_eq_right"><span class="name">exists_or_eq_right</span></a></div><div class="nav_link"><a class="break_within" href="#exists_or_eq_left'"><span class="name">exists_or_eq_left'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_or_eq_right'"><span class="name">exists_or_eq_right'</span></a></div><div class="nav_link"><a class="break_within" href="#forall_apply_eq_imp_iff'"><span class="name">forall_apply_eq_imp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#forall_eq_apply_imp_iff'"><span class="name">forall_eq_apply_imp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_eq_right'"><span class="name">exists_eq_right'</span></a></div><div class="nav_link"><a class="break_within" href="#exists₂_comm"><span class="name">exists₂_comm</span></a></div><div class="nav_link"><a class="break_within" href="#And.exists"><span class="name">And</span>.<span class="name">exists</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_of_or_forall"><span class="name">forall_or_of_or_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.forall_or_left"><span class="name">Decidable</span>.<span class="name">forall_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_left"><span class="name">forall_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.forall_or_right"><span class="name">Decidable</span>.<span class="name">forall_or_right</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_right"><span class="name">forall_or_right</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_prop"><span class="name">exists_unique_prop</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_false"><span class="name">exists_unique_false</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.fst"><span class="name">Exists</span>.<span class="name">fst</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.snd"><span class="name">Exists</span>.<span class="name">snd</span></a></div><div class="nav_link"><a class="break_within" href="#Prop.exists_iff"><span class="name">Prop</span>.<span class="name">exists_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Prop.forall_iff"><span class="name">Prop</span>.<span class="name">forall_iff</span></a></div><div class="nav_link"><a class="break_within" href="#exists_prop_of_true"><span class="name">exists_prop_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#exists_iff_of_forall"><span class="name">exists_iff_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_prop_of_true"><span class="name">exists_unique_prop_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#exists_prop_of_false"><span class="name">exists_prop_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#exists_prop_congr"><span class="name">exists_prop_congr</span></a></div><div class="nav_link"><a class="break_within" href="#exists_prop_congr'"><span class="name">exists_prop_congr'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_true_left"><span class="name">exists_true_left</span></a></div><div class="nav_link"><a class="break_within" href="#forall_prop_congr"><span class="name">forall_prop_congr</span></a></div><div class="nav_link"><a class="break_within" href="#forall_prop_congr'"><span class="name">forall_prop_congr'</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_left"><span class="name">forall_true_left</span></a></div><div class="nav_link"><a class="break_within" href="#ExistsUnique.elim₂"><span class="name">ExistsUnique</span>.<span class="name">elim₂</span></a></div><div class="nav_link"><a class="break_within" href="#ExistsUnique.intro₂"><span class="name">ExistsUnique</span>.<span class="name">intro₂</span></a></div><div class="nav_link"><a class="break_within" href="#ExistsUnique.exists₂"><span class="name">ExistsUnique</span>.<span class="name">exists₂</span></a></div><div class="nav_link"><a class="break_within" href="#ExistsUnique.unique₂"><span class="name">ExistsUnique</span>.<span class="name">unique₂</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.dec"><span class="name">Classical</span>.<span class="name">dec</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decPred"><span class="name">Classical</span>.<span class="name">decPred</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decRel"><span class="name">Classical</span>.<span class="name">decRel</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decEq"><span class="name">Classical</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.existsCases"><span class="name">Classical</span>.<span class="name">existsCases</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.some_spec₂"><span class="name">Classical</span>.<span class="name">some_spec₂</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.subtype_of_exists"><span class="name">Classical</span>.<span class="name">subtype_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.byContradiction'"><span class="name">Classical</span>.<span class="name">byContradiction'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choice_of_byContradiction'"><span class="name">Classical</span>.<span class="name">choice_of_byContradiction'</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.classicalRecOn"><span class="name">Exists</span>.<span class="name">classicalRecOn</span></a></div><div class="nav_link"><a class="break_within" href="#bex_def"><span class="name">bex_def</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.elim"><span class="name">BEx</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.intro"><span class="name">BEx</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#ball_congr"><span class="name">ball_congr</span></a></div><div class="nav_link"><a class="break_within" href="#bex_congr"><span class="name">bex_congr</span></a></div><div class="nav_link"><a class="break_within" href="#bex_eq_left"><span class="name">bex_eq_left</span></a></div><div class="nav_link"><a class="break_within" href="#BAll.imp_right"><span class="name">BAll</span>.<span class="name">imp_right</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.imp_right"><span class="name">BEx</span>.<span class="name">imp_right</span></a></div><div class="nav_link"><a class="break_within" href="#BAll.imp_left"><span class="name">BAll</span>.<span class="name">imp_left</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.imp_left"><span class="name">BEx</span>.<span class="name">imp_left</span></a></div><div class="nav_link"><a class="break_within" href="#ball_of_forall"><span class="name">ball_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#forall_of_ball"><span class="name">forall_of_ball</span></a></div><div class="nav_link"><a class="break_within" href="#bex_of_exists"><span class="name">bex_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#exists_of_bex"><span class="name">exists_of_bex</span></a></div><div class="nav_link"><a class="break_within" href="#bex_imp"><span class="name">bex_imp</span></a></div><div class="nav_link"><a class="break_within" href="#not_bex"><span class="name">not_bex</span></a></div><div class="nav_link"><a class="break_within" href="#not_ball_of_bex_not"><span class="name">not_ball_of_bex_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.not_ball"><span class="name">Decidable</span>.<span class="name">not_ball</span></a></div><div class="nav_link"><a class="break_within" href="#not_ball"><span class="name">not_ball</span></a></div><div class="nav_link"><a class="break_within" href="#ball_true_iff"><span class="name">ball_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ball_and"><span class="name">ball_and</span></a></div><div class="nav_link"><a class="break_within" href="#bex_or"><span class="name">bex_or</span></a></div><div class="nav_link"><a class="break_within" href="#ball_or_left"><span class="name">ball_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#bex_or_left"><span class="name">bex_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_iff"><span class="name">dite_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_iff"><span class="name">ite_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#eq_ite_iff"><span class="name">eq_ite_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_iff'"><span class="name">dite_eq_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_iff'"><span class="name">ite_eq_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#dite_ne_left_iff"><span class="name">dite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_ne_right_iff"><span class="name">dite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ne_left_iff"><span class="name">ite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ne_right_iff"><span class="name">ite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_eq_left_iff"><span class="name">Ne</span>.<span class="name">dite_eq_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_eq_right_iff"><span class="name">Ne</span>.<span class="name">dite_eq_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_eq_left_iff"><span class="name">Ne</span>.<span class="name">ite_eq_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_eq_right_iff"><span class="name">Ne</span>.<span class="name">ite_eq_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_ne_left_iff"><span class="name">Ne</span>.<span class="name">dite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_ne_right_iff"><span class="name">Ne</span>.<span class="name">dite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_ne_left_iff"><span class="name">Ne</span>.<span class="name">ite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_ne_right_iff"><span class="name">Ne</span>.<span class="name">ite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_or_eq"><span class="name">dite_eq_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_or_eq"><span class="name">ite_eq_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#apply_dite₂"><span class="name">apply_dite₂</span></a></div><div class="nav_link"><a class="break_within" href="#apply_ite₂"><span class="name">apply_ite₂</span></a></div><div class="nav_link"><a class="break_within" href="#dite_apply"><span class="name">dite_apply</span></a></div><div class="nav_link"><a class="break_within" href="#ite_apply"><span class="name">ite_apply</span></a></div><div class="nav_link"><a class="break_within" href="#ite_and"><span class="name">ite_and</span></a></div><div class="nav_link"><a class="break_within" href="#dite_dite_comm"><span class="name">dite_dite_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ite_comm"><span class="name">ite_ite_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ite_prop_iff_or"><span class="name">ite_prop_iff_or</span></a></div><div class="nav_link"><a class="break_within" href="#dite_prop_iff_or"><span class="name">dite_prop_iff_or</span></a></div><div class="nav_link"><a class="break_within" href="#ite_prop_iff_and"><span class="name">ite_prop_iff_and</span></a></div><div class="nav_link"><a class="break_within" href="#dite_prop_iff_and"><span class="name">dite_prop_iff_and</span></a></div><div class="nav_link"><a class="break_within" href="#if_true_right"><span class="name">if_true_right</span></a></div><div class="nav_link"><a class="break_within" href="#if_true_left"><span class="name">if_true_left</span></a></div><div class="nav_link"><a class="break_within" href="#if_false_right"><span class="name">if_false_right</span></a></div><div class="nav_link"><a class="break_within" href="#if_false_left"><span class="name">if_false_left</span></a></div><div class="nav_link"><a class="break_within" href="#not_beq_of_ne"><span class="name">not_beq_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#beq_eq_decide"><span class="name">beq_eq_decide</span></a></div><div class="nav_link"><a class="break_within" href="#beq_ext"><span class="name">beq_ext</span></a></div><div class="nav_link"><a class="break_within" href="#lawful_beq_subsingleton"><span class="name">lawful_beq_subsingleton</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Basic-logic-properties">Basic logic properties <a class="hover-link" href="#Basic-logic-properties">#</a></h1><p>This file is one of the earliest imports in mathlib.</p><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>Theorems that require decidability hypotheses are in the namespace <code><a href="../.././Init/Prelude.html#Decidable">Decidable</a></code>.
Classical versions are in the namespace <code>Classical</code>.</p></div><div class="decl" id="hidden"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L47-L47">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#hidden"><span class="name">hidden</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>An identity function with its main argument implicit. This will be printed as <code><a href="../.././Mathlib/Logic/Basic.html#hidden">hidden</a></code> even
if it is applied to a large term, so it can be used for elision,
as done in the <code>elide</code> and <code>unelide</code> tactics.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">hidden</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></li></ul></details><details id="instances-for-list-hidden" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="decidableEq_of_subsingleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L50-L51">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#decidableEq_of_subsingleton"><span class="name">decidableEq_of_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#decidableEq_of_subsingleton">decidableEq_of_subsingleton</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="instSubsingletonSubtype"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L54-L55">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instSubsingletonSubtype"><span class="name">instSubsingletonSubtype</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Sort</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Subtype">Subtype</a> <span class="fn">p</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="congr_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L59-L61">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_heq"><span class="name">congr_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="congr_arg_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L64-L66">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_arg_heq"><span class="name">congr_arg_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">a₁</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">a₂</span></span>)</span></span></span></div></div></div></div><div class="decl" id="ULift.down_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L69-L70">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ULift.down_injective"><span class="name">ULift</span>.<span class="name">down_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Function.html#Function.Injective">Function.Injective</a> <span class="fn">ULift.down</span></span></div></div></div></div><div class="decl" id="ULift.down_inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L73-L74">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ULift.down_inj"><span class="name">ULift</span>.<span class="name">down_inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn"><a href="../.././Init/Prelude.html#ULift">ULift.{u_2, u_1}</a>      <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn"><a href="../.././Init/Prelude.html#ULift">ULift.{u_2, u_1}</a>      <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span>.down</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b</span>.down</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="PLift.down_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L77-L78">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#PLift.down_injective"><span class="name">PLift</span>.<span class="name">down_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Function.html#Function.Injective">Function.Injective</a> <span class="fn">PLift.down</span></span></div></div></div></div><div class="decl" id="PLift.down_inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L81-L82">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#PLift.down_inj"><span class="name">PLift</span>.<span class="name">down_inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn"><a href="../.././Init/Prelude.html#PLift">PLift</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn"><a href="../.././Init/Prelude.html#PLift">PLift</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span>.down</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b</span>.down</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="eq_iff_eq_cancel_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L85-L86">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_iff_eq_cancel_left"><span class="name">eq_iff_eq_cancel_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="eq_iff_eq_cancel_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L89-L90">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_iff_eq_cancel_right"><span class="name">eq_iff_eq_cancel_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ {<span class="fn">c</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="ne_and_eq_iff_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L93-L94">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_and_eq_iff_right"><span class="name">ne_and_eq_iff_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Fact"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L114-L117">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Fact"><span class="name">Fact</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>Wrapper for adding elementary propositions to the type class systems.
Warning: this can easily be abused. See the rest of this docstring for details.</p><p>Certain propositions should not be treated as a class globally,
but sometimes it is very convenient to be able to use the type class system
in specific circumstances.</p><p>For example, <code>ZMod p</code> is a field if and only if <code>p</code> is a prime number.
In order to be able to find this field instance automatically by type class search,
we have to turn <code>p.prime</code> into an instance implicit assumption.</p><p>On the other hand, making <code>Nat.prime</code> a class would require a major refactoring of the library,
and it is questionable whether making <code>Nat.prime</code> a class is desirable at all.
The compromise is to add the assumption <code>[Fact p.prime]</code> to <code>ZMod.field</code>.</p><p>In particular, this class is not intended for turning the type class system
into an automated theorem prover for first order logic.</p><ul class="structure_fields" id="Fact.mk"><li id="Fact.out" class="structure_field"><div class="structure_field_info">out : <span class="fn">p</span></div><div class="structure_field_doc"><p><code><a href="../.././Mathlib/Logic/Basic.html#Fact.out">Fact.out</a></code> contains the unwrapped witness for the fact represented by the instance of
<code><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> p</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Fact" class="instances-list"></ul></details></div></div><div class="decl" id="Fact.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L126-L126">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Fact.elim"><span class="name">Fact</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div></div></div><div class="decl" id="fact_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L127-L127">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#fact_iff"><span class="name">fact_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="Function.swap₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L132-L134">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.swap₂"><span class="name">Function</span>.<span class="name">swap₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₁ : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₂ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₁ : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₂ : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Sort</a> u_3</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn">(<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>) → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn">(<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>) → <span class="fn"><span class="fn">φ</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i₂ : <span class="fn">ι₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i₁ : <span class="fn">ι₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₁ : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">φ</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></div></div><p>Swaps two pairs of arguments to a function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Function.swap₂">Function.swap₂</a> <span class="fn">f</span> <span class="fn">i₂</span> <span class="fn">j₂</span> <span class="fn">i₁</span> <span class="fn">j₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></li></ul></details><details id="instances-for-list-Function.swap₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-propositional-connectives">Declarations about propositional connectives <a class="hover-link" href="#Declarations-about-propositional-connectives">#</a></h3></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-implies">Declarations about <code>implies</code> <a class="hover-link" href="#Declarations-about-implies">#</a></h3></div><div class="decl" id="instIsReflPropIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L160-L160">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instIsReflPropIff"><span class="name">instIsReflPropIff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Algebra/Classes.html#IsRefl">IsRefl</a> <a href="../.././foundational_types.html">Prop</a> <a href="../.././Init/Core.html#Iff">Iff</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#instIsReflPropIff">instIsReflPropIff</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instIsTransPropIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L162-L162">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instIsTransPropIff"><span class="name">instIsTransPropIff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Algebra/Classes.html#IsTrans">IsTrans</a> <a href="../.././foundational_types.html">Prop</a> <a href="../.././Init/Core.html#Iff">Iff</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#instIsTransPropIff">instIsTransPropIff</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Iff.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L164-L164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.imp"><span class="name">Iff</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#imp_congr">imp_congr</a></code>.</p></div></div><div class="decl" id="eq_true_eq_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L167-L168">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_true_eq_id"><span class="name">eq_true_eq_id</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Eq">Eq</a> <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">id</span></span></div></div></div></div><div class="decl" id="imp_iff_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L175-L175">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_right_iff"><span class="name">imp_iff_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="and_or_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L178-L178">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_or_imp"><span class="name">and_or_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Function.mt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L182-L182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.mt"><span class="name">Function</span>.<span class="name">mt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></span></div></div><p>Provide modus tollens (<code><a href="../.././Init/Core.html#mt">mt</a></code>) as dot notation for implications.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-not">Declarations about <code><a href="../.././Init/Prelude.html#not">not</a></code> <a class="hover-link" href="#Declarations-about-not">#</a></h3></div><div class="decl" id="dec_em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L187-L187">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dec_em"><span class="name">dec_em</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#Decidable.em">Decidable.em</a></code>.</p></div></div><div class="decl" id="dec_em'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L190-L190">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dec_em'"><span class="name">dec_em'</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L193-L193">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#em"><span class="name">em</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.em">Classical.em</a></code>.</p><hr></hr><p><strong>Diaconescu's theorem</strong>: excluded middle from choice, Function extensionality and propositional extensionality.</p></div></div><div class="decl" id="em'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L196-L196">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#em'"><span class="name">em'</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L199-L199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_not"><span class="name">or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="Decidable.eq_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L202-L202">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.eq_or_ne"><span class="name">Decidable</span>.<span class="name">eq_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="Decidable.ne_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L205-L205">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.ne_or_eq"><span class="name">Decidable</span>.<span class="name">ne_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="eq_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L208-L208">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_or_ne"><span class="name">eq_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="ne_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L211-L211">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_or_eq"><span class="name">ne_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="by_contradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L214-L214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_contradiction"><span class="name">by_contradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href="../.././Init/Prelude.html#False">False</a></span>)</span> → <span class="fn">p</span></span></div></div></div></div><div class="decl" id="by_cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L218-L219">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_cases"><span class="name">by_cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hpq : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hnpq : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div></div></div><div class="decl" id="by_contra"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L222-L222">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_contra"><span class="name">by_contra</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href="../.././Init/Prelude.html#False">False</a></span>)</span> → <span class="fn">p</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#by_contradiction">by_contradiction</a></code>.</p></div></div><div class="decl" id="of_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L249-L249">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#of_not_not"><span class="name">of_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_ne_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L252-L252">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_ne_iff"><span class="name">not_ne_iff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1} {<span class="fn">a </span>b : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="of_not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L255-L255">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#of_not_imp"><span class="name">of_not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Not.decidable_imp_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L258-L258">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Not.decidable_imp_symm"><span class="name">Not</span>.<span class="name">decidable_imp_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#Decidable.not_imp_symm">Decidable.not_imp_symm</a></code>.</p></div></div><div class="decl" id="Not.imp_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L261-L261">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Not.imp_symm"><span class="name">Not</span>.<span class="name">imp_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">b</span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> → <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="not_imp_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L264-L264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_comm"><span class="name">not_imp_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> → <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="not_imp_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L267-L267">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_self"><span class="name">not_imp_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Imp.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L270-L270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Imp.swap"><span class="name">Imp</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Iff.not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L273-L273">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not"><span class="name">Iff</span>.<span class="name">not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#not_congr">not_congr</a></code>.</p></div></div><div class="decl" id="Iff.not_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L276-L276">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not_left"><span class="name">Iff</span>.<span class="name">not_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Iff.not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L279-L279">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not_right"><span class="name">Iff</span>.<span class="name">not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Iff.ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L282-L283">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne"><span class="name">Iff</span>.<span class="name">ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span></span></span>)</span></span></div></div></div></div><div class="decl" id="Iff.ne_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L286-L287">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne_left"><span class="name">Iff</span>.<span class="name">ne_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span></span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span>)</span></span></div></div></div></div><div class="decl" id="Iff.ne_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L290-L291">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne_right"><span class="name">Iff</span>.<span class="name">ne_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span></span></span>)</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-Xor">Declarations about <code><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a></code> <a class="hover-link" href="#Declarations-about-Xor">#</a></h3></div><div class="decl" id="xor_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L296-L297">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_true"><span class="name">xor_true</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Not">Not</a></span></div></div></div></div><div class="decl" id="xor_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L300-L300">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_false"><span class="name">xor_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">id</span></span></div></div></div></div><div class="decl" id="xor_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L303-L303">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_comm"><span class="name">xor_comm</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">b</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="instCommutativePropXor'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L306-L306">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instCommutativePropXor'"><span class="name">instCommutativePropXor'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Std.Commutative">Std.Commutative</a> <a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#instCommutativePropXor'">instCommutativePropXor'</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="xor_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L308-L308">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_self"><span class="name">xor_self</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="xor_not_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L311-L311">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_left"><span class="name">xor_not_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span></div></div></div></div><div class="decl" id="xor_not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L314-L314">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_right"><span class="name">xor_not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span></div></div></div></div><div class="decl" id="xor_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L317-L317">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_not"><span class="name">xor_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Xor'.or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L320-L320">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Xor'.or"><span class="name">Xor'</span>.<span class="name">or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-and">Declarations about <code><a href="../.././Init/Prelude.html#and">and</a></code> <a class="hover-link" href="#Declarations-about-and">#</a></h3></div><div class="decl" id="Iff.and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L325-L325">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.and"><span class="name">Iff</span>.<span class="name">and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">d</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#and_congr">and_congr</a></code>.</p></div></div><div class="decl" id="And.rotate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L332-L332">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#And.rotate"><span class="name">And</span>.<span class="name">rotate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">c</span></span></span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../.././Init/PropLemmas.html#and_rotate">and_rotate</a></code>.</p></div></div><div class="decl" id="and_symm_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L337-L337">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_symm_right"><span class="name">and_symm_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="and_symm_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L338-L338">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_symm_left"><span class="name">and_symm_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">p</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">p</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-or">Declarations about <code><a href="../.././Init/Prelude.html#or">or</a></code> <a class="hover-link" href="#Declarations-about-or">#</a></h3></div><div class="decl" id="Iff.or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L342-L342">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.or"><span class="name">Iff</span>.<span class="name">or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">d</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#or_congr">or_congr</a></code>.</p></div></div><div class="decl" id="Or.rotate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L347-L347">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.rotate"><span class="name">Or</span>.<span class="name">rotate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../.././Init/PropLemmas.html#or_rotate">or_rotate</a></code>.</p></div></div><div class="decl" id="or_of_or_of_imp_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L351-L351">source</a></div><div class="attributes">@[deprecated Or.imp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_of_or_of_imp_of_imp"><span class="name">or_of_or_of_imp_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₃ : <span class="fn"><span class="fn">b</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">d</span></span></div></div></div></div><div class="decl" id="or_of_or_of_imp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L355-L355">source</a></div><div class="attributes">@[deprecated Or.imp_left]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_of_or_of_imp_left"><span class="name">or_of_or_of_imp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="or_of_or_of_imp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L359-L359">source</a></div><div class="attributes">@[deprecated Or.imp_right]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_of_or_of_imp_right"><span class="name">or_of_or_of_imp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Or.elim3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L362-L363">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.elim3"><span class="name">Or</span>.<span class="name">elim3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ha : <span class="fn"><span class="fn">a</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn">b</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hc : <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">d</span></div></div></div></div><div class="decl" id="Or.imp3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L366-L367">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.imp3"><span class="name">Or</span>.<span class="name">imp3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(had : <span class="fn"><span class="fn">a</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbe : <span class="fn"><span class="fn">b</span> → <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hcf : <span class="fn"><span class="fn">c</span> → <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> → <span class="fn"><span class="fn">d</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">e</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="not_or_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L376-L376">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_or_of_imp"><span class="name">not_or_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Decidable.or_not_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L380-L381">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.or_not_of_imp"><span class="name">Decidable</span>.<span class="name">or_not_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="or_not_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L384-L384">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_not_of_imp"><span class="name">or_not_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="imp_iff_not_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L387-L387">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_not_or"><span class="name">imp_iff_not_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="imp_iff_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L390-L390">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_or_not"><span class="name">imp_iff_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="not_imp_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L393-L393">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_not"><span class="name">not_imp_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="imp_and_neg_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L397-L398">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_and_neg_imp_iff"><span class="name">imp_and_neg_imp_iff</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn">q</span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span></div></div></div></div><div class="decl" id="Function.mtr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L401-L401">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.mtr"><span class="name">Function</span>.<span class="name">mtr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></span></div></div><p>Provide the reverse of modus tollens (<code><a href="../.././Init/Core.html#mt">mt</a></code>) as dot notation for implications.</p></div></div><div class="decl" id="or_congr_left'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L409-L409">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_congr_left'"><span class="name">or_congr_left'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span> → <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="or_congr_right'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L412-L412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_congr_right'"><span class="name">or_congr_right'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">(<span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-distributivity">Declarations about distributivity <a class="hover-link" href="#Declarations-about-distributivity">#</a></h3></div><div class="mod_doc"><p>Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Iff.iff">iff</a></code></p></div><div class="decl" id="Iff.iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L426-L426">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.iff"><span class="name">Iff</span>.<span class="name">iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p₁ : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p₂ : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q₁ : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q₂ : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">p₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">q₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₁</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn">p₂</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₂</span></span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/SimpLemmas.html#iff_congr">iff_congr</a></code>.</p></div></div><div class="decl" id="iff_mpr_iff_true_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L430-L430">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_mpr_iff_true_intro"><span class="name">iff_mpr_iff_true_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">P</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="imp_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L435-L435">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_or"><span class="name">imp_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span>)</span></span></span></div></div></div></div><div class="decl" id="imp_or'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L440-L440">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_or'"><span class="name">imp_or'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span>)</span></span></span></div></div></div></div><div class="decl" id="not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L443-L443">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp"><span class="name">not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="peirce"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L446-L446">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#peirce"><span class="name">peirce</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span> → <span class="fn">a</span></span>)</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L449-L449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff_not"><span class="name">not_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span></div></div></div></div><div class="decl" id="not_iff_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L452-L452">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff_comm"><span class="name">not_iff_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span></span>)</span></span></div></div></div></div><div class="decl" id="not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L455-L455">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff"><span class="name">not_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span></div></div></div></div><div class="decl" id="iff_not_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L458-L458">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_not_comm"><span class="name">iff_not_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span>)</span></span></div></div></div></div><div class="decl" id="iff_iff_and_or_not_and_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L461-L462">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_iff_and_or_not_and_not"><span class="name">iff_iff_and_or_not_and_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="iff_iff_not_or_and_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L465-L466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_iff_not_or_and_or_not"><span class="name">iff_iff_not_or_and_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span>)</span></span></span></div></div></div></div><div class="decl" id="not_and_not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L469-L469">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_and_not_right"><span class="name">not_and_not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="De-Morgan-s-laws">De Morgan's laws <a class="hover-link" href="#De-Morgan-s-laws">#</a></h3></div><div class="decl" id="not_and_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L483-L483">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_and_or"><span class="name">not_and_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></div></div><p>One of <strong>de Morgan's laws</strong>: the negation of a conjunction is logically equivalent to the
disjunction of the negations.</p></div></div><div class="decl" id="or_iff_not_and_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L488-L488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_iff_not_and_not"><span class="name">or_iff_not_and_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span>)</span></span></span></div></div></div></div><div class="decl" id="and_iff_not_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L491-L491">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_iff_not_or_not"><span class="name">and_iff_not_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span>)</span></span></span></div></div></div></div><div class="decl" id="not_xor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L494-L495">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_xor"><span class="name">not_xor</span></a></span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">P</span> <span class="fn">Q</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span></span>)</span></span></div></div></div></div><div class="decl" id="xor_iff_not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L498-L498">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_not_iff"><span class="name">xor_iff_not_iff</span></a></span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">P</span> <span class="fn">Q</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span></span>)</span></span></span></div></div></div></div><div class="decl" id="xor_iff_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L501-L501">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_iff_not"><span class="name">xor_iff_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span>)</span></span></div></div></div></div><div class="decl" id="xor_iff_not_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L504-L504">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_not_iff'"><span class="name">xor_iff_not_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-equality">Declarations about equality <a class="hover-link" href="#Declarations-about-equality">#</a></h3></div><div class="decl" id="Membership.mem.ne_of_not_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L511-L511">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_not_mem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Std/Logic.html#ne_of_mem_of_not_mem">ne_of_mem_of_not_mem</a></code>.</p></div></div><div class="decl" id="Membership.mem.ne_of_not_mem'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L512-L512">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_not_mem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span> → <span class="fn"><span class="fn">s</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">t</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Std/Logic.html#ne_of_mem_of_not_mem'">ne_of_mem_of_not_mem'</a></code>.</p></div></div><div class="decl" id="ball_cond_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L520-L522">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_cond_comm"><span class="name">ball_cond_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span></div></div></div></div><div class="decl" id="ball_mem_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L525-L527">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_mem_comm"><span class="name">ball_mem_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span></div></div></div></div><div class="decl" id="ne_of_eq_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L532-L532">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_of_eq_of_ne"><span class="name">ne_of_eq_of_ne</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1} {<span class="fn">a </span>b c : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="ne_of_ne_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L533-L533">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_of_ne_of_eq"><span class="name">ne_of_ne_of_eq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1} {<span class="fn">a </span>b c : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Eq.trans_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L535-L535">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Eq.trans_ne"><span class="name">Eq</span>.<span class="name">trans_ne</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1} {<span class="fn">a </span>b c : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#ne_of_eq_of_ne">ne_of_eq_of_ne</a></code>.</p></div></div><div class="decl" id="Ne.trans_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L536-L536">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.trans_eq"><span class="name">Ne</span>.<span class="name">trans_eq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1} {<span class="fn">a </span>b c : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#ne_of_ne_of_eq">ne_of_ne_of_eq</a></code>.</p></div></div><div class="decl" id="eq_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L540-L541">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_equivalence"><span class="name">eq_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">Eq</span></span></div></div></div></div><div class="decl" id="congr_refl_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L552-L553">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_refl_left"><span class="name">congr_refl_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_refl_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L557-L558">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_refl_right"><span class="name">congr_refl_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_arg_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L562-L562">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_arg_refl"><span class="name">congr_arg_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_fun_rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L566-L566">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_fun_rfl"><span class="name">congr_fun_rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_fun_congr_arg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L570-L571">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_fun_congr_arg"><span class="name">congr_fun_congr_arg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Eq.rec_eq_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L577-L578">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Eq.rec_eq_cast"><span class="name">Eq</span>.<span class="name">rec_eq_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(z : <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">h</span> ▸ <span class="fn">z</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">z</span></span></span></div></div></div></div><div class="decl" id="eqRec_heq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L581-L584">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eqRec_heq'"><span class="name">eqRec_heq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">motive</span> <span class="fn">a'</span> <span class="fn">⋯</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn"><span class="fn">t</span> ▸ <span class="fn">p</span></span>)</span> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="rec_heq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L586-L587">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#rec_heq_of_heq"><span class="name">rec_heq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn"><span class="fn">e</span> ▸ <span class="fn">x</span></span>)</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="rec_heq_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L590-L591">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#rec_heq_iff_heq"><span class="name">rec_heq_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn"><span class="fn">e</span> ▸ <span class="fn">x</span></span>)</span> <span class="fn">y</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="heq_rec_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L594-L595">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_rec_iff_heq"><span class="name">heq_rec_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><span class="fn">e</span> ▸ <span class="fn">y</span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-quantifiers">Declarations about quantifiers <a class="hover-link" href="#Declarations-about-quantifiers">#</a></h3></div><div class="decl" id="pi_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L621-L622">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#pi_congr"><span class="name">pi_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β' : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">β'</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β'</span> <span class="fn">a</span></span></span>)</span></span></div></div></div></div><div class="decl" id="forall₂_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L628-L630">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_imp"><span class="name">forall₂_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="forall₃_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L633-L635">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₃_imp"><span class="name">forall₃_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_2</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span>)</span> → <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Exists₂.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L638-L640">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists₂.imp"><span class="name">Exists₂</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span> → <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="Exists₃.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L643-L645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists₃.imp"><span class="name">Exists₃</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_2</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn">∃ (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span>)</span> → <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn">∃ (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></span></div></div></div></div><div class="decl" id="forall_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L654-L654">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_swap"><span class="name">forall_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">y</span> : <span class="fn">β</span>) (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></div></div></div></div><div class="decl" id="forall₂_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L657-L658">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_swap"><span class="name">forall₂_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₁ : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₂ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₁ : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₂ : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">i₁</span> : <span class="fn">ι₁</span>) (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>) (<span class="fn">i₂</span> : <span class="fn">ι₂</span>) (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">i₂</span> : <span class="fn">ι₂</span>) (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>) (<span class="fn">i₁</span> : <span class="fn">ι₁</span>) (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></div></div></div></div><div class="decl" id="imp_forall_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L663-L664">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_forall_iff"><span class="name">imp_forall_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p</span> → <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></span></div></div><p>We intentionally restrict the type of <code>α</code> in this lemma so that this is a safer to use in simp
than <code><a href="../.././Mathlib/Logic/Basic.html#forall_swap">forall_swap</a></code>.</p></div></div><div class="decl" id="exists_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L667-L668">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_swap"><span class="name">exists_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></span></div></div></div></div><div class="decl" id="not_forall_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L686-L686">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall_not"><span class="name">not_forall_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="forall_or_exists_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L694-L695">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_exists_not"><span class="name">forall_or_exists_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_or_forall_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L697-L698">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_or_forall_not"><span class="name">exists_or_forall_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_imp_iff_exists_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L700-L703">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_imp_iff_exists_imp"><span class="name">forall_imp_iff_exists_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[ha : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="forall_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L707-L707">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_iff"><span class="name">forall_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">α</span> → <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="forall_true_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L712-L713">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_iff'"><span class="name">forall_true_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="forall₂_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L717-L717">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_true_iff"><span class="name">forall₂_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././Init/Prelude.html#True">True</a></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="forall₃_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L721-L722">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₃_true_iff"><span class="name">forall₃_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_3</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././Init/Prelude.html#True">True</a></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="exists_unique_iff_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L725-L727">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_iff_exists"><span class="name">exists_unique_iff_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃! (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="exists_unique_const"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L734-L735">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_const"><span class="name">exists_unique_const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Sort</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[i : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃! (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Decidable.and_forall_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L744-L746">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.and_forall_ne"><span class="name">Decidable</span>.<span class="name">and_forall_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="and_forall_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L749-L750">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_forall_ne"><span class="name">and_forall_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Ne.ne_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L753-L754">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ne_or_ne"><span class="name">Ne</span>.<span class="name">ne_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(z : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">z</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">y</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">z</span></span></span></div></div></div></div><div class="decl" id="exists_unique_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L757-L758">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_eq"><span class="name">exists_unique_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃! (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="exists_unique_eq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L761-L762">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_eq'"><span class="name">exists_unique_eq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃! (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L766-L766">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply'"><span class="name">exists_apply_eq_apply'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a' : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L770-L770">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq"><span class="name">exists_apply_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="exists_exists_and_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L772-L774">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_and_eq_and"><span class="name">exists_exists_and_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">b</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>)</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_exists_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L777-L779">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_eq_and"><span class="name">exists_exists_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="exists_exists_and_exists_and_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L782-L786">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_and_exists_and_eq_and"><span class="name">exists_exists_and_exists_and_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">c</span> : <span class="fn">γ</span>), <span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">c</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="exists_exists_exists_and_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L788-L792">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_exists_and_eq"><span class="name">exists_exists_exists_and_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">c</span> : <span class="fn">γ</span>), <span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">c</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_or_eq_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L794-L794">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_or_eq_left"><span class="name">exists_or_eq_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="exists_or_eq_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L797-L797">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_or_eq_right"><span class="name">exists_or_eq_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span></span></div></div></div></div><div class="decl" id="exists_or_eq_left'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L800-L800">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_or_eq_left'"><span class="name">exists_or_eq_left'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="exists_or_eq_right'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L803-L803">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_or_eq_right'"><span class="name">exists_or_eq_right'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="forall_apply_eq_imp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L806-L807">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_apply_eq_imp_iff'"><span class="name">forall_apply_eq_imp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="forall_eq_apply_imp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L812-L813">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_eq_apply_imp_iff'"><span class="name">forall_eq_apply_imp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="exists_eq_right'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L819-L819">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_eq_right'"><span class="name">exists_eq_right'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="exists₂_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L824-L826">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists₂_comm"><span class="name">exists₂_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₁ : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₂ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₁ : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₂ : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">i₁</span> : <span class="fn">ι₁</span>), <span class="fn">∃ (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>), <span class="fn">∃ (<span class="fn">i₂</span> : <span class="fn">ι₂</span>), <span class="fn">∃ (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn">∃ (<span class="fn">i₂</span> : <span class="fn">ι₂</span>), <span class="fn">∃ (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>), <span class="fn">∃ (<span class="fn">i₁</span> : <span class="fn">ι₁</span>), <span class="fn">∃ (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="And.exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L829-L830">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#And.exists"><span class="name">And</span>.<span class="name">exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span>), <span class="fn"><span class="fn">f</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">hp</span> : <span class="fn">p</span>), <span class="fn">∃ (<span class="fn">hq</span> : <span class="fn">q</span>), <span class="fn"><span class="fn">f</span> <span class="fn">⋯</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_or_of_or_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L833-L833">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_of_or_forall"><span class="name">forall_or_of_or_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Decidable.forall_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L837-L840">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.forall_or_left"><span class="name">Decidable</span>.<span class="name">forall_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L843-L844">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_left"><span class="name">forall_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="Decidable.forall_or_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L848-L849">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.forall_or_right"><span class="name">Decidable</span>.<span class="name">forall_or_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="forall_or_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L852-L853">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_right"><span class="name">forall_or_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="exists_unique_prop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L856-L856">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_prop"><span class="name">exists_unique_prop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃! (<span class="fn">x</span> : <span class="fn">p</span>), <span class="fn">q</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="exists_unique_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L859-L859">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_false"><span class="name">exists_unique_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∃! (<span class="fn">x</span> : <span class="fn">α</span>), <a href="../.././Init/Prelude.html#False">False</a></span></span></div></div></div></div><div class="decl" id="Exists.fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L862-L863">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.fst"><span class="name">Exists</span>.<span class="name">fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">b</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span> → <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Exists.snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L866-L867">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.snd"><span class="name">Exists</span>.<span class="name">snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">b</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Prop.exists_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L870-L872">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Prop.exists_iff"><span class="name">Prop</span>.<span class="name">exists_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">h</span> : <a href="../.././foundational_types.html">Prop</a>), <span class="fn"><span class="fn">p</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span></span></span></div></div></div></div><div class="decl" id="Prop.forall_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L874-L875">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Prop.forall_iff"><span class="name">Prop</span>.<span class="name">forall_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">h</span> : <a href="../.././foundational_types.html">Prop</a>), <span class="fn"><span class="fn">p</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span></span></span></div></div></div></div><div class="decl" id="exists_prop_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L877-L878">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_prop_of_true"><span class="name">exists_prop_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">p</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">h'</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h'</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="exists_iff_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L881-L882">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_iff_of_forall"><span class="name">exists_iff_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="exists_unique_prop_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L885-L886">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_prop_of_true"><span class="name">exists_unique_prop_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">p</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃! (<span class="fn">h'</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h'</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="exists_prop_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L891-L892">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_prop_of_false"><span class="name">exists_prop_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∃ (<span class="fn">h'</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h'</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_prop_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L896-L898">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_prop_congr"><span class="name">exists_prop_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q' : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hq : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hp : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">q</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="exists_prop_congr'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L902-L904">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_prop_congr'"><span class="name">exists_prop_congr'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q' : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hq : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hp : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">q</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="exists_true_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L908-L909">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_true_left"><span class="name">exists_true_left</span></a></span><span class="decl_args">
<span class="fn">(p : <span class="fn"><a href="../.././Init/Prelude.html#True">True</a> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#True">True</a>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True.intro">True.intro</a></span></span></div></div><p>See <code>IsEmpty.<a href="../.././Mathlib/Logic/Basic.html#Prop.exists_iff">exists_iff</a></code> for the <code><a href="../.././Init/Prelude.html#False">False</a></code> version.</p></div></div><div class="decl" id="forall_prop_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L914-L916">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_prop_congr"><span class="name">forall_prop_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q' : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hq : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hp : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="forall_prop_congr'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L921-L923">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_prop_congr'"><span class="name">forall_prop_congr'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q' : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hq : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hp : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="forall_true_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L927-L928">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_left"><span class="name">forall_true_left</span></a></span><span class="decl_args">
<span class="fn">(p : <span class="fn"><a href="../.././Init/Prelude.html#True">True</a> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#True">True</a>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True.intro">True.intro</a></span></span></div></div><p>See <code>IsEmpty.<a href="../.././Mathlib/Logic/Basic.html#Prop.forall_iff">forall_iff</a></code> for the <code><a href="../.././Init/Prelude.html#False">False</a></code> version.</p></div></div><div class="decl" id="ExistsUnique.elim₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L931-L936">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ExistsUnique.elim₂"><span class="name">ExistsUnique</span>.<span class="name">elim₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₂ : <span class="fn">∃! (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃! (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">y</span> : <span class="fn">α</span>) (<span class="fn">hy</span> : <span class="fn"><span class="fn">p</span> <span class="fn">y</span></span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">y</span> <span class="fn">hy</span></span> → <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></span></span>)</span> → <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span></div></div></div></div><div class="decl" id="ExistsUnique.intro₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L939-L943">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ExistsUnique.intro₂"><span class="name">ExistsUnique</span>.<span class="name">intro₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(hp : <span class="fn"><span class="fn">p</span> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hq : <span class="fn"><span class="fn">q</span> <span class="fn">w</span> <span class="fn">hp</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">y</span> : <span class="fn">α</span>) (<span class="fn">hy</span> : <span class="fn"><span class="fn">p</span> <span class="fn">y</span></span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">y</span> <span class="fn">hy</span></span> → <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">w</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃! (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃! (<span class="fn">hx</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">hx</span></span></span></span></div></div></div></div><div class="decl" id="ExistsUnique.exists₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L946-L948">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ExistsUnique.exists₂"><span class="name">ExistsUnique</span>.<span class="name">exists₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∃! (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃! (<span class="fn">hx</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">hx</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">hx</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">hx</span></span></span></span></div></div></div></div><div class="decl" id="ExistsUnique.unique₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L951-L955">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ExistsUnique.unique₂"><span class="name">ExistsUnique</span>.<span class="name">unique₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∃! (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃! (<span class="fn">hx</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">hx</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{y₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y₂ : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hpy₁ : <span class="fn"><span class="fn">p</span> <span class="fn">y₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hqy₁ : <span class="fn"><span class="fn">q</span> <span class="fn">y₁</span> <span class="fn">hpy₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpy₂ : <span class="fn"><span class="fn">p</span> <span class="fn">y₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hqy₂ : <span class="fn"><span class="fn">q</span> <span class="fn">y₂</span> <span class="fn">hpy₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">y₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y₂</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Classical-lemmas">Classical lemmas <a class="hover-link" href="#Classical-lemmas">#</a></h3></div><div class="decl" id="Classical.dec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L967-L967">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.dec"><span class="name">Classical</span>.<span class="name">dec</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span></div></div><p>Any prop <code>p</code> is decidable classically. A shorthand for <code><a href="../.././Init/Classical.html#Classical.propDecidable">Classical.propDecidable</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.dec">Classical.dec</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.dec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decPred"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L971-L971">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decPred"><span class="name">Classical</span>.<span class="name">decPred</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span></div></div><p>Any predicate <code>p</code> is decidable classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decPred">Classical.decPred</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.decPred" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decRel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L975-L975">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decRel"><span class="name">Classical</span>.<span class="name">decRel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">p</span></span></div></div><p>Any relation <code>p</code> is decidable classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decRel">Classical.decRel</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.decRel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L979-L979">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decEq"><span class="name">Classical</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span></div></div><p>Any type <code>α</code> has decidable equality classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decEq">Classical.decEq</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.existsCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L985-L986">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.existsCases"><span class="name">Classical</span>.<span class="name">existsCases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(H0 : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">C</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>Construct a function from a default value <code>H0</code>, and a function to use if there exists a value
satisfying the predicate.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.existsCases">Classical.existsCases</a> <span class="fn">H0</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span> then <span class="fn"><span class="fn">H</span> <span class="fn">⋯</span> <span class="fn">⋯</span></span> else <span class="fn">H0</span></span></span></li></ul></details><details id="instances-for-list-Classical.existsCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.some_spec₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L989-L990">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.some_spec₂"><span class="name">Classical</span>.<span class="name">some_spec₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpq : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">q</span> <span class="fn">(<span class="fn"><a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span></span>)</span></span></div></div></div></div><div class="decl" id="Classical.subtype_of_exists"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L994-L995">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.subtype_of_exists"><span class="name">Classical</span>.<span class="name">subtype_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">{ <span class="fn">x</span> : <span class="fn">α</span> // <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span> }</span></div></div><p>A version of <code><a href="../.././Init/Classical.html#Classical.indefiniteDescription">Classical.indefiniteDescription</a></code> which is definitionally equal to a pair</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.subtype_of_exists">Classical.subtype_of_exists</a> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn"><a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span></span>, <span class="fn">property</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-Classical.subtype_of_exists" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.byContradiction'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L999-L1000">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'"><span class="name">Classical</span>.<span class="name">byContradiction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><span class="fn">α</span> → <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A version of <code>byContradiction</code> that uses types instead of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'">Classical.byContradiction'</a> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Classical.choice">Classical.choice</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Classical.byContradiction'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.choice_of_byContradiction'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1004-L1005">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choice_of_byContradiction'"><span class="name">Classical</span>.<span class="name">choice_of_byContradiction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(contra : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><span class="fn">α</span> → <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span> → <span class="fn">α</span></span></div></div><p><code>classical.<a href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'">byContradiction'</a></code> is equivalent to lean's axiom <code>classical.choice</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.choice_of_byContradiction'">Classical.choice_of_byContradiction'</a> <span class="fn">contra</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">contra</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Classical.choice_of_byContradiction'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Exists.classicalRecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1014-L1015">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.classicalRecOn"><span class="name">Exists</span>.<span class="name">classicalRecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">C</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>This function has the same type as <code><a href="../.././Init/Core.html#Exists.recOn">Exists.recOn</a></code>, and can be used to case on an equality,
but <code><a href="../.././Init/Core.html#Exists.recOn">Exists.recOn</a></code> can only eliminate into Prop, while this version eliminates into any universe
using the axiom of choice.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Exists.classicalRecOn">Exists.classicalRecOn</a> <span class="fn">h</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">H</span> <span class="fn">(<span class="fn"><a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Exists.classicalRecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-bounded-quantifiers">Declarations about bounded quantifiers <a class="hover-link" href="#Declarations-about-bounded-quantifiers">#</a></h3></div><div class="decl" id="bex_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1023-L1024">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_def"><span class="name">bex_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="BEx.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1027-L1028">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.elim"><span class="name">BEx</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> → <span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h</span></span> → <span class="fn">b</span></span></span>)</span> → <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="BEx.intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1031-L1032">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.intro"><span class="name">BEx</span>.<span class="name">intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="ball_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1035-L1036">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_congr"><span class="name">ball_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="bex_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1039-L1040">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_congr"><span class="name">bex_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="bex_eq_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1043-L1044">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_eq_left"><span class="name">bex_eq_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="BAll.imp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1047-L1048">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BAll.imp_right"><span class="name">BAll</span>.<span class="name">imp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="BEx.imp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1051-L1052">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.imp_right"><span class="name">BEx</span>.<span class="name">imp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="BAll.imp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1055-L1056">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BAll.imp_left"><span class="name">BAll</span>.<span class="name">imp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="BEx.imp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1059-L1060">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.imp_left"><span class="name">BEx</span>.<span class="name">imp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="ball_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1063-L1063">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_of_forall"><span class="name">ball_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="forall_of_ball"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1066-L1066">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_of_ball"><span class="name">forall_of_ball</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="bex_of_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1069-L1070">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_of_exists"><span class="name">bex_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_of_bex"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1073-L1074">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_of_bex"><span class="name">exists_of_bex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="bex_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1077-L1077">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_imp"><span class="name">bex_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="not_bex"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1080-L1080">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_bex"><span class="name">not_bex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="not_ball_of_bex_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1083-L1084">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_ball_of_bex_not"><span class="name">not_ball_of_bex_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span>)</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="Decidable.not_ball"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1088-L1091">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.not_ball"><span class="name">Decidable</span>.<span class="name">not_ball</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>) → <span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>)</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></span></div></div></div></div><div class="decl" id="not_ball"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1094-L1094">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_ball"><span class="name">not_ball</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></span></div></div></div></div><div class="decl" id="ball_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1097-L1098">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_true_iff"><span class="name">ball_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././Init/Prelude.html#True">True</a></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="ball_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1101-L1102">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_and"><span class="name">ball_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="bex_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1105-L1106">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_or"><span class="name">bex_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></span></div></div></div></div><div class="decl" id="ball_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1109-L1110">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_or_left"><span class="name">ball_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span></span></span></div></div></div></div><div class="decl" id="bex_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1113-L1116">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_or_left"><span class="name">bex_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span></span></span></div></div></div></div><div class="decl" id="dite_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1128-L1129">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_iff"><span class="name">dite_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn"><span class="fn">B</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1132-L1133">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_iff"><span class="name">ite_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="eq_ite_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1136-L1137">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_ite_iff"><span class="name">eq_ite_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn">b</span> else <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="dite_eq_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1139-L1141">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_iff'"><span class="name">dite_eq_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn"><span class="fn">B</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_eq_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1144-L1144">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_iff'"><span class="name">ite_eq_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">P</span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span>)</span></span></span></div></div></div></div><div class="decl" id="dite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1152-L1154">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_ne_left_iff"><span class="name">dite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span></span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="dite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1157-L1158">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_ne_right_iff"><span class="name">dite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>) =&gt; <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="ite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1161-L1162">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ne_left_iff"><span class="name">ite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="ite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1165-L1166">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ne_right_iff"><span class="name">ite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Ne.dite_eq_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1169-L1170">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_eq_left_iff"><span class="name">Ne</span>.<span class="name">dite_eq_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span></span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="Ne.dite_eq_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1173-L1174">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_eq_right_iff"><span class="name">Ne</span>.<span class="name">dite_eq_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>) =&gt; <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.ite_eq_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1177-L1178">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_eq_left_iff"><span class="name">Ne</span>.<span class="name">ite_eq_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="Ne.ite_eq_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1181-L1182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_eq_right_iff"><span class="name">Ne</span>.<span class="name">ite_eq_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.dite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1185-L1186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_ne_left_iff"><span class="name">Ne</span>.<span class="name">dite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span></span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.dite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1189-L1190">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_ne_right_iff"><span class="name">Ne</span>.<span class="name">dite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>) =&gt; <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="Ne.ite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1193-L1194">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_ne_left_iff"><span class="name">Ne</span>.<span class="name">ite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.ite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1197-L1198">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_ne_right_iff"><span class="name">Ne</span>.<span class="name">ite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="dite_eq_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1205-L1206">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_or_eq"><span class="name">dite_eq_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_eq_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1209-L1210">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_or_eq"><span class="name">ite_eq_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="apply_dite₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1215-L1218">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#apply_dite₂"><span class="name">apply_dite₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><span class="fn">P</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(d : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">c</span> <span class="fn">d</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn">a</span> <span class="fn">h</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">c</span> <span class="fn">h</span></span>)</span></span> else <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn">b</span> <span class="fn">h</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">d</span> <span class="fn">h</span></span>)</span></span></span></span></div></div><p>A two-argument function applied to two <code><a href="../.././Init/Prelude.html#dite">dite</a></code>s is a <code><a href="../.././Init/Prelude.html#dite">dite</a></code> of that two-argument function
applied to each of the branches.</p></div></div><div class="decl" id="apply_ite₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1223-L1225">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#apply_ite₂"><span class="name">apply_ite₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(d : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">c</span> else <span class="fn">d</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">c</span></span> else <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">d</span></span></span></span></div></div><p>A two-argument function applied to two <code><a href="../.././Init/Prelude.html#ite">ite</a></code>s is a <code><a href="../.././Init/Prelude.html#ite">ite</a></code> of that two-argument function
applied to each of the branches.</p></div></div><div class="decl" id="dite_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1230-L1231">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_apply"><span class="name">dite_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">P</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">h</span> <span class="fn">a</span></span> else <span class="fn"><span class="fn">g</span> <span class="fn">h</span> <span class="fn">a</span></span></span></span></div></div><p>A 'dite' producing a <code>Pi</code> type <code>Π a, σ a</code>, applied to a value <code>a : α</code> is a <code><a href="../.././Init/Prelude.html#dite">dite</a></code> that applies
either branch to <code>a</code>.</p></div></div><div class="decl" id="ite_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1236-L1237">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_apply"><span class="name">ite_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">f</span> else <span class="fn">g</span></span>)</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> else <span class="fn"><span class="fn">g</span> <span class="fn">a</span></span></span></span></div></div><p>A 'ite' producing a <code>Pi</code> type <code>Π a, σ a</code>, applied to a value <code>a : α</code> is a <code><a href="../.././Init/Prelude.html#ite">ite</a></code> that applies
either branch to <code>a</code>.</p></div></div><div class="decl" id="ite_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1240-L1241">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_and"><span class="name">ite_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span></span> then <span class="fn">a</span> else <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn">if <span class="fn">Q</span> then <span class="fn">a</span> else <span class="fn">b</span></span> else <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="dite_dite_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1244-L1249">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_dite_comm"><span class="name">dite_dite_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn">Q</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span> → <span class="fn">α</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">P</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">if p : <span class="fn">P</span> then <span class="fn"><span class="fn">A</span> <span class="fn">p</span></span> else <span class="fn">if q : <span class="fn">Q</span> then <span class="fn"><span class="fn">B</span> <span class="fn">q</span></span> else <span class="fn"><span class="fn">C</span> <span class="fn">p</span> <span class="fn">q</span></span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if q : <span class="fn">Q</span> then <span class="fn"><span class="fn">B</span> <span class="fn">q</span></span> else <span class="fn">if p : <span class="fn">P</span> then <span class="fn"><span class="fn">A</span> <span class="fn">p</span></span> else <span class="fn"><span class="fn">C</span> <span class="fn">p</span> <span class="fn">q</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_ite_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1252-L1255">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ite_comm"><span class="name">ite_ite_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">P</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">if <span class="fn">Q</span> then <span class="fn">b</span> else <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">Q</span> then <span class="fn">b</span> else <span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="ite_prop_iff_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1260-L1261">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_prop_iff_or"><span class="name">ite_prop_iff_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">Q</span> else <span class="fn">R</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">R</span></span></span></span></div></div></div></div><div class="decl" id="dite_prop_iff_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1263-L1265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_prop_iff_or"><span class="name">dite_prop_iff_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn"><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">Q</span> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">∃ (<span class="fn">p</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">Q</span> <span class="fn">p</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">p</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">R</span> <span class="fn">p</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_prop_iff_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1268-L1269">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_prop_iff_and"><span class="name">ite_prop_iff_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">Q</span> else <span class="fn">R</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">P</span> → <span class="fn">Q</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">R</span></span>)</span></span></span></div></div></div></div><div class="decl" id="dite_prop_iff_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1271-L1273">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_prop_iff_and"><span class="name">dite_prop_iff_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn"><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">Q</span> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">Q</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">R</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="if_true_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1275-L1275">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#if_true_right"><span class="name">if_true_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">Q</span> else <a href="../.././Init/Prelude.html#True">True</a></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">Q</span></span></span></div></div></div></div><div class="decl" id="if_true_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1278-L1278">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#if_true_left"><span class="name">if_true_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <a href="../.././Init/Prelude.html#True">True</a> else <span class="fn">Q</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">Q</span></span></span></div></div></div></div><div class="decl" id="if_false_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1281-L1281">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#if_false_right"><span class="name">if_false_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <span class="fn">Q</span> else <a href="../.././Init/Prelude.html#False">False</a></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span></span></span></div></div></div></div><div class="decl" id="if_false_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1284-L1284">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#if_false_left"><span class="name">if_false_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">if <span class="fn">P</span> then <a href="../.././Init/Prelude.html#False">False</a> else <span class="fn">Q</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span></span></span></div></div></div></div><div class="decl" id="not_beq_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1289-L1290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_beq_of_ne"><span class="name">not_beq_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ne : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="beq_eq_decide"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1292-L1294">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_eq_decide"><span class="name">beq_eq_decide</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span></span></div></div></div></div><div class="decl" id="beq_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1297-L1304">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_ext"><span class="name">beq_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(inst1 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(inst2 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x </span>y : <span class="fn">α</span>), <span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span></span></div></div></div></div><div class="decl" id="lawful_beq_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Logic/Basic.lean#L1306-L1311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#lawful_beq_subsingleton"><span class="name">lawful_beq_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(inst1 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(inst2 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>