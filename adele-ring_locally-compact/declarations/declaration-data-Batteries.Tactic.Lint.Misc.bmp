{"name":"Batteries.Tactic.Lint.Misc","instances":[],"imports":["Init","Lean.Util.CollectLevelParams","Lean.Util.ForEachExpr","Lean.Meta.ForEachExpr","Lean.Meta.GlobalInstances","Lean.Meta.Check","Lean.Util.Recognizers","Lean.DocString","Batteries.Tactic.Lint.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/batteries/blob/e7897807913fafdab31b01b9f627550bcc96cff2/Batteries/Tactic/Lint/Misc.lean#L269-L281","name":"Std.Tactic.Lint.explicitVarsOfIff","line":269,"kind":"def","docLink":"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.explicitVarsOfIff","doc":"A linter for checking if variables appearing on both sides of an iff are explicit. Ideally, such\nvariables should be implicit instead.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.explicitVarsOfIff\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lint</span>.<span class=\"name\">explicitVarsOfIff</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Tactic/Lint/Basic.html#Std.Tactic.Lint.Linter\">Std.Tactic.Lint.Linter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/batteries/blob/e7897807913fafdab31b01b9f627550bcc96cff2/Batteries/Tactic/Lint/Misc.lean#L243-L263","name":"Std.Tactic.Lint.unusedHavesSuffices","line":243,"kind":"def","docLink":"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.unusedHavesSuffices","doc":"A linter for checking that declarations don't have unused term mode have statements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.unusedHavesSuffices\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lint</span>.<span class=\"name\">unusedHavesSuffices</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Tactic/Lint/Basic.html#Std.Tactic.Lint.Linter\">Std.Tactic.Lint.Linter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/batteries/blob/e7897807913fafdab31b01b9f627550bcc96cff2/Batteries/Tactic/Lint/Misc.lean#L230-L240","name":"Std.Tactic.Lint.findUnusedHaves","line":230,"kind":"def","docLink":"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.findUnusedHaves","doc":"Return a list of unused `let_fun` terms in an expression.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.findUnusedHaves\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lint</span>.<span class=\"name\">findUnusedHaves</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/batteries/blob/e7897807913fafdab31b01b9f627550bcc96cff2/Batteries/Tactic/Lint/Misc.lean#L208-L225","name":"Std.Tactic.Lint.synTaut","line":208,"kind":"def","docLink":"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.synTaut","doc":"A linter for checking that declarations aren't syntactic tautologies.\nChecks whether a lemma is a declaration of the form `∀ a b ... z, e₁ = e₂`\nwhere `e₁` and `e₂` are identical exprs.\nWe call declarations of this form syntactic tautologies.\nSuch lemmas are (mostly) useless and sometimes introduced unintentionally when proving basic facts\nwith rfl when elaboration results in a different term than the user intended. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.synTaut\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lint</span>.<span class=\"name\">synTaut</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Tactic/Lint/Basic.html#Std.Tactic.Lint.Linter\">Std.Tactic.Lint.Linter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/batteries/blob/e7897807913fafdab31b01b9f627550bcc96cff2/Batteries/Tactic/Lint/Misc.lean#L183-L200","name":"Std.Tactic.Lint.checkUnivs","line":183,"kind":"def","docLink":"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.checkUnivs","doc":"A linter for checking that there are no bad `max u v` universe levels.\nChecks whether all universe levels `u` in the type of `d` are \"good\".\nThis means that `u` either occurs in a `level` of `d` by itself, or (recursively)\nwith only other good levels.\nWhen this fails, usually this means that there is a level `max u v`, where neither `u` nor `v`\noccur by themselves in a level. It is ok if *one* of `u` or `v` never occurs alone. For example,\n`(α : Type u) (β : Type (max u v))` is a occasionally useful method of saying that `β` lives in\na higher universe level than `α`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.checkUnivs\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lint</span>.<span class=\"name\">checkUnivs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Tactic/Lint/Basic.html#Std.Tactic.Lint.Linter\">Std.Tactic.Lint.Linter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/batteries/blob/e7897807913fafdab31b01b9f627550bcc96cff2/Batteries/Tactic/Lint/Misc.lean#L129-L137","name":"Std.Tactic.Lint.checkType","line":129,"kind":"def","docLink":"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.checkType","doc":"A linter for checking whether statements of declarations are well-typed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.checkType\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lint</span>.<span class=\"name\">checkType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Tactic/Lint/Basic.html#Std.Tactic.Lint.Linter\">Std.Tactic.Lint.Linter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/batteries/blob/e7897807913fafdab31b01b9f627550bcc96cff2/Batteries/Tactic/Lint/Misc.lean#L109-L126","name":"Std.Tactic.Lint.defLemma","line":109,"kind":"def","docLink":"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.defLemma","doc":"A linter for checking whether the correct declaration constructor (definition or theorem)\nhas been used. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.defLemma\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lint</span>.<span class=\"name\">defLemma</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Tactic/Lint/Basic.html#Std.Tactic.Lint.Linter\">Std.Tactic.Lint.Linter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/batteries/blob/e7897807913fafdab31b01b9f627550bcc96cff2/Batteries/Tactic/Lint/Misc.lean#L88-L105","name":"Std.Tactic.Lint.docBlameThm","line":88,"kind":"def","docLink":"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.docBlameThm","doc":"A linter for checking theorem doc strings. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.docBlameThm\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lint</span>.<span class=\"name\">docBlameThm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Tactic/Lint/Basic.html#Std.Tactic.Lint.Linter\">Std.Tactic.Lint.Linter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/batteries/blob/e7897807913fafdab31b01b9f627550bcc96cff2/Batteries/Tactic/Lint/Misc.lean#L64-L85","name":"Std.Tactic.Lint.docBlame","line":64,"kind":"def","docLink":"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.docBlame","doc":"A linter for checking definition doc strings. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.docBlame\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lint</span>.<span class=\"name\">docBlame</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Tactic/Lint/Basic.html#Std.Tactic.Lint.Linter\">Std.Tactic.Lint.Linter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/batteries/blob/e7897807913fafdab31b01b9f627550bcc96cff2/Batteries/Tactic/Lint/Misc.lean#L39-L61","name":"Std.Tactic.Lint.unusedArguments","line":39,"kind":"def","docLink":"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.unusedArguments","doc":"A linter for checking for unused arguments.\nWe skip all declarations that contain `sorry` in their value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.unusedArguments\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lint</span>.<span class=\"name\">unusedArguments</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Tactic/Lint/Basic.html#Std.Tactic.Lint.Linter\">Std.Tactic.Lint.Linter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/batteries/blob/e7897807913fafdab31b01b9f627550bcc96cff2/Batteries/Tactic/Lint/Misc.lean#L26-L35","name":"Std.Tactic.Lint.dupNamespace","line":26,"kind":"def","docLink":"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.dupNamespace","doc":"A linter for checking whether a declaration has a namespace twice consecutively in its name. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Lint/Misc.html#Std.Tactic.Lint.dupNamespace\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lint</span>.<span class=\"name\">dupNamespace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Tactic/Lint/Basic.html#Std.Tactic.Lint.Linter\">Std.Tactic.Lint.Linter</a></div></div>"}]}