{"name":"Init.Data.Int.DivMod","instances":[{"typeNames":["Int"],"name":"Int.instDivInt","className":"Div"},{"typeNames":["Int"],"name":"Int.instModInt","className":"Mod"}],"imports":["Init.Data.Int.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Data/Int/DivMod.lean#L190-L199","name":"Int.bdiv","line":190,"kind":"def","docLink":"./Init/Data/Int/DivMod.html#Int.bdiv","doc":"Balanced division.  This returns the unique integer so that\n`b * (Int.bdiv a b) + Int.bmod a b = a`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Int/DivMod.html#Int.bdiv\"><span class=\"name\">Int</span>.<span class=\"name\">bdiv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(m : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Data/Int/DivMod.lean#L179-L184","name":"Int.bmod","line":179,"kind":"def","docLink":"./Init/Data/Int/DivMod.html#Int.bmod","doc":"Balanced modulus.  This version of Integer modulus uses the\nbalanced rounding convention, which guarantees that\n`m/2 ≤ bmod x m < m/2` for `m ≠ 0` and `bmod x m` is congruent\nto `x` modulo `m`.\n\nIf `m = 0`, then `bmod x m = x`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Int/DivMod.html#Int.bmod\"><span class=\"name\">Int</span>.<span class=\"name\">bmod</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(m : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Data/Int/DivMod.lean#L158-L159","name":"Int.instModInt","line":158,"kind":"instance","docLink":"./Init/Data/Int/DivMod.html#Int.instModInt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Int/DivMod.html#Int.instModInt\"><span class=\"name\">Int</span>.<span class=\"name\">instModInt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Mod\">Mod</a> <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Data/Int/DivMod.lean#L156-L157","name":"Int.instDivInt","line":156,"kind":"instance","docLink":"./Init/Data/Int/DivMod.html#Int.instDivInt","doc":"The Div and Mod syntax uses ediv and emod for compatibility with SMTLIb and mathematical\nreasoning tends to be easier.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Int/DivMod.html#Int.instDivInt\"><span class=\"name\">Int</span>.<span class=\"name\">instDivInt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Div\">Div</a> <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Data/Int/DivMod.lean#L148-L150","name":"Int.emod","line":148,"kind":"def","docLink":"./Init/Data/Int/DivMod.html#Int.emod","doc":"Integer modulus. This version of `Int.mod` uses the E-rounding convention\n(euclidean division), in which `Int.emod x y` satisfies `0 ≤ emod x y < natAbs y` for `y ≠ 0`\nand `Int.ediv` is the unique function satisfying `emod x y + (ediv x y) * y = x`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Int/DivMod.html#Int.emod\"><span class=\"name\">Int</span>.<span class=\"name\">emod</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Data/Int/DivMod.lean#L135-L140","name":"Int.ediv","line":135,"kind":"def","docLink":"./Init/Data/Int/DivMod.html#Int.ediv","doc":"Integer division. This version of `Int.div` uses the E-rounding convention\n(euclidean division), in which `Int.emod x y` satisfies `0 ≤ mod x y < natAbs y` for `y ≠ 0`\nand `Int.ediv` is the unique function satisfying `emod x y + (ediv x y) * y = x`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Int/DivMod.html#Int.ediv\"><span class=\"name\">Int</span>.<span class=\"name\">ediv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Data/Int/DivMod.lean#L118-L123","name":"Int.fmod","line":118,"kind":"def","docLink":"./Init/Data/Int/DivMod.html#Int.fmod","doc":"Integer modulus. This version of `Int.mod` uses the F-rounding convention\n(flooring division), in which `Int.fdiv x y` satisfies `fdiv x y = floor (x / y)`\nand `Int.fmod` is the unique function satisfying `fmod x y + (fdiv x y) * y = x`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Int/DivMod.html#Int.fmod\"><span class=\"name\">Int</span>.<span class=\"name\">fmod</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Data/Int/DivMod.lean#L105-L111","name":"Int.fdiv","line":105,"kind":"def","docLink":"./Init/Data/Int/DivMod.html#Int.fdiv","doc":"Integer division. This version of division uses the F-rounding convention\n(flooring division), in which `Int.fdiv x y` satisfies `fdiv x y = floor (x / y)`\nand `Int.fmod` is the unique function satisfying `fmod x y + (fdiv x y) * y = x`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Int/DivMod.html#Int.fdiv\"><span class=\"name\">Int</span>.<span class=\"name\">fdiv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Data/Int/DivMod.lean#L90-L94","name":"Int.mod","line":90,"kind":"def","docLink":"./Init/Data/Int/DivMod.html#Int.mod","doc":"Integer modulo. This function uses the\n[*\"T-rounding\"*][t-rounding] (**T**runcation-rounding) convention\nto pair with `Int.div`, meaning that `a % b + b * (a / b) = a`\nunconditionally (see [`Int.mod_add_div`][theo mod_add_div]). In\nparticular, `a % 0 = a`.\n\n[t-rounding]: https://dl.acm.org/doi/pdf/10.1145/128861.128862\n[theo mod_add_div]: https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.mod_add_div#doc\n\nExamples:\n\n```\n#eval (7 : Int) % (0 : Int) -- 7\n#eval (0 : Int) % (7 : Int) -- 0\n\n#eval (12 : Int) % (6 : Int) -- 0\n#eval (12 : Int) % (-6 : Int) -- 0\n#eval (-12 : Int) % (6 : Int) -- 0\n#eval (-12 : Int) % (-6 : Int) -- 0\n\n#eval (12 : Int) % (7 : Int) -- 5\n#eval (12 : Int) % (-7 : Int) -- 5\n#eval (-12 : Int) % (7 : Int) -- 2\n#eval (-12 : Int) % (-7 : Int) -- 2\n```\n\nImplemented by efficient native code. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Int/DivMod.html#Int.mod\"><span class=\"name\">Int</span>.<span class=\"name\">mod</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Data/Int/DivMod.lean#L56-L60","name":"Int.div","line":56,"kind":"def","docLink":"./Init/Data/Int/DivMod.html#Int.div","doc":"`div` uses the [*\"T-rounding\"*][t-rounding]\n(**T**runcation-rounding) convention, meaning that it rounds toward\nzero. Also note that division by zero is defined to equal zero.\n\n  The relation between integer division and modulo is found in\n  `Int.mod_add_div` which states that\n  `a % b + b * (a / b) = a`, unconditionally.\n\n  [t-rounding]: https://dl.acm.org/doi/pdf/10.1145/128861.128862 [theo\n  mod_add_div]:\n  https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.mod_add_div#doc\n\n  Examples:\n\n  ```\n  #eval (7 : Int) / (0 : Int) -- 0\n  #eval (0 : Int) / (7 : Int) -- 0\n\n  #eval (12 : Int) / (6 : Int) -- 2\n  #eval (12 : Int) / (-6 : Int) -- -2\n  #eval (-12 : Int) / (6 : Int) -- -2\n  #eval (-12 : Int) / (-6 : Int) -- 2\n\n  #eval (12 : Int) / (7 : Int) -- 1\n  #eval (12 : Int) / (-7 : Int) -- -1\n  #eval (-12 : Int) / (7 : Int) -- -1\n  #eval (-12 : Int) / (-7 : Int) -- 1\n  ```\n\n  Implemented by efficient native code.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Int/DivMod.html#Int.div\"><span class=\"name\">Int</span>.<span class=\"name\">div</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></span></div></div>"}]}