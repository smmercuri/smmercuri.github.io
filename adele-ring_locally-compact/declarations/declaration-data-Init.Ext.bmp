{"name":"Init.Ext","instances":[],"imports":["Init.TacticsExtra","Init.RCases"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L113-L113","name":"Unit.ext","line":113,"kind":"theorem","docLink":"./Init/Ext.html#Unit.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#Unit.ext\"><span class=\"name\">Unit</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Init/Prelude.html#Unit\">Unit</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Init/Prelude.html#Unit\">Unit</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L112-L112","name":"PUnit.ext","line":112,"kind":"theorem","docLink":"./Init/Ext.html#PUnit.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#PUnit.ext\"><span class=\"name\">PUnit</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Init/Prelude.html#PUnit\">PUnit</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Init/Prelude.html#PUnit\">PUnit</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L109-L110","name":"PSigma.ext","line":109,"kind":"theorem","docLink":"./Init/Ext.html#PSigma.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#PSigma.ext\"><span class=\"name\">PSigma</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ {<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1} {<span class=\"fn\">β</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> u_2</span>} {<span class=\"fn\">x </span>y : <span class=\"fn\"><a href=\"./Init/Core.html#PSigma\">PSigma</a> <span class=\"fn\">β</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.fst</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.fst</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#HEq\">HEq</a> <span class=\"fn\"><span class=\"fn\">x</span>.snd</span> <span class=\"fn\"><span class=\"fn\">y</span>.snd</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L106-L107","name":"Sigma.ext","line":106,"kind":"theorem","docLink":"./Init/Ext.html#Sigma.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#Sigma.ext\"><span class=\"name\">Sigma</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ {<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1} {<span class=\"fn\">β</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Type</a> u_2</span>} {<span class=\"fn\">x </span>y : <span class=\"fn\"><a href=\"./Init/Core.html#Sigma\">Sigma</a> <span class=\"fn\">β</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.fst</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.fst</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#HEq\">HEq</a> <span class=\"fn\"><span class=\"fn\">x</span>.snd</span> <span class=\"fn\"><span class=\"fn\">y</span>.snd</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L103-L104","name":"PProd.ext","line":103,"kind":"theorem","docLink":"./Init/Ext.html#PProd.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#PProd.ext\"><span class=\"name\">PProd</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><a href=\"./Init/Prelude.html#PProd\">PProd</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\"><a href=\"./Init/Prelude.html#PProd\">PProd</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.fst</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.fst</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.snd</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.snd</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L100-L101","name":"Prod.ext","line":100,"kind":"theorem","docLink":"./Init/Ext.html#Prod.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#Prod.ext\"><span class=\"name\">Prod</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.fst</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.fst</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.snd</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.snd</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L91-L93","name":"Lean.Elab.Tactic.Ext.tacticExt1___","line":91,"kind":"def","docLink":"./Init/Ext.html#Lean.Elab.Tactic.Ext.tacticExt1___","doc":"`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#Lean.Elab.Tactic.Ext.tacticExt1___\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">tacticExt1___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L81-L82","name":"Lean.Elab.Tactic.Ext.applyExtTheorem","line":81,"kind":"def","docLink":"./Init/Ext.html#Lean.Elab.Tactic.Ext.applyExtTheorem","doc":"Apply a single extensionality theorem to the current goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#Lean.Elab.Tactic.Ext.applyExtTheorem\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">applyExtTheorem</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L65-L79","name":"Lean.Elab.Tactic.Ext.ext","line":65,"kind":"def","docLink":"./Init/Ext.html#Lean.Elab.Tactic.Ext.ext","doc":"Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#Lean.Elab.Tactic.Ext.ext\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L42-L47","name":"Lean.Elab.Tactic.Ext.declareExtTheoremFor","line":42,"kind":"def","docLink":"./Init/Ext.html#Lean.Elab.Tactic.Ext.declareExtTheoremFor","doc":"`declare_ext_theorems_for A` declares the extensionality theorems for the structure `A`.\n\nThese theorems state that two expressions with the structure type are equal if their fields are equal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#Lean.Elab.Tactic.Ext.declareExtTheoremFor\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">declareExtTheoremFor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L36-L40","name":"Lean.Elab.Tactic.Ext.extIffType","line":36,"kind":"def","docLink":"./Init/Ext.html#Lean.Elab.Tactic.Ext.extIffType","doc":"Creates the type of the iff-variant of the extensionality theorem for the given structure,\nelaborating to `x = y ↔ x.1 = y.1 ∧ x.2 = y.2`, for example.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#Lean.Elab.Tactic.Ext.extIffType\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">extIffType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L30-L34","name":"Lean.Elab.Tactic.Ext.extType","line":30,"kind":"def","docLink":"./Init/Ext.html#Lean.Elab.Tactic.Ext.extType","doc":"Creates the type of the extensionality theorem for the given structure,\nelaborating to `x.1 = y.1 → x.2 = y.2 → x = y`, for example.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#Lean.Elab.Tactic.Ext.extType\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">extType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Init/Ext.lean#L12-L24","name":"Lean.Parser.Attr.ext","line":12,"kind":"def","docLink":"./Init/Ext.html#Lean.Parser.Attr.ext","doc":"Registers an extensionality theorem.\n\n* When `@[ext]` is applied to a structure, it generates `.ext` and `.ext_iff` theorems and registers\nthem for the `ext` tactic.\n\n* When `@[ext]` is applied to a theorem, the theorem is registered for the `ext` tactic.\n\n* An optional natural number argument, e.g. `@[ext 9000]`, specifies a priority for the lemma. Higher-priority lemmas are chosen first, and the default is `1000`.\n\n* The flag `@[ext (flat := false)]` causes generated structure extensionality theorems to show inherited fields based on their representation,\nrather than flattening the parents' fields into the lemma's equality hypotheses.\nstructures in the generated extensionality theorems. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Ext.html#Lean.Parser.Attr.ext\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}