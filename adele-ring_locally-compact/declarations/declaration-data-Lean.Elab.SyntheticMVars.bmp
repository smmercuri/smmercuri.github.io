{"name":"Lean.Elab.SyntheticMVars","instances":[],"imports":["Lean.Meta.Tactic.Util","Lean.Util.ForEachExpr","Lean.Util.OccursCheck","Lean.Elab.Tactic.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Elab/SyntheticMVars.lean#L487-L493","name":"Lean.Elab.Term.runPendingTacticsAt","line":487,"kind":"def","docLink":"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.runPendingTacticsAt","doc":"Collect unassigned metavariables at `e` that have associated tactic blocks, and then execute them using `runTactic`.\nWe use this method at the `match .. with` elaborator when it cannot be postponed anymore, but it is still waiting\nthe result of a tactic block.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.runPendingTacticsAt\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">runPendingTacticsAt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Elab/SyntheticMVars.lean#L478-L480","name":"Lean.Elab.Term.elabTermAndSynthesize","line":478,"kind":"def","docLink":"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.elabTermAndSynthesize","doc":"Elaborate `stx`, and make sure all pending synthetic metavariables created while elaborating `stx` are solved. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.elabTermAndSynthesize\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">elabTermAndSynthesize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(expectedType? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Elab/SyntheticMVars.lean#L474-L475","name":"Lean.Elab.Term.withSynthesizeLight","line":474,"kind":"def","docLink":"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.withSynthesizeLight","doc":"Similar to `withSynthesize`, but sets `mayPostpone` to `true`, and do not use `synthesizeUsingDefault` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.withSynthesizeLight\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">withSynthesizeLight</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadFunctorT\">MonadFunctorT</a> <a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Elab/SyntheticMVars.lean#L470-L471","name":"Lean.Elab.Term.withSynthesize","line":470,"kind":"def","docLink":"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.withSynthesize","doc":"Execute `k`, and synthesize pending synthetic metavariables created while executing `k` are solved.\nIf `mayPostpone == false`, then all of them must be synthesized.\nRemark: even if `mayPostpone == true`, the method still uses `synthesizeUsingDefault` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.withSynthesize\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">withSynthesize</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadFunctorT\">MonadFunctorT</a> <a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(mayPostpone : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Elab/SyntheticMVars.lean#L450-L452","name":"Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault","line":450,"kind":"def","docLink":"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">synthesizeSyntheticMVarsUsingDefault</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Elab/SyntheticMVars.lean#L441-L442","name":"Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing","line":441,"kind":"def","docLink":"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">synthesizeSyntheticMVarsNoPostponing</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ignoreStuckTC : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Elab/SyntheticMVars.lean#L404-L435","name":"Lean.Elab.Term.synthesizeSyntheticMVars.loop","line":404,"kind":"opaque","docLink":"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVars.loop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVars.loop\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">synthesizeSyntheticMVars</span>.<span class=\"name\">loop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mayPostpone : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignoreStuckTC : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Unit\">Unit</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Elab/SyntheticMVars.lean#L403-L438","name":"Lean.Elab.Term.synthesizeSyntheticMVars","line":403,"kind":"opaque","docLink":"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVars","doc":"Try to process pending synthetic metavariables. If `mayPostpone == false`,\nthen `pendingMVars` is `[]` after executing this method.\n\nIt keeps executing `synthesizeSyntheticMVarsStep` while progress is being made.\nIf `mayPostpone == false`, then it applies default instances to `SyntheticMVarKind.typeClass` (if available)\nmetavariables that are still unresolved, and then tries to resolve metavariables\nwith `mayPostpone == false`. That is, we force them to produce error messages and/or commit to\na \"best option\". If, after that, we still haven't made progress, we report \"stuck\" errors.\n\nRemark: we set `ignoreStuckTC := true` when elaborating `simp` arguments. Then,\npending TC problems become implicit parameters for the simp theorem.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVars\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">synthesizeSyntheticMVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mayPostpone : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignoreStuckTC : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Elab/SyntheticMVars.lean#L300-L336","name":"Lean.Elab.Term.runTactic","line":300,"kind":"opaque","docLink":"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.runTactic","doc":"Try to synthesize a term `val` using the tactic code `tacticCode`, and then assign `mvarId := val`.\n\nThe `tacticCode` syntax comprises the whole `by ...` expression.\n\nIf `report := false`, then `runTactic` will not capture exceptions nor will report unsolved goals. Unsolved goals become exceptions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.runTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">runTactic</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tacticCode : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(report : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Elab/SyntheticMVars.lean#L210-L224","name":"Lean.Elab.Term.reportStuckSyntheticMVar","line":210,"kind":"def","docLink":"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.reportStuckSyntheticMVar","doc":"We use this method to report typeclass (and coercion) resolution problems that are \"stuck\".\nThat is, there is nothing else to do, and we don't have enough information to synthesize them using TC resolution.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.reportStuckSyntheticMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">reportStuckSyntheticMVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignoreStuckTC : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"}]}