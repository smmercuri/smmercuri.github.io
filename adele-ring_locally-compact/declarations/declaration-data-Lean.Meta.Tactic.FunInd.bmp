{"name":"Lean.Meta.Tactic.FunInd","instances":[],"imports":["Lean.Meta.Basic","Lean.Meta.Match.MatcherApp.Transform","Lean.Meta.Check","Lean.Meta.Tactic.Cleanup","Lean.Meta.Tactic.Subst","Lean.Meta.Injective","Lean.Meta.ArgsPacker","Lean.Elab.PreDefinition.WF.Eqns","Lean.Elab.PreDefinition.Structural.Eqns","Lean.Elab.Command","Lean.Meta.Tactic.ElimInfo"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L999-L1011","name":"Lean.Tactic.FunInd.isFunInductName","line":999,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunInductName","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isFunInductName\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">isFunInductName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(env : <a href=\"./Lean/Environment.html#Lean.Environment\">Lean.Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lake.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L991-L997","name":"Lean.Tactic.FunInd.deriveInduction","line":991,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInduction","doc":"Given a recursively defined function `foo`, derives `foo.induct`. See the module doc for details.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveInduction\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">deriveInduction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lake.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L972-L986","name":"Lean.Tactic.FunInd.deriveUnpackedInduction","line":972,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnpackedInduction","doc":"Given `foo._unary.induct`, define `foo.mutual_induct` and then `foo.induct`, `bar.induct`, … "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnpackedInduction\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">deriveUnpackedInduction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(eqnInfo : <a href=\"./Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo\">Lean.Elab.WF.EqnInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(unaryInductName : <a href=\"./Init/Prelude.html#Lean.Name\">Lake.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L926-L969","name":"Lean.Tactic.FunInd.unpackMutualInduction","line":926,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.unpackMutualInduction","doc":"Takes an induction principle where the motive is a `PSigma`/`PSum` type and\nunpacks it into a n-ary and (possibly) joint induction principle.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.unpackMutualInduction\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">unpackMutualInduction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(eqnInfo : <a href=\"./Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo\">Lean.Elab.WF.EqnInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(unaryInductName : <a href=\"./Init/Prelude.html#Lean.Name\">Lake.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lake.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L876-L920","name":"Lean.Tactic.FunInd.cleanPackedArgs","line":876,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanPackedArgs","doc":"In the type of `value`, reduces\n* Beta-redexes\n* `PSigma.casesOn (PSigma.mk a b) (fun x y => k x y)  -->  k a b`\n* `PSum.casesOn (PSum.inl x) k₁ k₂                    -->  k₁ x`\n* `foo._unary (PSum.inl (PSigma.mk a b))              -->  foo a b`\nand then wraps `value` in an appropriate type hint.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.cleanPackedArgs\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">cleanPackedArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(eqnInfo : <a href=\"./Lean/Elab/PreDefinition/WF/Eqns.html#Lean.Elab.WF.EqnInfo\">Lean.Elab.WF.EqnInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(value : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L808-L866","name":"Lean.Tactic.FunInd.deriveUnaryInduction","line":808,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnaryInduction","doc":"Given a definition `foo` defined via `WellFounded.fixF`, derive a suitable induction principle\n`foo.induct` for it. See module doc for details.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deriveUnaryInduction\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">deriveUnaryInduction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lake.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lake.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L798-L801","name":"Lean.Tactic.FunInd.findRecursor.err","line":798,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.findRecursor.err","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.findRecursor.err\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">findRecursor</span>.<span class=\"name\">err</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lake.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L727-L801","name":"Lean.Tactic.FunInd.findRecursor","line":727,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.findRecursor","doc":"This function looks that the body of a recursive function and looks for either users of\n`fix`, `fixF` or a `.brecOn`, and abstracts over the differences between them. It passes\nto the continuation\n\n* whether we are using well-founded recursion\n* the fixed parameters of the function body\n* the varying parameters of the function body (this includes both the targets of the\n  recursion and extra parameters passed to the recursor)\n* the position of the motive/induction hypothesis in the body's arguments\n* the body, as passed to the recursor. Expected to be a lambda that takes the\n  varying paramters and the motive\n* a function to re-assemble the call with a new Motive. The resulting expression expects\n  the new body next, so that the expected type of the body can be inferred\n* a function to finish assembling the call with the new body.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.findRecursor\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">findRecursor</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lake.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(varNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lake.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><a href=\"./Init/Prelude.html#Bool\">Bool</a> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> →\n    <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> →\n      <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span> → <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></span></span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L698-L709","name":"Lean.Tactic.FunInd.motiveUniverseParamPos","line":698,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.motiveUniverseParamPos","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.motiveUniverseParamPos\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">motiveUniverseParamPos</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(declName : <a href=\"./Init/Prelude.html#Lean.Name\">Lake.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L682-L692","name":"Lean.Tactic.FunInd.abstractIndependentMVars","line":682,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.abstractIndependentMVars","doc":"Given an expression `e` with metavariables\n* collects all these meta-variables,\n* lifts them to the current context by reverting all local declarations up to `x`\n* introducing a local variable for each of the meta variable\n* assigning that local variable to the mvar\n* and finally lambda-abstracting over these new local variables.\n\nThis operation only works if the metavariables are independent from each other.\n\nThe resulting meta variable assignment is no longer valid (mentions out-of-scope\nvariables), so after this operations, terms that still mention these meta variables must not\nbe used anymore.\n\nWe are not using `mkLambdaFVars` on mvars directly, nor `abstractMVars`, as these at the moment\ndo not handle delayed assignemnts correctly.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.abstractIndependentMVars\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">abstractIndependentMVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvars : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L572-L663","name":"Lean.Tactic.FunInd.buildInductionBody","line":572,"kind":"opaque","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody","doc":"Builds an expression of type `goal` by replicating the expression `e` into its tail-call-positions,\nwhere it calls `buildInductionCase`. Collects the cases of the final induction hypothesis\nas `MVars` as it goes.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionBody\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">buildInductionBody</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(is_wf : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fn : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(toClear : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(toPreserve : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(goal : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(oldIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(IHs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">Lean.Tactic.FunInd.M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L561-L565","name":"Lean.Tactic.FunInd.maskArray","line":561,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.maskArray","doc":"`maskArray mask xs` keeps those `x` where the corresponding entry in `mask` is `true` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.maskArray\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">maskArray</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(mask : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(xs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L546-L558","name":"Lean.Tactic.FunInd.mkLambdaFVarsMasked","line":546,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkLambdaFVarsMasked","doc":"Like `mkLambdaFVars (usedOnly := true)`, but\n\n * silently skips expression in `xs` that are not `.isFVar`\n * returns a mask (same size as `xs`) indicating which variables have been abstracted\n   (`true` means was abstracted).\n\nThe result `r` can be applied with `r.beta (maskArray mask args)`.\n\nWe use this when generating the functional induction principle to refine the goal through a `match`,\nhere `xs` are the discriminans of the `match`.\nWe do not expect non-trivial discriminants to appear in the goal (and if they do, the user will\nget a helpful equality into the context).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkLambdaFVarsMasked\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">mkLambdaFVarsMasked</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(xs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L517-L530","name":"Lean.Tactic.FunInd.buildInductionCase","line":517,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase","doc":"Base case of `buildInductionBody`: Construct a case for the final induction hypthesis.  "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.buildInductionCase\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">buildInductionCase</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(is_wf : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fn : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(oldIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(toClear : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(toPreserve : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(goal : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(IHs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\">Lean.Tactic.FunInd.M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L513-L513","name":"Lean.Tactic.FunInd.M","line":513,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M","doc":"Helper monad to traverse the function body, collecting the cases as mvars\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.M\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">M</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L501-L508","name":"Lean.Tactic.FunInd.substVarAfter","line":501,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.substVarAfter","doc":"Substitutes equations, but makes sure to only substitute variables introduced after the motive\nas the motive could depend on anything before, and `substVar` would happily drop equations\nabout these fixed parameters.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.substVarAfter\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">substVarAfter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L489-L493","name":"Lean.Tactic.FunInd.assertIHs","line":489,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.assertIHs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.assertIHs\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">assertIHs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(vals : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(mvarid : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L479-L487","name":"Lean.Tactic.FunInd.deduplicateIHs","line":479,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deduplicateIHs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.deduplicateIHs\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">deduplicateIHs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(vals : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L358-L473","name":"Lean.Tactic.FunInd.collectIHs","line":358,"kind":"opaque","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.collectIHs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.collectIHs\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">collectIHs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(is_wf : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fn : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(oldIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L263-L348","name":"Lean.Tactic.FunInd.foldCalls","line":263,"kind":"opaque","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldCalls","doc":"Replace calls to oldIH back to calls to the original function. At the end, if `oldIH` occurs, an\nerror is thrown.\n\nThe `newIH` will not show up in the output of `foldCalls`, we use it as a helper to infer the\nargument of nested recursive calls when we have structural recursion.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.foldCalls\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">foldCalls</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(is_wf : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fn : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(oldIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L247-L254","name":"Lean.Tactic.FunInd.isPProdProjWithArgs","line":247,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isPProdProjWithArgs","doc":"Structural recursion only:\nRecognizes `oldIH.fst.snd a₁ a₂` and returns `newIH.fst.snd` and `#[a₁, a₂]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isPProdProjWithArgs\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">isPProdProjWithArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(oldIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L227-L241","name":"Lean.Tactic.FunInd.isPProdProj","line":227,"kind":"opaque","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isPProdProj","doc":"Structural recursion only:\nRecognizes `oldIH.fst.snd a₁ a₂` and returns `newIH.fst.snd`.\nPossibly switching from `PProd.fst` to `And.left` if needed\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.isPProdProj\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">isPProdProj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(oldIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newIH : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L215-L220","name":"Lean.Tactic.FunInd.mkSnd","line":215,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkSnd","doc":"`PProd.snd` or `And.right` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkSnd\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">mkSnd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L207-L212","name":"Lean.Tactic.FunInd.mkFst","line":207,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkFst","doc":"`PProd.fst` or `And.left` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.mkFst\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">mkFst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Lean/Meta/Tactic/FunInd.lean#L200-L204","name":"Lean.Tactic.FunInd.removeLamda","line":200,"kind":"def","docLink":"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.removeLamda","doc":"Opens the body of a lambda, _without_ putting the free variable into the local context.\nThis is used when replacing parameters with different expressions.\nThis way it will not be picked up by metavariables.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/FunInd.html#Lean.Tactic.FunInd.removeLamda\"><span class=\"name\">Lean</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FunInd</span>.<span class=\"name\">removeLamda</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Exception.html#Lean.MonadError\">Lean.MonadError</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Meta.html#Lean.MonadNameGenerator\">Lean.MonadNameGenerator</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><span class=\"fn\">n</span> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">n</span> <span class=\"fn\">α</span></span></div></div>"}]}