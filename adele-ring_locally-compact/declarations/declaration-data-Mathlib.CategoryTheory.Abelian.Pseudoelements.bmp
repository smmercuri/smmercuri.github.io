{"name":"Mathlib.CategoryTheory.Abelian.Pseudoelements","instances":[{"typeNames":["CategoryTheory.Abelian.Pseudoelement"],"name":"CategoryTheory.Abelian.Pseudoelement.hasZero","className":"Zero"},{"typeNames":["CategoryTheory.Abelian.Pseudoelement"],"name":"CategoryTheory.Abelian.Pseudoelement.instInhabited","className":"Inhabited"}],"imports":["Init","Mathlib.CategoryTheory.Abelian.Exact","Mathlib.CategoryTheory.Comma.Over","Mathlib.Algebra.Category.ModuleCat.EpiMono"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L435-L450","name":"CategoryTheory.Abelian.Pseudoelement.ModuleCat.eq_range_of_pseudoequal","line":435,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.ModuleCat.eq_range_of_pseudoequal","doc":"In the category `Module R`, if `x` and `y` are pseudoequal, then the range of the associated\nmorphisms is the same. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.ModuleCat.eq_range_of_pseudoequal\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">ModuleCat</span>.<span class=\"name\">eq_range_of_pseudoequal</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{G : <span class=\"fn\"><a href=\"./Mathlib/Algebra/Category/ModuleCat/Basic.html#ModuleCat\">ModuleCat</a> <span class=\"fn\">R</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">G</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">G</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">G</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Submodule/Range.html#LinearMap.range\">LinearMap.range</a> <span class=\"fn\"><span class=\"fn\">x</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Submodule/Range.html#LinearMap.range\">LinearMap.range</a> <span class=\"fn\"><span class=\"fn\">y</span>.hom</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L420-L429","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_pullback","line":420,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_pullback","doc":"If `f : P ⟶ R` and `g : Q ⟶ R` are morphisms and `p : P` and `q : Q` are pseudoelements such\nthat `f p = g q`, then there is some `s : pullback f g` such that `fst s = p` and `snd s = q`.\n\nRemark: Borceux claims that `s` is unique, but this is false. See\n`Counterexamples/Pseudoelement.lean` for details. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_pullback\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudo_pullback</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPullbacks\">CategoryTheory.Limits.HasPullbacks</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{q : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">Q</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">p</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">q</span></span></span> →\n  <span class=\"fn\">∃ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.pullback\">CategoryTheory.Limits.pullback</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.pullback.fst\">CategoryTheory.Limits.pullback.fst</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">p</span></span> <a href=\"./Init/Prelude.html#And\">∧</a>       <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.pullback.snd\">CategoryTheory.Limits.pullback.snd</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">q</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L393-L411","name":"CategoryTheory.Abelian.Pseudoelement.sub_of_eq_image","line":393,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.sub_of_eq_image","doc":"If two pseudoelements `x` and `y` have the same image under some morphism `f`, then we can form\ntheir \"difference\" `z`. This pseudoelement has the properties that `f z = 0` and for all\nmorphisms `g`, if `g y = 0` then `g z = g x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.sub_of_eq_image\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">sub_of_eq_image</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">y</span></span></span> →\n  <span class=\"fn\">∃ (<span class=\"fn\">z</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">z</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#And\">∧</a>       <span class=\"fn\">∀ (<span class=\"fn\">R</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>),\n        <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> →\n          <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">z</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">x</span></span></span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L358-L386","name":"CategoryTheory.Abelian.Pseudoelement.exact_of_pseudo_exact","line":358,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.exact_of_pseudo_exact","doc":"If two morphisms are exact on pseudoelements, they are exact. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.exact_of_pseudo_exact\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">exact_of_pseudo_exact</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/Algebra/Homology/ShortComplex/Basic.html#CategoryTheory.ShortComplex\">CategoryTheory.ShortComplex</a> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hS : <span class=\"fn\">∀ (<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\"><span class=\"fn\">S</span>.X₂</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\"><span class=\"fn\">S</span>.g</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> →\n    <span class=\"fn\">∃ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\"><span class=\"fn\">S</span>.X₁</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\"><span class=\"fn\">S</span>.f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">S</span>.Exact</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L352-L353","name":"CategoryTheory.Abelian.Pseudoelement.apply_eq_zero_of_comp_eq_zero","line":352,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.apply_eq_zero_of_comp_eq_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.apply_eq_zero_of_comp_eq_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">apply_eq_zero_of_comp_eq_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">a</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Quot.mk\">Quot.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">Q</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">a</span></span>)</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L323-L348","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_exact_of_exact","line":323,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_exact_of_exact","doc":"Two morphisms in an exact sequence are exact on pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_exact_of_exact\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudo_exact_of_exact</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <span class=\"fn\"><a href=\"./Mathlib/Algebra/Homology/ShortComplex/Basic.html#CategoryTheory.ShortComplex\">CategoryTheory.ShortComplex</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hS : <span class=\"fn\"><span class=\"fn\">S</span>.Exact</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\"><span class=\"fn\">S</span>.X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\"><span class=\"fn\">S</span>.g</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> →\n  <span class=\"fn\">∃ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\"><span class=\"fn\">S</span>.X₁</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\"><span class=\"fn\">S</span>.f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L307-L318","name":"CategoryTheory.Abelian.Pseudoelement.epi_of_pseudo_surjective","line":307,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.epi_of_pseudo_surjective","doc":"A morphism that is surjective on pseudoelements is an epimorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.epi_of_pseudo_surjective\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">epi_of_pseudo_surjective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span></span>)</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L296-L302","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_surjective_of_epi","line":296,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_surjective_of_epi","doc":"An epimorphism is surjective on pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_surjective_of_epi\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudo_surjective_of_epi</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L288-L291","name":"CategoryTheory.Abelian.Pseudoelement.mono_of_zero_of_map_zero","line":288,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.mono_of_zero_of_map_zero","doc":"A morphism that only maps the zero pseudoelement to zero is a monomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.mono_of_zero_of_map_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">mono_of_zero_of_map_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></span>)</span> →\n  <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L282-L285","name":"CategoryTheory.Abelian.Pseudoelement.zero_of_map_zero","line":282,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_of_map_zero","doc":"A morphism that is injective on pseudoelements only maps the zero element to zero. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_of_map_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_of_map_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span></span>)</span></span> →\n  <span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L271-L279","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono","line":271,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono","doc":"A monomorphism is injective on pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudo_injective_of_mono</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L267-L268","name":"CategoryTheory.Abelian.Pseudoelement.eq_zero_iff","line":267,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.eq_zero_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.eq_zero_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">eq_zero_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L258-L259","name":"CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext'","line":258,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_morphism_ext'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span>)</span> → <span class=\"fn\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L254-L256","name":"CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext","line":254,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext","doc":"An extensionality lemma for being the zero arrow. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_morphism_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span>)</span> → <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L248-L251","name":"CategoryTheory.Abelian.Pseudoelement.zero_apply","line":248,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_apply","doc":"The zero morphism maps every pseudoelement to 0. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(Q : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">0</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L242-L244","name":"CategoryTheory.Abelian.Pseudoelement.apply_zero","line":242,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.apply_zero","doc":"Morphisms map the zero pseudoelement to the zero pseudoelement. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.apply_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">apply_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L232-L234","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_iff","line":232,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_iff","doc":"The pseudoelement induced by an arrow is zero precisely when that arrow is zero. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoZero_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Quot.mk\">Quot.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">P</span></span>)</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L228-L229","name":"CategoryTheory.Abelian.Pseudoelement.zero_eq_zero","line":228,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_eq_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_eq_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_eq_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">0</span></span>⟧</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L225-L225","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_def","line":225,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_def","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_def\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoZero_def</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">0</span></span>⟧</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L222-L223","name":"CategoryTheory.Abelian.Pseudoelement.instInhabited","line":222,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.instInhabited","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.instInhabited\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">instInhabited</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L219-L220","name":"CategoryTheory.Abelian.Pseudoelement.hasZero","line":219,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.hasZero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.hasZero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">hasZero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/ZeroOne.html#Zero\">Zero</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L212-L213","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero","line":212,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero","doc":"The zero pseudoelement is the class of a zero morphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoZero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L207-L209","name":"CategoryTheory.Abelian.Pseudoelement.zero_eq_zero'","line":207,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_eq_zero'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_eq_zero'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_eq_zero'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">0</span></span>⟧</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">0</span></span>⟧</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L200-L203","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_aux","line":200,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_aux","doc":"The arrows pseudo-equal to a zero morphism are precisely the zero morphisms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_aux\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoZero_aux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(Q : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Core.html#HasEquiv.Equiv\">≈</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">0</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L183-L184","name":"CategoryTheory.Abelian.Pseudoelement.comp_comp","line":183,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.comp_comp","doc":"Composition of functions on pseudoelements is composition of morphisms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.comp_comp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">comp_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L176-L180","name":"CategoryTheory.Abelian.Pseudoelement.comp_apply","line":176,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.comp_apply","doc":"Applying a pseudoelement to a composition of morphisms is the same as composing\nwith each morphism. Sadly, this is not a definitional equality, but at least it is\ntrue. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.comp_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">comp_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L171-L171","name":"CategoryTheory.Abelian.Pseudoelement.pseudoApply_mk'","line":171,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply_mk'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply_mk'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoApply_mk'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">⟦<span class=\"fn\">a</span>⟧</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">a</span>.hom</span> <span class=\"fn\">f</span></span>)</span></span>⟧</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L164-L165","name":"CategoryTheory.Abelian.Pseudoelement.homToFun","line":164,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.homToFun","doc":"A coercion from morphisms to functions on pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.homToFun\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">homToFun</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#CoeFun\">CoeFun</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">Q</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L160-L161","name":"CategoryTheory.Abelian.Pseudoelement.pseudoApply","line":160,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply","doc":"A morphism `f` induces a function `pseudoApply f` on pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoApply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">Q</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L155-L157","name":"CategoryTheory.Abelian.Pseudoelement.pseudoApply_aux","line":155,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply_aux","doc":"If two elements are pseudo-equal, then their composition with a morphism is, too. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply_aux\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoApply_aux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Core.html#HasEquiv.Equiv\">≈</a> <span class=\"fn\">b</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app\">CategoryTheory.Abelian.app</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Core.html#HasEquiv.Equiv\">≈</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app\">CategoryTheory.Abelian.app</a> <span class=\"fn\">f</span> <span class=\"fn\">b</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L152-L152","name":"CategoryTheory.Abelian.Pseudoelement.over_coe_def","line":152,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.over_coe_def","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.over_coe_def\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">over_coe_def</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Quot.mk\">Quot.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">P</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">a</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">a</span></span>⟧</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L147-L148","name":"CategoryTheory.Abelian.Pseudoelement.overToSort","line":147,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.overToSort","doc":"A coercion from an arrow with codomain `P` to its associated pseudoelement. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.overToSort\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">overToSort</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L139-L140","name":"CategoryTheory.Abelian.Pseudoelement.objectToSort","line":139,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.objectToSort","doc":"A coercion from an object of an abelian category to its pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.objectToSort\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">objectToSort</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#CoeSort\">CoeSort</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max u v))</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L133-L134","name":"CategoryTheory.Abelian.Pseudoelement","line":133,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement","doc":"A `Pseudoelement` of `P` is just an equivalence class of arrows ending in `P` by being\npseudo-equal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u v)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L126-L127","name":"CategoryTheory.Abelian.Pseudoelement.setoid","line":126,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.setoid","doc":"The arrows with codomain `P` equipped with the equivalence relation of being pseudo-equal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.setoid\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">setoid</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Setoid\">Setoid</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L116-L121","name":"CategoryTheory.Abelian.pseudoEqual_trans","line":116,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_trans","doc":"Pseudoequality is transitive: Just take the pullback. The pullback morphisms will\nbe epimorphisms since in an abelian category, pullbacks of epimorphisms are epimorphisms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_trans\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">pseudoEqual_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/Logic.html#Transitive\">Transitive</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L107-L108","name":"CategoryTheory.Abelian.pseudoEqual_symm","line":107,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_symm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_symm\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">pseudoEqual_symm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/Logic.html#Symmetric\">Symmetric</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L104-L105","name":"CategoryTheory.Abelian.pseudoEqual_refl","line":104,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_refl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_refl\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">pseudoEqual_refl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/Logic.html#Reflexive\">Reflexive</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L101-L102","name":"CategoryTheory.Abelian.PseudoEqual","line":101,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual","doc":"Two arrows `f : X ⟶ P` and `g : Y ⟶ P` are called pseudo-equal if there is some object\n`R` and epimorphisms `p : R ⟶ X` and `q : R ⟶ Y` such that `p ≫ f = q ≫ g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">PseudoEqual</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L97-L97","name":"CategoryTheory.Abelian.app_hom","line":97,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">app_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app\">CategoryTheory.Abelian.app</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">a</span>.hom</span> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L93-L94","name":"CategoryTheory.Abelian.app","line":93,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app","doc":"This is just composition of morphisms in `C`. Another way to express this would be\n`(Over.map f).obj a`, but our definition has nicer definitional properties. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">Q</span></span></div></div>"}]}