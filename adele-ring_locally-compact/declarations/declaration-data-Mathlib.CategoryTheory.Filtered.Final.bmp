{"name":"Mathlib.CategoryTheory.Filtered.Final","instances":[],"imports":["Init","Mathlib.CategoryTheory.Filtered.Connected","Mathlib.CategoryTheory.Limits.TypesFiltered","Mathlib.CategoryTheory.Limits.Final"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L225-L229","name":"CategoryTheory.Functor.initial_iff_isCofiltered_costructuredArrow","line":225,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.initial_iff_isCofiltered_costructuredArrow","doc":"If `C` is cofiltered, then `F : C ⥤ D` is initial if and only if `CostructuredArrow F d` is\ncofiltered for all `d : D`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.initial_iff_isCofiltered_costructuredArrow\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">initial_iff_isCofiltered_costructuredArrow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> v₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, v₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty\">CategoryTheory.IsCofilteredOrEmpty</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.Initial</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered\">CategoryTheory.IsCofiltered</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.CostructuredArrow\">CategoryTheory.CostructuredArrow</a> <span class=\"fn\">F</span> <span class=\"fn\">d</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L217-L221","name":"CategoryTheory.Functor.final_iff_isFiltered_structuredArrow","line":217,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.final_iff_isFiltered_structuredArrow","doc":"If `C` is filtered, then `F : C ⥤ D` is final if and only if `StructuredArrow d F` is filtered\nfor all `d : D`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.final_iff_isFiltered_structuredArrow\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">final_iff_isFiltered_structuredArrow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> v₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, v₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty\">CategoryTheory.IsFilteredOrEmpty</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.Final</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered\">CategoryTheory.IsFiltered</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.StructuredArrow\">CategoryTheory.StructuredArrow</a> <span class=\"fn\">d</span> <span class=\"fn\">F</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L211-L213","name":"CategoryTheory.Functor.Initial.exists_eq","line":211,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.Initial.exists_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.Initial.exists_eq\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">Initial</span>.<span class=\"name\">exists_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> v₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, v₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty\">CategoryTheory.IsCofilteredOrEmpty</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Initial</span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{d : <span class=\"fn\">D</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">d</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s' : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">d</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (<span class=\"fn\">c'</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">t</span> : <span class=\"fn\"><span class=\"fn\">c'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">c</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">s'</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L207-L209","name":"CategoryTheory.Functor.Final.exists_coeq","line":207,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.Final.exists_coeq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.Final.exists_coeq\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">Final</span>.<span class=\"name\">exists_coeq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> v₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, v₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty\">CategoryTheory.IsFilteredOrEmpty</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Final</span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{d : <span class=\"fn\">D</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s' : <span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (<span class=\"fn\">c'</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">t</span> : <span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">c'</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">s</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">s'</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L194-L205","name":"CategoryTheory.Functor.initial_iff_of_isCofiltered","line":194,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.initial_iff_of_isCofiltered","doc":"If `C` is cofiltered, then we can give an explicit condition for a functor `F : C ⥤ D` to\nbe initial. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.initial_iff_of_isCofiltered\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">initial_iff_of_isCofiltered</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> v₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, v₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty\">CategoryTheory.IsCofilteredOrEmpty</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.Initial</span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">d</span></span>)</span></span></span></span>)</span> <a href=\"./Init/Prelude.html#And\">∧</a>     <span class=\"fn\">∀ {<span class=\"fn\">d</span> : <span class=\"fn\">D</span>} {<span class=\"fn\">c</span> : <span class=\"fn\">C</span>} (<span class=\"fn\">s </span><span class=\"fn\">s'</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">d</span></span>),\n      <span class=\"fn\">∃ (<span class=\"fn\">c'</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">t</span> : <span class=\"fn\"><span class=\"fn\">c'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">c</span></span>),\n        <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">s'</span></span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L175-L190","name":"CategoryTheory.Functor.final_iff_of_isFiltered","line":175,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.final_iff_of_isFiltered","doc":"If `C` is filtered, then we can give an explicit condition for a functor `F : C ⥤ D` to\nbe final. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.final_iff_of_isFiltered\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">final_iff_of_isFiltered</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> v₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, v₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty\">CategoryTheory.IsFilteredOrEmpty</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.Final</span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span></span>)</span></span></span></span>)</span> <a href=\"./Init/Prelude.html#And\">∧</a>     <span class=\"fn\">∀ {<span class=\"fn\">d</span> : <span class=\"fn\">D</span>} {<span class=\"fn\">c</span> : <span class=\"fn\">C</span>} (<span class=\"fn\">s </span><span class=\"fn\">s'</span> : <span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span></span>),\n      <span class=\"fn\">∃ (<span class=\"fn\">c'</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">t</span> : <span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">c'</span></span>),\n        <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">s</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">s'</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span></span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L160-L165","name":"CategoryTheory.Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful","line":160,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful","doc":"In this situation, `C` is also cofiltered, see\n`IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">initial_of_exists_of_isCofiltered_of_fullyFaithful</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty\">CategoryTheory.IsCofilteredOrEmpty</a> <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Full</span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Faithful</span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">d</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span>.Initial</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L150-L156","name":"CategoryTheory.Functor.final_of_exists_of_isFiltered_of_fullyFaithful","line":150,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.final_of_exists_of_isFiltered_of_fullyFaithful","doc":"In this situation, `C` is also filtered, see\n`IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.final_of_exists_of_isFiltered_of_fullyFaithful\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">final_of_exists_of_isFiltered_of_fullyFaithful</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty\">CategoryTheory.IsFilteredOrEmpty</a> <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Full</span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Faithful</span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span>.Final</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L140-L146","name":"CategoryTheory.IsCofiltered.of_exists_of_isCofiltered_of_fullyFaithful","line":140,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.IsCofiltered.of_exists_of_isCofiltered_of_fullyFaithful","doc":"In this situation, `F` is also initial, see\n`Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.IsCofiltered.of_exists_of_isCofiltered_of_fullyFaithful\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">IsCofiltered</span>.<span class=\"name\">of_exists_of_isCofiltered_of_fullyFaithful</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered\">CategoryTheory.IsCofiltered</a> <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Full</span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Faithful</span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">d</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered\">CategoryTheory.IsCofiltered</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L130-L136","name":"CategoryTheory.IsFiltered.of_exists_of_isFiltered_of_fullyFaithful","line":130,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.IsFiltered.of_exists_of_isFiltered_of_fullyFaithful","doc":"In this situation, `F` is also final, see\n`Functor.final_of_exists_of_isFiltered_of_fullyFaithful`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.IsFiltered.of_exists_of_isFiltered_of_fullyFaithful\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">IsFiltered</span>.<span class=\"name\">of_exists_of_isFiltered_of_fullyFaithful</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered\">CategoryTheory.IsFiltered</a> <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Full</span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Faithful</span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered\">CategoryTheory.IsFiltered</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L121-L126","name":"CategoryTheory.IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful","line":121,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful","doc":"In this situation, `F` is also initial, see\n`Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">IsCofilteredOrEmpty</span>.<span class=\"name\">of_exists_of_isCofiltered_of_fullyFaithful</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty\">CategoryTheory.IsCofilteredOrEmpty</a> <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Full</span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Faithful</span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">d</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty\">CategoryTheory.IsCofilteredOrEmpty</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L108-L117","name":"CategoryTheory.IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful","line":108,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful","doc":"In this situation, `F` is also final, see\n`Functor.final_of_exists_of_isFiltered_of_fullyFaithful`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">IsFilteredOrEmpty</span>.<span class=\"name\">of_exists_of_isFiltered_of_fullyFaithful</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty\">CategoryTheory.IsFilteredOrEmpty</a> <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Full</span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">F</span>.Faithful</span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty\">CategoryTheory.IsFilteredOrEmpty</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L99-L104","name":"CategoryTheory.Functor.initial_of_exists_of_isCofiltered","line":99,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.initial_of_exists_of_isCofiltered","doc":"If `C` is cofiltered, then we can give an explicit condition for a functor `F : C ⥤ D` to\nbe final. The converse is also true, see `initial_iff_of_isCofiltered`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.initial_of_exists_of_isCofiltered\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">initial_of_exists_of_isCofiltered</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty\">CategoryTheory.IsCofilteredOrEmpty</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">d</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\">∀ {<span class=\"fn\">d</span> : <span class=\"fn\">D</span>} {<span class=\"fn\">c</span> : <span class=\"fn\">C</span>} (<span class=\"fn\">s </span><span class=\"fn\">s'</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">d</span></span>),\n  <span class=\"fn\">∃ (<span class=\"fn\">c'</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">t</span> : <span class=\"fn\"><span class=\"fn\">c'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">c</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">s'</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span>.Initial</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L91-L95","name":"CategoryTheory.Functor.final_of_exists_of_isFiltered","line":91,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.final_of_exists_of_isFiltered","doc":"If `C` is filtered, then we can give an explicit condition for a functor `F : C ⥤ D` to\nbe final. The converse is also true, see `final_iff_of_isFiltered`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.final_of_exists_of_isFiltered\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">final_of_exists_of_isFiltered</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty\">CategoryTheory.IsFilteredOrEmpty</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\">∀ {<span class=\"fn\">d</span> : <span class=\"fn\">D</span>} {<span class=\"fn\">c</span> : <span class=\"fn\">C</span>} (<span class=\"fn\">s </span><span class=\"fn\">s'</span> : <span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span></span>),\n  <span class=\"fn\">∃ (<span class=\"fn\">c'</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">t</span> : <span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">c'</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">s</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">s'</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span>.Final</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L74-L87","name":"CategoryTheory.isCofiltered_costructuredArrow_of_isCofiltered_of_exists","line":74,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.isCofiltered_costructuredArrow_of_isCofiltered_of_exists","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.isCofiltered_costructuredArrow_of_isCofiltered_of_exists\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">isCofiltered_costructuredArrow_of_isCofiltered_of_exists</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty\">CategoryTheory.IsCofilteredOrEmpty</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">d</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\">∀ {<span class=\"fn\">d</span> : <span class=\"fn\">D</span>} {<span class=\"fn\">c</span> : <span class=\"fn\">C</span>} (<span class=\"fn\">s </span><span class=\"fn\">s'</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">d</span></span>),\n  <span class=\"fn\">∃ (<span class=\"fn\">c'</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">t</span> : <span class=\"fn\"><span class=\"fn\">c'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">c</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">s'</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(d : <span class=\"fn\">D</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered\">CategoryTheory.IsCofiltered</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.CostructuredArrow\">CategoryTheory.CostructuredArrow</a> <span class=\"fn\">F</span> <span class=\"fn\">d</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L56-L72","name":"CategoryTheory.isFiltered_structuredArrow_of_isFiltered_of_exists","line":56,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.isFiltered_structuredArrow_of_isFiltered_of_exists","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.isFiltered_structuredArrow_of_isFiltered_of_exists\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">isFiltered_structuredArrow_of_isFiltered_of_exists</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty\">CategoryTheory.IsFilteredOrEmpty</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\">∃ (<span class=\"fn\">c</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\">∀ {<span class=\"fn\">d</span> : <span class=\"fn\">D</span>} {<span class=\"fn\">c</span> : <span class=\"fn\">C</span>} (<span class=\"fn\">s </span><span class=\"fn\">s'</span> : <span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">c</span></span></span>),\n  <span class=\"fn\">∃ (<span class=\"fn\">c'</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">t</span> : <span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">c'</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">s</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">s'</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">t</span></span>)</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(d : <span class=\"fn\">D</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered\">CategoryTheory.IsFiltered</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.StructuredArrow\">CategoryTheory.StructuredArrow</a> <span class=\"fn\">d</span> <span class=\"fn\">F</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L52-L54","name":"CategoryTheory.Functor.initial_of_isCofiltered_costructuredArrow","line":52,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.initial_of_isCofiltered_costructuredArrow","doc":"If `CostructuredArrow F d` is filtered for any `d : D`, then `F : C ⥤ D` is initial. This is\nsimply because cofiltered categories are connectged. More profoundly, the converse is also true\nif `C` is cofiltered, see `initial_iff_isCofiltered_costructuredArrow`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.initial_of_isCofiltered_costructuredArrow\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">initial_of_isCofiltered_costructuredArrow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered\">CategoryTheory.IsCofiltered</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.CostructuredArrow\">CategoryTheory.CostructuredArrow</a> <span class=\"fn\">F</span> <span class=\"fn\">d</span></span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span>.Initial</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Filtered/Final.lean#L45-L47","name":"CategoryTheory.Functor.final_of_isFiltered_structuredArrow","line":45,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.final_of_isFiltered_structuredArrow","doc":"If `StructuredArrow d F` is filtered for any `d : D`, then `F : C ⥤ D` is final. This is\nsimply because filtered categories are connected. More profoundly, the converse is also true if\n`C` is filtered, see `final_iff_isFiltered_structuredArrow`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Filtered/Final.html#CategoryTheory.Functor.final_of_isFiltered_structuredArrow\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">final_of_isFiltered_structuredArrow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ (<span class=\"fn\">d</span> : <span class=\"fn\">D</span>), <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered\">CategoryTheory.IsFiltered</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow.html#CategoryTheory.StructuredArrow\">CategoryTheory.StructuredArrow</a> <span class=\"fn\">d</span> <span class=\"fn\">F</span></span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span>.Final</span></div></div>"}]}