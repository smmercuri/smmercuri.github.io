{"name":"Mathlib.CategoryTheory.Limits.Preserves.Ulift","instances":[{"typeNames":["CategoryTheory.uliftFunctor"],"name":"CategoryTheory.Limits.Types.instPreservesLimitsOfSizeUliftFunctor","className":"CategoryTheory.Limits.PreservesLimitsOfSize"},{"typeNames":["CategoryTheory.uliftFunctor"],"name":"CategoryTheory.Limits.Types.instCreatesLimitsOfSizeUliftFunctor","className":"CategoryTheory.CreatesLimitsOfSize"},{"typeNames":["CategoryTheory.uliftFunctor"],"name":"CategoryTheory.Limits.Types.instPreservesColimitsOfSizeUliftFunctor","className":"CategoryTheory.Limits.PreservesColimitsOfSize"},{"typeNames":["CategoryTheory.uliftFunctor"],"name":"CategoryTheory.Limits.Types.instCreatesColimitsOfSizeUliftFunctor","className":"CategoryTheory.CreatesColimitsOfSize"}],"imports":["Init","Mathlib.CategoryTheory.Limits.Creates","Mathlib.CategoryTheory.Limits.Types","Mathlib.Data.Set.Subsingleton"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L150-L151","name":"CategoryTheory.Limits.Types.instCreatesColimitsOfSizeUliftFunctor","line":150,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.instCreatesColimitsOfSizeUliftFunctor","doc":"The functor `uliftFunctor : Type u ⥤ Type (max u v)` creates `u`-small colimits.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.instCreatesColimitsOfSizeUliftFunctor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">instCreatesColimitsOfSizeUliftFunctor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Creates.html#CategoryTheory.CreatesColimitsOfSize\">CategoryTheory.CreatesColimitsOfSize.{w, u, u, max u v, u + 1, max (u + 1) (v + 1)}</a>                                            <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L138-L145","name":"CategoryTheory.Limits.Types.instPreservesColimitsOfSizeUliftFunctor","line":138,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.instPreservesColimitsOfSizeUliftFunctor","doc":"The functor `uliftFunctor : Type u ⥤ Type (max u v)` preserves colimits of arbitrary size.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.instPreservesColimitsOfSizeUliftFunctor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">instPreservesColimitsOfSizeUliftFunctor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Basic.html#CategoryTheory.Limits.PreservesColimitsOfSize\">CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, u, max u v, u + 1, max (u + 1) (v + 1)}</a>                                           \n  <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L126-L133","name":"CategoryTheory.Limits.Types.descFun_spec","line":126,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descFun_spec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descFun_spec\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">descFun_spec</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span>.pt</span> → <span class=\"fn\"><span class=\"fn\">lc</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descFun\">CategoryTheory.Limits.Types.descFun</a> <span class=\"fn\">hc</span> <span class=\"fn\">lc</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span>.ι</span>.app</span> <span class=\"fn\">j</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">lc</span>.ι</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">ULift.up</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L121-L124","name":"CategoryTheory.Limits.Types.descFun_apply_spec","line":121,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descFun_apply_spec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descFun_apply_spec\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">descFun_apply_spec</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><span class=\"fn\">c</span>.pt</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\"><span class=\"fn\">lc</span>.pt</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descFun\">CategoryTheory.Limits.Types.descFun</a> <span class=\"fn\">hc</span> <span class=\"fn\">lc</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet\">CategoryTheory.Limits.Types.descSet</a> <span class=\"fn\">hc</span> <span class=\"fn\">{<span class=\"fn\">y</span>}</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L119-L119","name":"CategoryTheory.Limits.Types.descFun","line":119,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descFun","doc":"Given a colimit cocone in `Type u` and an arbitrary cocone over the diagram lifted to\n`Type (max u v)`, produce a function from the cocone point of the colimit cocone to the\ncocone point of the other cocone, that witnesses the colimit cocone also being a colimit\nin the higher universe. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descFun\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">descFun</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\">c</span>.pt</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">lc</span>.pt</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L109-L113","name":"CategoryTheory.Limits.Types.exists_unique_mem_descSet","line":109,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.exists_unique_mem_descSet","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.exists_unique_mem_descSet\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">exists_unique_mem_descSet</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\">c</span>.pt</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃! <span class=\"fn\">y</span> : <span class=\"fn\"><span class=\"fn\">lc</span>.pt</span>, <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet\">CategoryTheory.Limits.Types.descSet</a> <span class=\"fn\">hc</span> <span class=\"fn\">{<span class=\"fn\">y</span>}</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L101-L107","name":"CategoryTheory.Limits.Types.descSet_inter_of_ne","line":101,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet_inter_of_ne","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet_inter_of_ne\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">descSet_inter_of_ne</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\">lc</span>.pt</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <span class=\"fn\"><span class=\"fn\">lc</span>.pt</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hn : <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet\">CategoryTheory.Limits.Types.descSet</a> <span class=\"fn\">hc</span> <span class=\"fn\">{<span class=\"fn\">x</span>}</span></span> <a href=\"./Init/Core.html#Inter.inter\">∩</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet\">CategoryTheory.Limits.Types.descSet</a> <span class=\"fn\">hc</span> <span class=\"fn\">{<span class=\"fn\">y</span>}</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L99-L99","name":"CategoryTheory.Limits.Types.descSet_empty","line":99,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet_empty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet_empty\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">descSet_empty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet\">CategoryTheory.Limits.Types.descSet</a> <span class=\"fn\">hc</span> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L92-L97","name":"CategoryTheory.Limits.Types.iUnion_descSet_singleton","line":92,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.iUnion_descSet_singleton","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.iUnion_descSet_singleton\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">iUnion_descSet_singleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">⋃ (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">lc</span>.pt</span>), <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet\">CategoryTheory.Limits.Types.descSet</a> <span class=\"fn\">hc</span> <span class=\"fn\">{<span class=\"fn\">x</span>}</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">Set.univ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L90-L90","name":"CategoryTheory.Limits.Types.descSet_univ","line":90,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet_univ","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet_univ\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">descSet_univ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet\">CategoryTheory.Limits.Types.descSet</a> <span class=\"fn\">hc</span> <span class=\"fn\">Set.univ</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">Set.univ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L84-L86","name":"CategoryTheory.Limits.Types.mem_descSet_singleton","line":84,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.mem_descSet_singleton","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.mem_descSet_singleton\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">mem_descSet_singleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><span class=\"fn\">lc</span>.pt</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{j : <span class=\"fn\">J</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.obj</span> <span class=\"fn\">j</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span>.ι</span>.app</span> <span class=\"fn\">j</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet\">CategoryTheory.Limits.Types.descSet</a> <span class=\"fn\">hc</span> <span class=\"fn\">{<span class=\"fn\">x</span>}</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">lc</span>.ι</span>.app</span> <span class=\"fn\">j</span> <span class=\"fn\">{ <span class=\"fn\">down</span> := <span class=\"fn\">y</span> }</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L76-L82","name":"CategoryTheory.Limits.Types.descSet_spec","line":76,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet_spec","doc":"Characterization the map `descSet hc`: the image of an element in a vertex of the original\ndiagram in the cocone point lies in `descSet hc ls` if and only if the image of the corresponding\nelement in the lifted diagram lie in `ls`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet_spec\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">descSet_spec</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\"><span class=\"fn\">c</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ls : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\"><span class=\"fn\">lc</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet\">CategoryTheory.Limits.Types.descSet</a> <span class=\"fn\">hc</span> <span class=\"fn\">ls</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">s</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.obj</span> <span class=\"fn\">j</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">lc</span>.ι</span>.app</span> <span class=\"fn\">j</span> <span class=\"fn\">{ <span class=\"fn\">down</span> := <span class=\"fn\">x</span> }</span></span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">ls</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span>.ι</span>.app</span> <span class=\"fn\">j</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L71-L71","name":"CategoryTheory.Limits.Types.descSet","line":71,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet","doc":"Given a subset of the cocone point of a cocone over the lifted functor,\nproduce a subset of the cocone point of a colimit cocone over the original functor. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.descSet\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">descSet</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ls : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\"><span class=\"fn\">lc</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\"><span class=\"fn\">c</span>.pt</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L63-L67","name":"CategoryTheory.Limits.Types.coconeOfSet","line":63,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.coconeOfSet","doc":"Given a subset of the cocone point of a cocone over the lifted functor,\nproduce a cocone over the original functor. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.coconeOfSet\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coconeOfSet</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{lc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ls : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\"><span class=\"fn\">lc</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">K</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L55-L56","name":"CategoryTheory.Limits.Types.instCreatesLimitsOfSizeUliftFunctor","line":55,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.instCreatesLimitsOfSizeUliftFunctor","doc":"The functor `uliftFunctor : Type u ⥤ Type (max u v)` creates `u`-small limits.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.instCreatesLimitsOfSizeUliftFunctor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">instCreatesLimitsOfSizeUliftFunctor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Creates.html#CategoryTheory.CreatesLimitsOfSize\">CategoryTheory.CreatesLimitsOfSize.{w, u, u, max u v, u + 1, max (u + 1) (v + 1)}</a>                                            <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L41-L50","name":"CategoryTheory.Limits.Types.instPreservesLimitsOfSizeUliftFunctor","line":41,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.instPreservesLimitsOfSizeUliftFunctor","doc":"The functor `uliftFunctor : Type u ⥤ Type (max u v)` preserves limits of arbitrary size.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.instPreservesLimitsOfSizeUliftFunctor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">instPreservesLimitsOfSizeUliftFunctor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Preserves/Basic.html#CategoryTheory.Limits.PreservesLimitsOfSize\">CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, u, max u v, u + 1, max (u + 1) (v + 1)}</a>                                           \n  <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Preserves/Ulift.lean#L30-L35","name":"CategoryTheory.Limits.Types.sectionsEquiv","line":30,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.sectionsEquiv","doc":"The equivalence between `K.sections` and `(K ⋙ uliftFunctor.{v, u}).sections`. This is used to show\nthat `uliftFunctor` preserves limits that are potentially too large to exist in the source\ncategory.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Preserves/Ulift.html#CategoryTheory.Limits.Types.sectionsEquiv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">sectionsEquiv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(K : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">J</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\"><span class=\"fn\">K</span>.sections</span></span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">↑<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">K</span>.comp</span> <a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.uliftFunctor\">CategoryTheory.uliftFunctor.{v, u}</a>   </span>)</span>.sections</span></span></span></div></div>"}]}