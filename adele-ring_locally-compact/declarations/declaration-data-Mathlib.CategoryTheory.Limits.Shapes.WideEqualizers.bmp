{"name":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","instances":[{"typeNames":["Eq"],"name":"CategoryTheory.Limits.instDecidableEqWalkingParallelFamily","className":"Decidable"},{"typeNames":["CategoryTheory.Limits.WalkingParallelFamily"],"name":"CategoryTheory.Limits.instInhabitedWalkingParallelFamily","className":"Inhabited"},{"typeNames":["Eq"],"name":"CategoryTheory.Limits.WalkingParallelFamily.instDecidableEqHom","className":"Decidable"},{"typeNames":["CategoryTheory.Limits.WalkingParallelFamily.Hom"],"name":"CategoryTheory.Limits.instInhabitedHomZero","className":"Inhabited"},{"typeNames":["CategoryTheory.Limits.WalkingParallelFamily"],"name":"CategoryTheory.Limits.WalkingParallelFamily.category","className":"CategoryTheory.Category"},{"typeNames":["CategoryTheory.Limits.wideEqualizer.ι"],"name":"CategoryTheory.Limits.wideEqualizer.ι_mono","className":"CategoryTheory.Mono"},{"typeNames":["CategoryTheory.Limits.wideCoequalizer.π"],"name":"CategoryTheory.Limits.wideCoequalizer.π_epi","className":"CategoryTheory.Epi"},{"typeNames":[],"name":"CategoryTheory.Limits.hasEqualizers_of_hasWideEqualizers","className":"CategoryTheory.Limits.HasLimitsOfShape"},{"typeNames":[],"name":"CategoryTheory.Limits.hasCoequalizers_of_hasWideCoequalizers","className":"CategoryTheory.Limits.HasColimitsOfShape"}],"imports":["Init","Mathlib.CategoryTheory.Limits.HasLimits","Mathlib.CategoryTheory.Limits.Shapes.Equalizers"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L678-L680","name":"CategoryTheory.Limits.hasCoequalizers_of_hasWideCoequalizers","line":678,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasCoequalizers_of_hasWideCoequalizers","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasCoequalizers_of_hasWideCoequalizers\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasCoequalizers_of_hasWideCoequalizers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizers\">CategoryTheory.Limits.HasWideCoequalizers</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizers\">CategoryTheory.Limits.HasCoequalizers</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L674-L676","name":"CategoryTheory.Limits.hasEqualizers_of_hasWideEqualizers","line":674,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasEqualizers_of_hasWideEqualizers","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasEqualizers_of_hasWideEqualizers\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasEqualizers_of_hasWideEqualizers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizers\">CategoryTheory.Limits.HasWideEqualizers</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizers\">CategoryTheory.Limits.HasEqualizers</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L669-L672","name":"CategoryTheory.Limits.hasWideCoequalizers_of_hasColimit_parallelFamily","line":669,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasWideCoequalizers_of_hasColimit_parallelFamily","doc":"If `C` has all colimits of diagrams `parallelFamily f`, then it has all wide coequalizers "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasWideCoequalizers_of_hasColimit_parallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasWideCoequalizers_of_hasColimit_parallelFamily</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ {<span class=\"fn\">J</span> : <a href=\"./foundational_types.html\">Type</a> w} {<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>} {<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimit\">CategoryTheory.Limits.HasColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizers\">CategoryTheory.Limits.HasWideCoequalizers</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L663-L666","name":"CategoryTheory.Limits.hasWideEqualizers_of_hasLimit_parallelFamily","line":663,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasWideEqualizers_of_hasLimit_parallelFamily","doc":"If `C` has all limits of diagrams `parallelFamily f`, then it has all wide equalizers "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasWideEqualizers_of_hasLimit_parallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasWideEqualizers_of_hasLimit_parallelFamily</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ {<span class=\"fn\">J</span> : <a href=\"./foundational_types.html\">Type</a> w} {<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>} {<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasLimit\">CategoryTheory.Limits.HasLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizers\">CategoryTheory.Limits.HasWideEqualizers</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L659-L660","name":"CategoryTheory.Limits.HasWideCoequalizers","line":659,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizers","doc":"`HasWideCoequalizers` represents a choice of wide coequalizer for every family of morphisms "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizers\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasWideCoequalizers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L655-L656","name":"CategoryTheory.Limits.HasWideEqualizers","line":655,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizers","doc":"`HasWideEqualizers` represents a choice of wide equalizer for every family of morphisms "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizers\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasWideEqualizers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L646-L648","name":"CategoryTheory.Limits.epi_of_isColimit_parallelFamily","line":646,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.epi_of_isColimit_parallelFamily","doc":"The wide coequalizer morphism in any colimit cocone is an epimorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.epi_of_isColimit_parallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">epi_of_isColimit_parallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L636-L637","name":"CategoryTheory.Limits.wideCoequalizer.π_epi","line":636,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_epi","doc":"A wide coequalizer morphism is an epimorphism "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_epi\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">π_epi</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L631-L633","name":"CategoryTheory.Limits.wideCoequalizer.hom_ext","line":631,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.hom_ext","doc":"Two maps from a wide coequalizer are equal if they are equal when composed with the wide\ncoequalizer map "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">l</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L624-L626","name":"CategoryTheory.Limits.wideCoequalizer.desc'","line":624,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc'","doc":"Any morphism `k : Y ⟶ W` satisfying `∀ j₁ j₂, f j₁ ≫ k = f j₂ ≫ k` induces a morphism\n`l : wideCoequalizer f ⟶ W` satisfying `wideCoequalizer.π ≫ g = l`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">desc'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">k</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span> //\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">l</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L617-L620","name":"CategoryTheory.Limits.wideCoequalizer.π_desc","line":617,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_desc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_desc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">π_desc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">k</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc\">CategoryTheory.Limits.wideCoequalizer.desc</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L616-L616","name":"CategoryTheory.Limits.wideCoequalizer.π_desc_assoc","line":616,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_desc_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_desc_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">π_desc_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">k</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc\">CategoryTheory.Limits.wideCoequalizer.desc</a> <span class=\"fn\">k</span> <span class=\"fn\">h✝</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L612-L614","name":"CategoryTheory.Limits.wideCoequalizer.desc","line":612,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc","doc":"Any morphism `k : Y ⟶ W` satisfying `∀ j₁ j₂, f j₁ ≫ k = f j₂ ≫ k` factors through the\nwide coequalizer of `f` via `wideCoequalizer.desc : wideCoequalizer f ⟶ W`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">desc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">k</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L604-L606","name":"CategoryTheory.Limits.wideCoequalizerIsWideCoequalizer","line":604,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizerIsWideCoequalizer","doc":"The cotrident built from `wideCoequalizer.π f` is colimiting. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizerIsWideCoequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizerIsWideCoequalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ\">CategoryTheory.Limits.Cotrident.ofπ</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L599-L601","name":"CategoryTheory.Limits.wideCoequalizer.condition","line":599,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L598-L598","name":"CategoryTheory.Limits.wideCoequalizer.condition_assoc","line":598,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L594-L596","name":"CategoryTheory.Limits.wideCoequalizer.cotrident_ι_app_one","line":594,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident_ι_app_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident_ι_app_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">cotrident_ι_app_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident\">CategoryTheory.Limits.wideCoequalizer.cotrident</a> <span class=\"fn\">f</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L590-L591","name":"CategoryTheory.Limits.wideCoequalizer.cotrident_π","line":590,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">cotrident_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident\">CategoryTheory.Limits.wideCoequalizer.cotrident</a> <span class=\"fn\">f</span></span>)</span>.π</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L586-L587","name":"CategoryTheory.Limits.wideCoequalizer.cotrident","line":586,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident","doc":"An arbitrary choice of coequalizer cocone for a parallel family `f`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">cotrident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L581-L582","name":"CategoryTheory.Limits.wideCoequalizer.π","line":581,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π","doc":"If a wideCoequalizer of `f` exists, we can access the corresponding projection by\nsaying `wideCoequalizer.π f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L576-L577","name":"CategoryTheory.Limits.wideCoequalizer","line":576,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer","doc":"If a wide coequalizer of `f`, we can access an arbitrary choice of such by\nsaying `wideCoequalizer f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">C</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L569-L570","name":"CategoryTheory.Limits.HasWideCoequalizer","line":569,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer","doc":"`HasWideCoequalizer f g` represents a particular choice of colimiting cocone\nfor the parallel family of morphisms `f`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasWideCoequalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L558-L560","name":"CategoryTheory.Limits.mono_of_isLimit_parallelFamily","line":558,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.mono_of_isLimit_parallelFamily","doc":"The wide equalizer morphism in any limit cone is a monomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.mono_of_isLimit_parallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">mono_of_isLimit_parallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone\">CategoryTheory.Limits.Cone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L548-L549","name":"CategoryTheory.Limits.wideEqualizer.ι_mono","line":548,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι_mono","doc":"A wide equalizer morphism is a monomorphism "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι_mono\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">ι_mono</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L543-L545","name":"CategoryTheory.Limits.wideEqualizer.hom_ext","line":543,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.hom_ext","doc":"Two maps into a wide equalizer are equal if they are equal when composed with the wide\nequalizer map. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\">CategoryTheory.Limits.wideEqualizer</a> <span class=\"fn\">f</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\">CategoryTheory.Limits.wideEqualizer</a> <span class=\"fn\">f</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L536-L538","name":"CategoryTheory.Limits.wideEqualizer.lift'","line":536,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift'","doc":"A morphism `k : W ⟶ X` satisfying `∀ j₁ j₂, k ≫ f j₁ = k ≫ f j₂` induces a morphism\n`l : W ⟶ wideEqualizer f` satisfying `l ≫ wideEqualizer.ι f = k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">lift'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\">CategoryTheory.Limits.wideEqualizer</a> <span class=\"fn\">f</span></span></span> //\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L529-L532","name":"CategoryTheory.Limits.wideEqualizer.lift_ι","line":529,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">lift_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift\">CategoryTheory.Limits.wideEqualizer.lift</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L528-L528","name":"CategoryTheory.Limits.wideEqualizer.lift_ι_assoc","line":528,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift_ι_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift_ι_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">lift_ι_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift\">CategoryTheory.Limits.wideEqualizer.lift</a> <span class=\"fn\">k</span> <span class=\"fn\">h✝</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L524-L526","name":"CategoryTheory.Limits.wideEqualizer.lift","line":524,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift","doc":"A morphism `k : W ⟶ X` satisfying `∀ j₁ j₂, k ≫ f j₁ = k ≫ f j₂` factors through the\nwide equalizer of `f` via `wideEqualizer.lift : W ⟶ wideEqualizer f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\">CategoryTheory.Limits.wideEqualizer</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L516-L518","name":"CategoryTheory.Limits.wideEqualizerIsWideEqualizer","line":516,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizerIsWideEqualizer","doc":"The wideEqualizer built from `wideEqualizer.ι f` is limiting. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizerIsWideEqualizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizerIsWideEqualizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι\">CategoryTheory.Limits.Trident.ofι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L512-L513","name":"CategoryTheory.Limits.wideEqualizer.condition","line":512,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L511-L511","name":"CategoryTheory.Limits.wideEqualizer.condition_assoc","line":511,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L507-L509","name":"CategoryTheory.Limits.wideEqualizer.trident_π_app_zero","line":507,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident_π_app_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident_π_app_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">trident_π_app_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident\">CategoryTheory.Limits.wideEqualizer.trident</a> <span class=\"fn\">f</span></span>)</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L503-L504","name":"CategoryTheory.Limits.wideEqualizer.trident_ι","line":503,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">trident_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident\">CategoryTheory.Limits.wideEqualizer.trident</a> <span class=\"fn\">f</span></span>)</span>.ι</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L499-L500","name":"CategoryTheory.Limits.wideEqualizer.trident","line":499,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident","doc":"A wide equalizer cone for a parallel family `f`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">trident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L494-L495","name":"CategoryTheory.Limits.wideEqualizer.ι","line":494,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι","doc":"If a wide equalizer of `f` exists, we can access the inclusion `wideEqualizer f ⟶ X` by\nsaying `wideEqualizer.ι f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\">CategoryTheory.Limits.wideEqualizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L489-L490","name":"CategoryTheory.Limits.wideEqualizer","line":489,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer","doc":"If a wide equalizer of `f` exists, we can access an arbitrary choice of such by\nsaying `wideEqualizer f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">C</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L482-L483","name":"CategoryTheory.Limits.HasWideEqualizer","line":482,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer","doc":"`HasWideEqualizer f` represents a particular choice of limiting cone for the parallel family of\nmorphisms `f`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasWideEqualizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L469-L472","name":"CategoryTheory.Limits.Cotrident.ext","line":469,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ext","doc":"To construct an isomorphism between cotridents,\nit suffices to give an isomorphism between the cocone points\nand check that it commutes with the `π` morphisms.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Tactics.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">s</span>.π</span> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">t</span>.π</span></span>)</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5462\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L457-L463","name":"CategoryTheory.Limits.Cotrident.mkHom","line":457,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.mkHom","doc":"Helper function for constructing morphisms between coequalizer cotridents.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.mkHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">mkHom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Tactics.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">s</span>.π</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">t</span>.π</span></span>)</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5380\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L456-L456","name":"CategoryTheory.Limits.Cotrident.mkHom_hom","line":456,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.mkHom_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.mkHom_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">mkHom_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Tactics.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">s</span>.π</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">t</span>.π</span></span>)</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5380\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.mkHom\">CategoryTheory.Limits.Cotrident.mkHom</a> <span class=\"fn\">k</span> <span class=\"fn\">w</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L449-L452","name":"CategoryTheory.Limits.Trident.ext","line":449,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext","doc":"To construct an isomorphism between tridents,\nit suffices to give an isomorphism between the cone points\nand check that it commutes with the `ι` morphisms.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Tactics.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span>)</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5249\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L448-L448","name":"CategoryTheory.Limits.Trident.ext_inv","line":448,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ext_inv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Tactics.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span>)</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5249\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext\">CategoryTheory.Limits.Trident.ext</a> <span class=\"fn\">i</span> <span class=\"fn\">w</span></span>)</span>.inv</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom\">CategoryTheory.Limits.Trident.mkHom</a> <span class=\"fn\"><span class=\"fn\">i</span>.inv</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L448-L448","name":"CategoryTheory.Limits.Trident.ext_hom","line":448,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ext_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Tactics.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span>)</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5249\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext\">CategoryTheory.Limits.Trident.ext</a> <span class=\"fn\">i</span> <span class=\"fn\">w</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom\">CategoryTheory.Limits.Trident.mkHom</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\">w</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L436-L442","name":"CategoryTheory.Limits.Trident.mkHom","line":436,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom","doc":"Helper function for constructing morphisms between wide equalizer tridents.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">mkHom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Tactics.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span>)</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5167\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L435-L435","name":"CategoryTheory.Limits.Trident.mkHom_hom","line":435,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">mkHom_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Tactics.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span>)</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5167\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom\">CategoryTheory.Limits.Trident.mkHom</a> <span class=\"fn\">k</span> <span class=\"fn\">w</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L429-L431","name":"CategoryTheory.Limits.Cotrident.ofCocone_ι","line":429,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofCocone_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofCocone_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ofCocone_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofCocone\">CategoryTheory.Limits.Cotrident.ofCocone</a> <span class=\"fn\">t</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L424-L426","name":"CategoryTheory.Limits.Trident.ofCone_π","line":424,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofCone_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofCone_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ofCone_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone\">CategoryTheory.Limits.Cone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofCone\">CategoryTheory.Limits.Trident.ofCone</a> <span class=\"fn\">t</span></span>)</span>.π</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L416-L421","name":"CategoryTheory.Limits.Cotrident.ofCocone","line":416,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofCocone","doc":"Given `F : WalkingParallelFamily ⥤ C`, which is really the same as\n`parallelFamily (F.map left) (F.map right)` and a cocone on `F`, we get a cotrident on\n`fun j ↦ F.map (line j)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofCocone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ofCocone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L406-L411","name":"CategoryTheory.Limits.Trident.ofCone","line":406,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofCone","doc":"Given `F : WalkingParallelFamily ⥤ C`, which is really the same as\n`parallelFamily (fun j ↦ F.map (line j))` and a cone on `F`, we get a trident on\n`fun j ↦ F.map (line j)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofCone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ofCone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone\">CategoryTheory.Limits.Cone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L398-L401","name":"CategoryTheory.Limits.Cocone.ofCotrident_ι","line":398,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cocone.ofCotrident_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cocone.ofCotrident_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cocone</span>.<span class=\"name\">ofCotrident_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cocone.ofCotrident\">CategoryTheory.Limits.Cocone.ofCotrident</a> <span class=\"fn\">t</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L393-L395","name":"CategoryTheory.Limits.Cone.ofTrident_π","line":393,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cone.ofTrident_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cone.ofTrident_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cone</span>.<span class=\"name\">ofTrident_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cone.ofTrident\">CategoryTheory.Limits.Cone.ofTrident</a> <span class=\"fn\">t</span></span>)</span>.π</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L385-L390","name":"CategoryTheory.Limits.Cocone.ofCotrident","line":385,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cocone.ofCotrident","doc":"This is a helper construction that can be useful when verifying that a category has all\ncoequalizers. Given `F : WalkingParallelFamily ⥤ C`, which is really the same as\n`parallelFamily (fun j ↦ F.map (line j))`, and a cotrident on `fun j ↦ F.map (line j)` we get a\ncocone on `F`.\n\nIf you're thinking about using this, have a look at\n`hasWideCoequalizers_of_hasColimit_parallelFamily`, which you may find to be an easier way\nof achieving your goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cocone.ofCotrident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cocone</span>.<span class=\"name\">ofCotrident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L370-L375","name":"CategoryTheory.Limits.Cone.ofTrident","line":370,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cone.ofTrident","doc":"This is a helper construction that can be useful when verifying that a category has certain wide\nequalizers. Given `F : WalkingParallelFamily ⥤ C`, which is really the same as\n`parallelFamily (fun j ↦ F.map (line j))`, and a trident on `fun j ↦ F.map (line j)`,\nwe get a cone on `F`.\n\nIf you're thinking about using this, have a look at\n`hasWideEqualizers_of_hasLimit_parallelFamily`, which you may find to be an easier way of\nachieving your goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cone.ofTrident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cone</span>.<span class=\"name\">ofTrident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone\">CategoryTheory.Limits.Cone</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L356-L360","name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso_natural","line":356,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_natural","doc":"The bijection of `Cotrident.IsColimit.homIso` is natural in `Z`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_natural\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso_natural</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(q : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso\">CategoryTheory.Limits.Cotrident.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z'</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">q</span></span>)</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso\">CategoryTheory.Limits.Cotrident.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span>)</span> <span class=\"fn\">q</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L348-L353","name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso","line":348,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso","doc":"Given a colimit cocone for the family `f : J → (X ⟶ Y)`, for any `Z`, morphisms from the cocone\npoint to `Z` are in bijection with morphisms `h : Z ⟶ X` such that\n`∀ j₁ j₂, f j₁ ≫ h = f j₂ ≫ h`.  Further, this bijection is natural in `Z`: see\n`Cotrident.IsColimit.homIso_natural`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a>   <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span> //\n    <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">h</span></span></span></span> }</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L347-L347","name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso_apply_coe","line":347,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_apply_coe","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_apply_coe\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso_apply_coe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso\">CategoryTheory.Limits.Cotrident.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">t</span>.π</span> <span class=\"fn\">k</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L347-L347","name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso_symm_apply","line":347,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_symm_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_symm_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso_symm_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span> //\n  <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">h</span></span></span></span> }</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso\">CategoryTheory.Limits.Cotrident.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span>.symm</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.desc'\">CategoryTheory.Limits.Cotrident.IsColimit.desc'</a> <span class=\"fn\">ht</span> <span class=\"fn\">↑<span class=\"fn\">h</span></span> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L336-L340","name":"CategoryTheory.Limits.Trident.IsLimit.homIso_natural","line":336,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_natural","doc":"The bijection of `Trident.IsLimit.homIso` is natural in `Z`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_natural\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso_natural</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(q : <span class=\"fn\"><span class=\"fn\">Z'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso\">CategoryTheory.Limits.Trident.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z'</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">q</span> <span class=\"fn\">k</span></span>)</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">q</span> <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso\">CategoryTheory.Limits.Trident.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L328-L333","name":"CategoryTheory.Limits.Trident.IsLimit.homIso","line":328,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso","doc":"Given a limit cone for the family `f : J → (X ⟶ Y)`, for any `Z`, morphisms from `Z` to its point\nare in bijection with morphisms `h : Z ⟶ X` such that `∀ j₁ j₂, h ≫ f j₁ = h ≫ f j₂`.\nFurther, this bijection is natural in `Z`: see `Trident.Limits.homIso_natural`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a>   <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> //\n    <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span> }</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L327-L327","name":"CategoryTheory.Limits.Trident.IsLimit.homIso_apply_coe","line":327,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_apply_coe","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_apply_coe\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso_apply_coe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso\">CategoryTheory.Limits.Trident.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L327-L327","name":"CategoryTheory.Limits.Trident.IsLimit.homIso_symm_apply","line":327,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_symm_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_symm_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso_symm_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> //\n  <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span> }</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso\">CategoryTheory.Limits.Trident.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span>.symm</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.lift'\">CategoryTheory.Limits.Trident.IsLimit.lift'</a> <span class=\"fn\">ht</span> <span class=\"fn\">↑<span class=\"fn\">h</span></span> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L315-L320","name":"CategoryTheory.Limits.Cotrident.IsColimit.mk'","line":315,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.mk'","doc":"This is another convenient method to verify that a cotrident is a colimit cocone. It\nonly asks for a proof of facts that carry any mathematical content, and allows access to the\nsame `s` for all parts. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.mk'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">mk'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(create : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>) →\n  <span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span> //\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">t</span>.π</span> <span class=\"fn\">l</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.π</span></span> <a href=\"./Init/Prelude.html#And\">∧</a>       <span class=\"fn\">∀\n        {<span class=\"fn\">m</span> :\n          <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n              <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>             <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n              <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span></span>},\n        <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">t</span>.π</span> <span class=\"fn\">m</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.π</span></span> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></span></span></span> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L300-L310","name":"CategoryTheory.Limits.Cotrident.IsColimit.mk","line":300,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.mk","doc":"This is a slightly more convenient method to verify that a cotrident is a colimit cocone. It\nonly asks for a proof of facts that carry any mathematical content "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.mk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(desc : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fac : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">t</span>.π</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">desc</span> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.π</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(uniq : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>) (<span class=\"fn\">m</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>),\n  <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">j</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>),\n      <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">m</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">j</span></span></span></span>)</span> →\n    <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">desc</span> <span class=\"fn\">s</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L292-L296","name":"CategoryTheory.Limits.Trident.IsLimit.mk'","line":292,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.mk'","doc":"This is another convenient method to verify that a trident is a limit cone. It\nonly asks for a proof of facts that carry any mathematical content, and allows access to the\nsame `s` for all parts. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.mk'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">mk'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(create : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>) →\n  <span class=\"fn\">{ <span class=\"fn\">l</span> :\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n        <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>       <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n        <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span></span> //\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span> <a href=\"./Init/Prelude.html#And\">∧</a>       <span class=\"fn\">∀\n        {<span class=\"fn\">m</span> :\n          <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n              <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>             <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n              <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span></span>},\n        <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">m</span> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></span></span></span> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L277-L287","name":"CategoryTheory.Limits.Trident.IsLimit.mk","line":277,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.mk","doc":"This is a slightly more convenient method to verify that a trident is a limit cone. It\nonly asks for a proof of facts that carry any mathematical content "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.mk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lift : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fac : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">lift</span> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(uniq : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>) (<span class=\"fn\">m</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>),\n  <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">j</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>),\n      <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">m</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">j</span></span></span></span>)</span> →\n    <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">lift</span> <span class=\"fn\">s</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L271-L273","name":"CategoryTheory.Limits.Cotrident.IsColimit.desc'","line":271,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.desc'","doc":"If `s` is a colimit cotrident over `f`, then a morphism `k : Y ⟶ W` satisfying\n`∀ j₁ j₂, f j₁ ≫ k = f j₂ ≫ k` induces a morphism `l : s.X ⟶ W` such that\n`Cotrident.π s ≫ l = k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.desc'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">desc'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">k</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span> // <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">s</span>.π</span> <span class=\"fn\">l</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L264-L266","name":"CategoryTheory.Limits.Trident.IsLimit.lift'","line":264,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.lift'","doc":"If `s` is a limit trident over `f`, then a morphism `k : W ⟶ X` satisfying\n`∀ j₁ j₂, k ≫ f j₁ = k ≫ f j₂` induces a morphism `l : W ⟶ s.X` such that\n`l ≫ Trident.ι s = k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.lift'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">lift'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span> // <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L257-L259","name":"CategoryTheory.Limits.Cotrident.IsColimit.hom_ext","line":257,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.hom_ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">s</span>.π</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">s</span>.π</span> <span class=\"fn\">l</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L253-L255","name":"CategoryTheory.Limits.Trident.IsLimit.hom_ext","line":253,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.hom_ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L248-L251","name":"CategoryTheory.Limits.Cotrident.coequalizer_ext","line":248,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.coequalizer_ext","doc":"To check whether two maps are coequalized by both maps of a cotrident, it suffices to check it\nfor the second map "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.coequalizer_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">coequalizer_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">s</span>.π</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">s</span>.π</span> <span class=\"fn\">l</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">l</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L241-L244","name":"CategoryTheory.Limits.Trident.equalizer_ext","line":241,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.equalizer_ext","doc":"To check whether two maps are equalized by both maps of a trident, it suffices to check it for\nthe first map "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.equalizer_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">equalizer_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\"><span class=\"fn\">s</span>.ι</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L236-L237","name":"CategoryTheory.Limits.Cotrident.condition","line":236,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\"><span class=\"fn\">t</span>.π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\"><span class=\"fn\">t</span>.π</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L235-L235","name":"CategoryTheory.Limits.Cotrident.condition_assoc","line":235,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">t</span>.π</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">t</span>.π</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L232-L233","name":"CategoryTheory.Limits.Trident.condition","line":232,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L231-L231","name":"CategoryTheory.Limits.Trident.condition_assoc","line":231,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">t</span>.ι</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L227-L229","name":"CategoryTheory.Limits.Cotrident.π_ofπ","line":227,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π_ofπ","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π_ofπ\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">π_ofπ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">π</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ\">CategoryTheory.Limits.Cotrident.ofπ</a> <span class=\"fn\">π</span> <span class=\"fn\">w</span></span>)</span>.π</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">π</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L223-L225","name":"CategoryTheory.Limits.Trident.ι_ofι","line":223,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι_ofι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι_ofι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ι_ofι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι\">CategoryTheory.Limits.Trident.ofι</a> <span class=\"fn\">ι</span> <span class=\"fn\">w</span></span>)</span>.ι</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">ι</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L211-L220","name":"CategoryTheory.Limits.Cotrident.ofπ","line":211,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ","doc":"A cotrident on `f : J → (X ⟶ Y)` is determined by the morphism `π : Y ⟶ P` satisfying\n`∀ j₁ j₂, f j₁ ≫ π = f j₂ ≫ π`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ofπ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">π</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L210-L210","name":"CategoryTheory.Limits.Cotrident.ofπ_pt","line":210,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ_pt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ_pt\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ofπ_pt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">π</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ\">CategoryTheory.Limits.Cotrident.ofπ</a> <span class=\"fn\">π</span> <span class=\"fn\">w</span></span>)</span>.pt</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">P</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L210-L210","name":"CategoryTheory.Limits.Cotrident.ofπ_ι_app","line":210,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ_ι_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ_ι_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ofπ_ι_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">π</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ\">CategoryTheory.Limits.Cotrident.ofπ</a> <span class=\"fn\">π</span> <span class=\"fn\">w</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.casesOn\">CategoryTheory.Limits.WalkingParallelFamily.casesOn</a> <span class=\"fn\">X</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Logic/Nonempty.html#Classical.arbitrary\">Classical.arbitrary</a> <span class=\"fn\">J</span></span>)</span></span>)</span> <span class=\"fn\">π</span></span>)</span> <span class=\"fn\">π</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L196-L205","name":"CategoryTheory.Limits.Trident.ofι","line":196,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι","doc":"A trident on `f : J → (X ⟶ Y)` is determined by the morphism `ι : P ⟶ X` satisfying\n`∀ j₁ j₂, ι ≫ f j₁ = ι ≫ f j₂`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ofι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L195-L195","name":"CategoryTheory.Limits.Trident.ofι_pt","line":195,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι_pt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι_pt\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ofι_pt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι\">CategoryTheory.Limits.Trident.ofι</a> <span class=\"fn\">ι</span> <span class=\"fn\">w</span></span>)</span>.pt</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">P</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L195-L195","name":"CategoryTheory.Limits.Trident.ofι_π_app","line":195,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι_π_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι_π_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ofι_π_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X✝</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span><span class=\"fn\">j₂</span> : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι\">CategoryTheory.Limits.Trident.ofι</a> <span class=\"fn\">ι</span> <span class=\"fn\">w</span></span>)</span>.π</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.casesOn\">CategoryTheory.Limits.WalkingParallelFamily.casesOn</a> <span class=\"fn\">X</span> <span class=\"fn\">ι</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Logic/Nonempty.html#Classical.arbitrary\">Classical.arbitrary</a> <span class=\"fn\">J</span></span>)</span></span>)</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L189-L190","name":"CategoryTheory.Limits.Cotrident.app_one","line":189,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.app_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.app_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">app_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L188-L188","name":"CategoryTheory.Limits.Cotrident.app_one_assoc","line":188,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.app_one_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.app_one_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">app_one_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L185-L186","name":"CategoryTheory.Limits.Trident.app_zero","line":185,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.app_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.app_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">app_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L184-L184","name":"CategoryTheory.Limits.Trident.app_zero_assoc","line":184,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.app_zero_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.app_zero_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">app_zero_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L181-L182","name":"CategoryTheory.Limits.Cotrident.π_eq_app_one","line":181,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π_eq_app_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π_eq_app_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">π_eq_app_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L177-L178","name":"CategoryTheory.Limits.Trident.ι_eq_app_zero","line":177,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι_eq_app_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι_eq_app_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ι_eq_app_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L173-L174","name":"CategoryTheory.Limits.Cotrident.π","line":173,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π","doc":"A cotrident `t` on the parallel family `f : J → (X ⟶ Y)` consists of two morphisms\n`t.ι.app zero : X ⟶ t.X` and `t.ι.app one : Y ⟶ t.X`. Of these, only the second one is\ninteresting, and we give it the shorter name `Cotrident.π t`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span>.obj</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L167-L168","name":"CategoryTheory.Limits.Trident.ι","line":167,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι","doc":"A trident `t` on the parallel family `f : J → (X ⟶ Y)` consists of two morphisms\n`t.π.app zero : t.X ⟶ X` and `t.π.app one : t.X ⟶ Y`. Of these, only the first one is\ninteresting, and we give it the shorter name `Trident.ι t`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span>.obj</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L159-L160","name":"CategoryTheory.Limits.Cotrident","line":159,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident","doc":"A cotrident on `f` and `g` is just a `Cocone (parallelFamily f)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max (max w u) v)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L155-L156","name":"CategoryTheory.Limits.Trident","line":155,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident","doc":"A trident on `f` is just a `Cone (parallelFamily f)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max (max w u) v)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L143-L152","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair","line":143,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair","doc":"`WalkingParallelPair` as a category is equivalent to a special case of\n`WalkingParallelFamily`.  "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L142-L142","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_hom_app","line":142,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_counitIso_hom_app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.counitIso</span>.hom</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L142-L142","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_inv_app","line":142,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_counitIso_inv_app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.counitIso</span>.inv</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L142-L142","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_inv_app","line":142,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_unitIso_inv_app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.unitIso</span>.inv</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L142-L142","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_hom_app","line":142,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_unitIso_hom_app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.unitIso</span>.hom</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L142-L142","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_obj","line":142,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_functor_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.functor</span>.obj</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.rec\">CategoryTheory.Limits.WalkingParallelFamily.rec</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>\n    <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L142-L142","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_map","line":142,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_functor_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.functor</span>.map</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">match <span class=\"fn\">x</span>, <span class=\"fn\">y</span>, <span class=\"fn\">h</span> with\n  | <span class=\"fn\">x</span>, <span class=\"fn\">.(<span class=\"fn\">x</span>)</span>, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.id\">CategoryTheory.Limits.WalkingParallelFamily.Hom.id</a> <span class=\"fn\">.(<span class=\"fn\">x</span>)</span></span> =&gt;\n    <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.rec\">CategoryTheory.Limits.WalkingParallelFamily.rec</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>\n        <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a> <span class=\"fn\">x</span></span>)</span></span>\n  | <span class=\"fn\">.(<span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span>)</span>, <span class=\"fn\">.(<span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span>)</span>,\n    <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span> =&gt;\n    <span class=\"fn\">bif <span class=\"fn\"><span class=\"fn\">j</span>.down</span> then <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a>\n    else <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L142-L142","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_map","line":142,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_inverse_map</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ {<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>} (<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.inverse</span>.map</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\">match <span class=\"fn\">X</span>, <span class=\"fn\">Y</span>, <span class=\"fn\">h</span> with\n    | <span class=\"fn\">x</span>, <span class=\"fn\">.(<span class=\"fn\">x</span>)</span>, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.id\">CategoryTheory.Limits.WalkingParallelPairHom.id</a> <span class=\"fn\">.(<span class=\"fn\">x</span>)</span></span> =&gt;\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a>\n        <span class=\"fn\">(<span class=\"fn\">match <span class=\"fn\">x</span> with\n        | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a> =&gt; <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span>\n        | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a> =&gt; <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span>)</span></span>\n    | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">.(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>)</a>, <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">.(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a>)</a>,\n      <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a> =&gt;\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">{ <span class=\"fn\">down</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>\n    | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">.(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>)</a>, <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">.(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a>)</a>,\n      <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a> =&gt;\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">{ <span class=\"fn\">down</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L142-L142","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_obj","line":142,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_inverse_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.inverse</span>.obj</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">match <span class=\"fn\">x</span> with\n  | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a> =&gt; <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span>\n  | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a> =&gt; <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L135-L138","name":"CategoryTheory.Limits.diagramIsoParallelFamily","line":135,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily","doc":"Every functor indexing a wide (co)equalizer is naturally isomorphic (actually, equal) to a\n`parallelFamily` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">diagramIsoParallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L134-L134","name":"CategoryTheory.Limits.diagramIsoParallelFamily_inv_app","line":134,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">diagramIsoParallelFamily_inv_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily\">CategoryTheory.Limits.diagramIsoParallelFamily</a> <span class=\"fn\">F</span></span>)</span>.inv</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L134-L134","name":"CategoryTheory.Limits.diagramIsoParallelFamily_hom_app","line":134,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">diagramIsoParallelFamily_hom_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily\">CategoryTheory.Limits.diagramIsoParallelFamily</a> <span class=\"fn\">F</span></span>)</span>.hom</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L129-L130","name":"CategoryTheory.Limits.parallelFamily_map_left","line":129,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_map_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_map_left\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelFamily_map_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{j : <span class=\"fn\">J</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L125-L126","name":"CategoryTheory.Limits.parallelFamily_obj_one","line":125,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_obj_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_obj_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelFamily_obj_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span>.obj</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L121-L122","name":"CategoryTheory.Limits.parallelFamily_obj_zero","line":121,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_obj_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_obj_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelFamily_obj_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span>.obj</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L110-L118","name":"CategoryTheory.Limits.parallelFamily","line":110,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily","doc":"`parallelFamily f` is the diagram in `C` consisting of the given family of morphisms, each with\ncommon domain and codomain.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L100-L102","name":"CategoryTheory.Limits.WalkingParallelFamily.hom_id","line":100,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.hom_id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.hom_id\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">hom_id</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.id\">CategoryTheory.Limits.WalkingParallelFamily.Hom.id</a> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L92-L97","name":"CategoryTheory.Limits.WalkingParallelFamily.category","line":92,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.category","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.category\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">category</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory\">CategoryTheory.SmallCategory</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L84-L88","name":"CategoryTheory.Limits.WalkingParallelFamily.Hom.comp","line":84,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.comp","doc":"Composition of morphisms in the indexing diagram for wide (co)equalizers. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.comp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">Hom</span>.<span class=\"name\">comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">Y</span> <span class=\"fn\">Z</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">X</span> <span class=\"fn\">Z</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L79-L79","name":"CategoryTheory.Limits.instInhabitedHomZero","line":79,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instInhabitedHomZero","doc":"Satisfying the inhabited linter "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instInhabitedHomZero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">instInhabitedHomZero</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> v)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L76-L76","name":"CategoryTheory.Limits.WalkingParallelFamily.instDecidableEqHom","line":76,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.instDecidableEqHom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.instDecidableEqHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">instDecidableEqHom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{<span class=\"fn\">J</span> : <a href=\"./foundational_types.html\">Type</a> u_1} →\n  <span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a_1</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>} →\n    <span class=\"fn\">[<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">J</span></span>] → <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">a</span> <span class=\"fn\">a_1</span></span>)</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L75-L75","name":"CategoryTheory.Limits.WalkingParallelFamily.Hom.line","line":75,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">Hom</span>.<span class=\"name\">line</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">J</span> →\n  <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L74-L74","name":"CategoryTheory.Limits.WalkingParallelFamily.Hom.id","line":74,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.id\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">Hom</span>.<span class=\"name\">id</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">X</span> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L72-L76","name":"CategoryTheory.Limits.WalkingParallelFamily.Hom","line":72,"kind":"inductive","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom","doc":"The type family of morphisms for the diagram indexing a wide (co)equalizer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">Hom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span> → <a href=\"./foundational_types.html\">Type</a> w</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L68-L69","name":"CategoryTheory.Limits.instInhabitedWalkingParallelFamily","line":68,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instInhabitedWalkingParallelFamily","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instInhabitedWalkingParallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">instInhabitedWalkingParallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L62-L66","name":"CategoryTheory.Limits.instDecidableEqWalkingParallelFamily","line":62,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instDecidableEqWalkingParallelFamily","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instDecidableEqWalkingParallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">instDecidableEqWalkingParallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L58-L58","name":"CategoryTheory.Limits.WalkingParallelFamily.one","line":58,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L57-L57","name":"CategoryTheory.Limits.WalkingParallelFamily.zero","line":57,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L56-L58","name":"CategoryTheory.Limits.WalkingParallelFamily","line":56,"kind":"inductive","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily","doc":"The type of objects for the diagram indexing a wide (co)equalizer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> w</div></div>"}]}