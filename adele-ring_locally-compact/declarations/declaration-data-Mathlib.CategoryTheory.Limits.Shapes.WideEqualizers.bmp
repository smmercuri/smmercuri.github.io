{"name":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","instances":[{"typeNames":["Eq"],"name":"CategoryTheory.Limits.instDecidableEqWalkingParallelFamily","className":"Decidable"},{"typeNames":["CategoryTheory.Limits.WalkingParallelFamily"],"name":"CategoryTheory.Limits.instInhabitedWalkingParallelFamily","className":"Inhabited"},{"typeNames":["Eq"],"name":"CategoryTheory.Limits.WalkingParallelFamily.instDecidableEqHom","className":"Decidable"},{"typeNames":["CategoryTheory.Limits.WalkingParallelFamily.Hom"],"name":"CategoryTheory.Limits.instInhabitedHomZero","className":"Inhabited"},{"typeNames":["CategoryTheory.Limits.WalkingParallelFamily"],"name":"CategoryTheory.Limits.WalkingParallelFamily.category","className":"CategoryTheory.Category"},{"typeNames":["CategoryTheory.Limits.wideEqualizer.ι"],"name":"CategoryTheory.Limits.wideEqualizer.ι_mono","className":"CategoryTheory.Mono"},{"typeNames":["CategoryTheory.Limits.wideCoequalizer.π"],"name":"CategoryTheory.Limits.wideCoequalizer.π_epi","className":"CategoryTheory.Epi"},{"typeNames":[],"name":"CategoryTheory.Limits.hasEqualizers_of_hasWideEqualizers","className":"CategoryTheory.Limits.HasLimitsOfShape"},{"typeNames":[],"name":"CategoryTheory.Limits.hasCoequalizers_of_hasWideCoequalizers","className":"CategoryTheory.Limits.HasColimitsOfShape"}],"imports":["Init","Mathlib.CategoryTheory.Limits.HasLimits","Mathlib.CategoryTheory.Limits.Shapes.Equalizers"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L814-L816","name":"CategoryTheory.Limits.hasCoequalizers_of_hasWideCoequalizers","line":814,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasCoequalizers_of_hasWideCoequalizers","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasCoequalizers_of_hasWideCoequalizers\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasCoequalizers_of_hasWideCoequalizers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizers\">CategoryTheory.Limits.HasWideCoequalizers</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizers\">CategoryTheory.Limits.HasCoequalizers</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L807-L809","name":"CategoryTheory.Limits.hasEqualizers_of_hasWideEqualizers","line":807,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasEqualizers_of_hasWideEqualizers","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasEqualizers_of_hasWideEqualizers\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasEqualizers_of_hasWideEqualizers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizers\">CategoryTheory.Limits.HasWideEqualizers</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizers\">CategoryTheory.Limits.HasEqualizers</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L799-L802","name":"CategoryTheory.Limits.hasWideCoequalizers_of_hasColimit_parallelFamily","line":799,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasWideCoequalizers_of_hasColimit_parallelFamily","doc":"If `C` has all colimits of diagrams `parallelFamily f`, then it has all wide coequalizers "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasWideCoequalizers_of_hasColimit_parallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasWideCoequalizers_of_hasColimit_parallelFamily</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ {<span class=\"fn\">J</span> : <a href=\"./foundational_types.html\">Type</a> w} {<span class=\"fn\">X </span>Y : <span class=\"fn\">C</span>} {<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimit\">CategoryTheory.Limits.HasColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizers\">CategoryTheory.Limits.HasWideCoequalizers</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L790-L793","name":"CategoryTheory.Limits.hasWideEqualizers_of_hasLimit_parallelFamily","line":790,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasWideEqualizers_of_hasLimit_parallelFamily","doc":"If `C` has all limits of diagrams `parallelFamily f`, then it has all wide equalizers "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.hasWideEqualizers_of_hasLimit_parallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasWideEqualizers_of_hasLimit_parallelFamily</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ {<span class=\"fn\">J</span> : <a href=\"./foundational_types.html\">Type</a> w} {<span class=\"fn\">X </span>Y : <span class=\"fn\">C</span>} {<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasLimit\">CategoryTheory.Limits.HasLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizers\">CategoryTheory.Limits.HasWideEqualizers</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L785-L786","name":"CategoryTheory.Limits.HasWideCoequalizers","line":785,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizers","doc":"`HasWideCoequalizers` represents a choice of wide coequalizer for every family of morphisms "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizers\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasWideCoequalizers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L780-L781","name":"CategoryTheory.Limits.HasWideEqualizers","line":780,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizers","doc":"`HasWideEqualizers` represents a choice of wide equalizer for every family of morphisms "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizers\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasWideEqualizers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L768-L770","name":"CategoryTheory.Limits.epi_of_isColimit_parallelFamily","line":768,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.epi_of_isColimit_parallelFamily","doc":"The wide coequalizer morphism in any colimit cocone is an epimorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.epi_of_isColimit_parallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">epi_of_isColimit_parallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L757-L758","name":"CategoryTheory.Limits.wideCoequalizer.π_epi","line":757,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_epi","doc":"A wide coequalizer morphism is an epimorphism "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_epi\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">π_epi</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L751-L753","name":"CategoryTheory.Limits.wideCoequalizer.hom_ext","line":751,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.hom_ext","doc":"Two maps from a wide coequalizer are equal if they are equal when composed with the wide\ncoequalizer map "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">l</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L743-L745","name":"CategoryTheory.Limits.wideCoequalizer.desc'","line":743,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc'","doc":"Any morphism `k : Y ⟶ W` satisfying `∀ j₁ j₂, f j₁ ≫ k = f j₂ ≫ k` induces a morphism\n`l : wideCoequalizer f ⟶ W` satisfying `wideCoequalizer.π ≫ g = l`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">desc'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">k</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span> //\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">l</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L735-L738","name":"CategoryTheory.Limits.wideCoequalizer.π_desc","line":735,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_desc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_desc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">π_desc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">k</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc\">CategoryTheory.Limits.wideCoequalizer.desc</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L734-L734","name":"CategoryTheory.Limits.wideCoequalizer.π_desc_assoc","line":734,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_desc_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π_desc_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">π_desc_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">k</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc\">CategoryTheory.Limits.wideCoequalizer.desc</a> <span class=\"fn\">k</span> <span class=\"fn\">h✝</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L729-L731","name":"CategoryTheory.Limits.wideCoequalizer.desc","line":729,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc","doc":"Any morphism `k : Y ⟶ W` satisfying `∀ j₁ j₂, f j₁ ≫ k = f j₂ ≫ k` factors through the\nwide coequalizer of `f` via `wideCoequalizer.desc : wideCoequalizer f ⟶ W`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.desc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">desc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">k</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L718-L720","name":"CategoryTheory.Limits.wideCoequalizerIsWideCoequalizer","line":718,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizerIsWideCoequalizer","doc":"The cotrident built from `wideCoequalizer.π f` is colimiting. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizerIsWideCoequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizerIsWideCoequalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ\">CategoryTheory.Limits.Cotrident.ofπ</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L710-L712","name":"CategoryTheory.Limits.wideCoequalizer.condition","line":710,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L709-L709","name":"CategoryTheory.Limits.wideCoequalizer.condition_assoc","line":709,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L702-L704","name":"CategoryTheory.Limits.wideCoequalizer.cotrident_ι_app_one","line":702,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident_ι_app_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident_ι_app_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">cotrident_ι_app_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident\">CategoryTheory.Limits.wideCoequalizer.cotrident</a> <span class=\"fn\">f</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L695-L696","name":"CategoryTheory.Limits.wideCoequalizer.cotrident_π","line":695,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">cotrident_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident\">CategoryTheory.Limits.wideCoequalizer.cotrident</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\">CategoryTheory.Limits.wideCoequalizer.π</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L688-L689","name":"CategoryTheory.Limits.wideCoequalizer.cotrident","line":688,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident","doc":"An arbitrary choice of coequalizer cocone for a parallel family `f`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.cotrident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">cotrident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L682-L683","name":"CategoryTheory.Limits.wideCoequalizer.π","line":682,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π","doc":"If a wideCoequalizer of `f` exists, we can access the corresponding projection by\nsaying `wideCoequalizer.π f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer.π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span>.<span class=\"name\">π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\">CategoryTheory.Limits.wideCoequalizer</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L676-L677","name":"CategoryTheory.Limits.wideCoequalizer","line":676,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer","doc":"If a wide coequalizer of `f`, we can access an arbitrary choice of such by\nsaying `wideCoequalizer f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideCoequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideCoequalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\">CategoryTheory.Limits.HasWideCoequalizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">C</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L668-L669","name":"CategoryTheory.Limits.HasWideCoequalizer","line":668,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer","doc":"`HasWideCoequalizer f g` represents a particular choice of colimiting cocone\nfor the parallel family of morphisms `f`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideCoequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasWideCoequalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L654-L656","name":"CategoryTheory.Limits.mono_of_isLimit_parallelFamily","line":654,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.mono_of_isLimit_parallelFamily","doc":"The wide equalizer morphism in any limit cone is a monomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.mono_of_isLimit_parallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">mono_of_isLimit_parallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone\">CategoryTheory.Limits.Cone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L643-L644","name":"CategoryTheory.Limits.wideEqualizer.ι_mono","line":643,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι_mono","doc":"A wide equalizer morphism is a monomorphism "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι_mono\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">ι_mono</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L637-L639","name":"CategoryTheory.Limits.wideEqualizer.hom_ext","line":637,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.hom_ext","doc":"Two maps into a wide equalizer are equal if they are equal when composed with the wide\nequalizer map. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\">CategoryTheory.Limits.wideEqualizer</a> <span class=\"fn\">f</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\">CategoryTheory.Limits.wideEqualizer</a> <span class=\"fn\">f</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L629-L631","name":"CategoryTheory.Limits.wideEqualizer.lift'","line":629,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift'","doc":"A morphism `k : W ⟶ X` satisfying `∀ j₁ j₂, k ≫ f j₁ = k ≫ f j₂` induces a morphism\n`l : W ⟶ wideEqualizer f` satisfying `l ≫ wideEqualizer.ι f = k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">lift'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\">CategoryTheory.Limits.wideEqualizer</a> <span class=\"fn\">f</span></span></span> //\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L621-L624","name":"CategoryTheory.Limits.wideEqualizer.lift_ι","line":621,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">lift_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift\">CategoryTheory.Limits.wideEqualizer.lift</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L620-L620","name":"CategoryTheory.Limits.wideEqualizer.lift_ι_assoc","line":620,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift_ι_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift_ι_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">lift_ι_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift\">CategoryTheory.Limits.wideEqualizer.lift</a> <span class=\"fn\">k</span> <span class=\"fn\">h✝</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L615-L617","name":"CategoryTheory.Limits.wideEqualizer.lift","line":615,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift","doc":"A morphism `k : W ⟶ X` satisfying `∀ j₁ j₂, k ≫ f j₁ = k ≫ f j₂` factors through the\nwide equalizer of `f` via `wideEqualizer.lift : W ⟶ wideEqualizer f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.lift\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\">CategoryTheory.Limits.wideEqualizer</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L604-L606","name":"CategoryTheory.Limits.wideEqualizerIsWideEqualizer","line":604,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizerIsWideEqualizer","doc":"The wideEqualizer built from `wideEqualizer.ι f` is limiting. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizerIsWideEqualizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizerIsWideEqualizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι\">CategoryTheory.Limits.Trident.ofι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L599-L600","name":"CategoryTheory.Limits.wideEqualizer.condition","line":599,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L598-L598","name":"CategoryTheory.Limits.wideEqualizer.condition_assoc","line":598,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L591-L593","name":"CategoryTheory.Limits.wideEqualizer.trident_π_app_zero","line":591,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident_π_app_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident_π_app_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">trident_π_app_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident\">CategoryTheory.Limits.wideEqualizer.trident</a> <span class=\"fn\">f</span></span>)</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L586-L587","name":"CategoryTheory.Limits.wideEqualizer.trident_ι","line":586,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">trident_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident\">CategoryTheory.Limits.wideEqualizer.trident</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\">CategoryTheory.Limits.wideEqualizer.ι</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L581-L582","name":"CategoryTheory.Limits.wideEqualizer.trident","line":581,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident","doc":"A wide equalizer cone for a parallel family `f`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.trident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">trident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L575-L576","name":"CategoryTheory.Limits.wideEqualizer.ι","line":575,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι","doc":"If a wide equalizer of `f` exists, we can access the inclusion `wideEqualizer f ⟶ X` by\nsaying `wideEqualizer.ι f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer.ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span>.<span class=\"name\">ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\">CategoryTheory.Limits.wideEqualizer</a> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L569-L570","name":"CategoryTheory.Limits.wideEqualizer","line":569,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer","doc":"If a wide equalizer of `f` exists, we can access an arbitrary choice of such by\nsaying `wideEqualizer f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.wideEqualizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">wideEqualizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\">CategoryTheory.Limits.HasWideEqualizer</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">C</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L561-L562","name":"CategoryTheory.Limits.HasWideEqualizer","line":561,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer","doc":"`HasWideEqualizer f` represents a particular choice of limiting cone for the parallel family of\nmorphisms `f`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.HasWideEqualizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasWideEqualizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L547-L550","name":"CategoryTheory.Limits.Cotrident.ext","line":547,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ext","doc":"To construct an isomorphism between cotridents,\nit suffices to give an isomorphism between the cocone points\nand check that it commutes with the `π` morphisms.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5522\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L534-L540","name":"CategoryTheory.Limits.Cotrident.mkHom","line":534,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.mkHom","doc":"Helper function for constructing morphisms between coequalizer cotridents.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.mkHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">mkHom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5416\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L533-L533","name":"CategoryTheory.Limits.Cotrident.mkHom_hom","line":533,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.mkHom_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.mkHom_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">mkHom_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5416\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.mkHom\">CategoryTheory.Limits.Cotrident.mkHom</a> <span class=\"fn\">k</span> <span class=\"fn\">w</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L525-L528","name":"CategoryTheory.Limits.Trident.ext","line":525,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext","doc":"To construct an isomorphism between tridents,\nit suffices to give an isomorphism between the cone points\nand check that it commutes with the `ι` morphisms.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5256\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L524-L524","name":"CategoryTheory.Limits.Trident.ext_inv","line":524,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ext_inv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5256\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext\">CategoryTheory.Limits.Trident.ext</a> <span class=\"fn\">i</span> <span class=\"fn\">w</span></span>)</span>.inv</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom\">CategoryTheory.Limits.Trident.mkHom</a> <span class=\"fn\"><span class=\"fn\">i</span>.inv</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L524-L524","name":"CategoryTheory.Limits.Trident.ext_hom","line":524,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ext_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5256\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ext\">CategoryTheory.Limits.Trident.ext</a> <span class=\"fn\">i</span> <span class=\"fn\">w</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom\">CategoryTheory.Limits.Trident.mkHom</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\">w</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L511-L517","name":"CategoryTheory.Limits.Trident.mkHom","line":511,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom","doc":"Helper function for constructing morphisms between wide equalizer tridents.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">mkHom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5150\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L510-L510","name":"CategoryTheory.Limits.Trident.mkHom_hom","line":510,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">mkHom_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers._hyg.5150\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.mkHom\">CategoryTheory.Limits.Trident.mkHom</a> <span class=\"fn\">k</span> <span class=\"fn\">w</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L503-L505","name":"CategoryTheory.Limits.Cotrident.ofCocone_ι","line":503,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofCocone_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofCocone_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ofCocone_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofCocone\">CategoryTheory.Limits.Cotrident.ofCocone</a> <span class=\"fn\">t</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L497-L499","name":"CategoryTheory.Limits.Trident.ofCone_π","line":497,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofCone_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofCone_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ofCone_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone\">CategoryTheory.Limits.Cone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofCone\">CategoryTheory.Limits.Trident.ofCone</a> <span class=\"fn\">t</span></span>)</span>.π</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L488-L493","name":"CategoryTheory.Limits.Cotrident.ofCocone","line":488,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofCocone","doc":"Given `F : WalkingParallelFamily ⥤ C`, which is really the same as\n`parallelFamily (F.map left) (F.map right)` and a cocone on `F`, we get a cotrident on\n`fun j ↦ F.map (line j)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofCocone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ofCocone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L477-L482","name":"CategoryTheory.Limits.Trident.ofCone","line":477,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofCone","doc":"Given `F : WalkingParallelFamily ⥤ C`, which is really the same as\n`parallelFamily (fun j ↦ F.map (line j))` and a cone on `F`, we get a trident on\n`fun j ↦ F.map (line j)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofCone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ofCone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone\">CategoryTheory.Limits.Cone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L468-L471","name":"CategoryTheory.Limits.Cocone.ofCotrident_ι","line":468,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cocone.ofCotrident_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cocone.ofCotrident_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cocone</span>.<span class=\"name\">ofCotrident_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cocone.ofCotrident\">CategoryTheory.Limits.Cocone.ofCotrident</a> <span class=\"fn\">t</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L462-L464","name":"CategoryTheory.Limits.Cone.ofTrident_π","line":462,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cone.ofTrident_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cone.ofTrident_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cone</span>.<span class=\"name\">ofTrident_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cone.ofTrident\">CategoryTheory.Limits.Cone.ofTrident</a> <span class=\"fn\">t</span></span>)</span>.π</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L453-L458","name":"CategoryTheory.Limits.Cocone.ofCotrident","line":453,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cocone.ofCotrident","doc":"This is a helper construction that can be useful when verifying that a category has all\ncoequalizers. Given `F : WalkingParallelFamily ⥤ C`, which is really the same as\n`parallelFamily (fun j ↦ F.map (line j))`, and a cotrident on `fun j ↦ F.map (line j)` we get a\ncocone on `F`.\n\nIf you're thinking about using this, have a look at\n`hasWideCoequalizers_of_hasColimit_parallelFamily`, which you may find to be an easier way\nof achieving your goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cocone.ofCotrident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cocone</span>.<span class=\"name\">ofCotrident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L437-L442","name":"CategoryTheory.Limits.Cone.ofTrident","line":437,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cone.ofTrident","doc":"This is a helper construction that can be useful when verifying that a category has certain wide\nequalizers. Given `F : WalkingParallelFamily ⥤ C`, which is really the same as\n`parallelFamily (fun j ↦ F.map (line j))`, and a trident on `fun j ↦ F.map (line j)`,\nwe get a cone on `F`.\n\nIf you're thinking about using this, have a look at\n`hasWideEqualizers_of_hasLimit_parallelFamily`, which you may find to be an easier way of\nachieving your goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cone.ofTrident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cone</span>.<span class=\"name\">ofTrident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone\">CategoryTheory.Limits.Cone</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L420-L424","name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso_natural","line":420,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_natural","doc":"The bijection of `Cotrident.IsColimit.homIso` is natural in `Z`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_natural\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso_natural</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(q : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso\">CategoryTheory.Limits.Cotrident.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z'</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">q</span></span>)</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso\">CategoryTheory.Limits.Cotrident.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span>)</span> <span class=\"fn\">q</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L409-L414","name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso","line":409,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso","doc":"Given a colimit cocone for the family `f : J → (X ⟶ Y)`, for any `Z`, morphisms from the cocone\npoint to `Z` are in bijection with morphisms `h : Z ⟶ X` such that\n`∀ j₁ j₂, f j₁ ≫ h = f j₂ ≫ h`.  Further, this bijection is natural in `Z`: see\n`Cotrident.IsColimit.homIso_natural`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a>   <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span> //\n    <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">h</span></span></span></span> }</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L408-L408","name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso_apply_coe","line":408,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_apply_coe","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_apply_coe\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso_apply_coe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso\">CategoryTheory.Limits.Cotrident.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">k</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L408-L408","name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso_symm_apply","line":408,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_symm_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso_symm_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso_symm_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span> //\n  <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">h</span></span></span></span> }</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.homIso\">CategoryTheory.Limits.Cotrident.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span>.symm</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.desc'\">CategoryTheory.Limits.Cotrident.IsColimit.desc'</a> <span class=\"fn\">ht</span> <span class=\"fn\">↑<span class=\"fn\">h</span></span> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L394-L398","name":"CategoryTheory.Limits.Trident.IsLimit.homIso_natural","line":394,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_natural","doc":"The bijection of `Trident.IsLimit.homIso` is natural in `Z`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_natural\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso_natural</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(q : <span class=\"fn\"><span class=\"fn\">Z'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso\">CategoryTheory.Limits.Trident.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z'</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">q</span> <span class=\"fn\">k</span></span>)</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">q</span> <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso\">CategoryTheory.Limits.Trident.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L385-L390","name":"CategoryTheory.Limits.Trident.IsLimit.homIso","line":385,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso","doc":"Given a limit cone for the family `f : J → (X ⟶ Y)`, for any `Z`, morphisms from `Z` to its point\nare in bijection with morphisms `h : Z ⟶ X` such that `∀ j₁ j₂, h ≫ f j₁ = h ≫ f j₂`.\nFurther, this bijection is natural in `Z`: see `Trident.Limits.homIso_natural`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a>   <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> //\n    <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span> }</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L384-L384","name":"CategoryTheory.Limits.Trident.IsLimit.homIso_apply_coe","line":384,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_apply_coe","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_apply_coe\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso_apply_coe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso\">CategoryTheory.Limits.Trident.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L384-L384","name":"CategoryTheory.Limits.Trident.IsLimit.homIso_symm_apply","line":384,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_symm_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso_symm_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso_symm_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> //\n  <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span> }</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.homIso\">CategoryTheory.Limits.Trident.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span>.symm</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.lift'\">CategoryTheory.Limits.Trident.IsLimit.lift'</a> <span class=\"fn\">ht</span> <span class=\"fn\">↑<span class=\"fn\">h</span></span> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L371-L376","name":"CategoryTheory.Limits.Cotrident.IsColimit.mk'","line":371,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.mk'","doc":"This is another convenient method to verify that a cotrident is a colimit cocone. It\nonly asks for a proof of facts that carry any mathematical content, and allows access to the\nsame `s` for all parts. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.mk'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">mk'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(create : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>) →\n  <span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span> //\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">l</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">s</span></span></span> <a href=\"./Init/Prelude.html#And\">∧</a>       <span class=\"fn\">∀\n        {<span class=\"fn\">m</span> :\n          <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n              <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>             <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n              <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span></span>},\n        <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">m</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>             <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">s</span></span></span> →\n          <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></span></span></span> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L355-L365","name":"CategoryTheory.Limits.Cotrident.IsColimit.mk","line":355,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.mk","doc":"This is a slightly more convenient method to verify that a cotrident is a colimit cocone. It\nonly asks for a proof of facts that carry any mathematical content "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.mk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(desc : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fac : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">desc</span> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">s</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(uniq : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>) (<span class=\"fn\">m</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>),\n  <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">j</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>),\n      <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">m</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">j</span></span></span></span>)</span> →\n    <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">desc</span> <span class=\"fn\">s</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L346-L350","name":"CategoryTheory.Limits.Trident.IsLimit.mk'","line":346,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.mk'","doc":"This is another convenient method to verify that a trident is a limit cone. It\nonly asks for a proof of facts that carry any mathematical content, and allows access to the\nsame `s` for all parts. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.mk'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">mk'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(create : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>) →\n  <span class=\"fn\">{ <span class=\"fn\">l</span> :\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n        <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>       <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n        <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span></span> //\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span></span> <a href=\"./Init/Prelude.html#And\">∧</a>       <span class=\"fn\">∀\n        {<span class=\"fn\">m</span> :\n          <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n              <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>             <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n              <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span></span>},\n        <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">m</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span></span> →\n          <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></span></span></span> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L330-L340","name":"CategoryTheory.Limits.Trident.IsLimit.mk","line":330,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.mk","doc":"This is a slightly more convenient method to verify that a trident is a limit cone. It\nonly asks for a proof of facts that carry any mathematical content "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.mk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lift : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fac : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">lift</span> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(uniq : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>) (<span class=\"fn\">m</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>),\n  <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">j</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>),\n      <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">m</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">j</span></span></span></span>)</span> →\n    <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">lift</span> <span class=\"fn\">s</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L321-L323","name":"CategoryTheory.Limits.Cotrident.IsColimit.desc'","line":321,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.desc'","doc":"If `s` is a colimit cotrident over `f`, then a morphism `k : Y ⟶ W` satisfying\n`∀ j₁ j₂, f j₁ ≫ k = f j₂ ≫ k` induces a morphism `l : s.X ⟶ W` such that\n`Cotrident.π s ≫ l = k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.desc'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">desc'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">k</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span> // <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">l</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L313-L315","name":"CategoryTheory.Limits.Trident.IsLimit.lift'","line":313,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.lift'","doc":"If `s` is a limit trident over `f`, then a morphism `k : W ⟶ X` satisfying\n`∀ j₁ j₂, k ≫ f j₁ = k ≫ f j₂` induces a morphism `l : W ⟶ s.X` such that\n`l ≫ Trident.ι s = k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.lift'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">lift'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span> // <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L303-L305","name":"CategoryTheory.Limits.Cotrident.IsColimit.hom_ext","line":303,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.hom_ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.IsColimit.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">l</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L298-L300","name":"CategoryTheory.Limits.Trident.IsLimit.hom_ext","line":298,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.hom_ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.IsLimit.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L290-L293","name":"CategoryTheory.Limits.Cotrident.coequalizer_ext","line":290,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.coequalizer_ext","doc":"To check whether two maps are coequalized by both maps of a cotrident, it suffices to check it\nfor the second map "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.coequalizer_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">coequalizer_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">l</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">l</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L282-L285","name":"CategoryTheory.Limits.Trident.equalizer_ext","line":282,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.equalizer_ext","doc":"To check whether two maps are equalized by both maps of a trident, it suffices to check it for\nthe first map "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.equalizer_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">equalizer_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">s</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L276-L277","name":"CategoryTheory.Limits.Cotrident.condition","line":276,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L275-L275","name":"CategoryTheory.Limits.Cotrident.condition_assoc","line":275,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L271-L272","name":"CategoryTheory.Limits.Trident.condition","line":271,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L270-L270","name":"CategoryTheory.Limits.Trident.condition_assoc","line":270,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j₁ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j₂ : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L265-L267","name":"CategoryTheory.Limits.Cotrident.π_ofπ","line":265,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π_ofπ","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π_ofπ\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">π_ofπ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">π</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ\">CategoryTheory.Limits.Cotrident.ofπ</a> <span class=\"fn\">π</span> <span class=\"fn\">w</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">π</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L260-L262","name":"CategoryTheory.Limits.Trident.ι_ofι","line":260,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι_ofι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι_ofι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ι_ofι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι\">CategoryTheory.Limits.Trident.ofι</a> <span class=\"fn\">ι</span> <span class=\"fn\">w</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">ι</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L247-L256","name":"CategoryTheory.Limits.Cotrident.ofπ","line":247,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ","doc":"A cotrident on `f : J → (X ⟶ Y)` is determined by the morphism `π : Y ⟶ P` satisfying\n`∀ j₁ j₂, f j₁ ≫ π = f j₂ ≫ π`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ofπ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">π</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L246-L246","name":"CategoryTheory.Limits.Cotrident.ofπ_pt","line":246,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ_pt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ_pt\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ofπ_pt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">π</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ\">CategoryTheory.Limits.Cotrident.ofπ</a> <span class=\"fn\">π</span> <span class=\"fn\">w</span></span>)</span>.pt</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">P</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L246-L246","name":"CategoryTheory.Limits.Cotrident.ofπ_ι_app","line":246,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ_ι_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ_ι_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">ofπ_ι_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span> <span class=\"fn\">π</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.ofπ\">CategoryTheory.Limits.Cotrident.ofπ</a> <span class=\"fn\">π</span> <span class=\"fn\">w</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.casesOn\">CategoryTheory.Limits.WalkingParallelFamily.casesOn</a> <span class=\"fn\">X</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Logic/Nonempty.html#Classical.arbitrary\">Classical.arbitrary</a> <span class=\"fn\">J</span></span>)</span></span>)</span> <span class=\"fn\">π</span></span>)</span> <span class=\"fn\">π</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L231-L240","name":"CategoryTheory.Limits.Trident.ofι","line":231,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι","doc":"A trident on `f : J → (X ⟶ Y)` is determined by the morphism `ι : P ⟶ X` satisfying\n`∀ j₁ j₂, ι ≫ f j₁ = ι ≫ f j₂`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ofι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L230-L230","name":"CategoryTheory.Limits.Trident.ofι_pt","line":230,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι_pt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι_pt\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ofι_pt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι\">CategoryTheory.Limits.Trident.ofι</a> <span class=\"fn\">ι</span> <span class=\"fn\">w</span></span>)</span>.pt</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">P</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L230-L230","name":"CategoryTheory.Limits.Trident.ofι_π_app","line":230,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι_π_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι_π_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ofι_π_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X✝</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\">∀ (<span class=\"fn\">j₁ </span>j₂ : <span class=\"fn\">J</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₁</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j₂</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ofι\">CategoryTheory.Limits.Trident.ofι</a> <span class=\"fn\">ι</span> <span class=\"fn\">w</span></span>)</span>.π</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.casesOn\">CategoryTheory.Limits.WalkingParallelFamily.casesOn</a> <span class=\"fn\">X</span> <span class=\"fn\">ι</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Logic/Nonempty.html#Classical.arbitrary\">Classical.arbitrary</a> <span class=\"fn\">J</span></span>)</span></span>)</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L223-L224","name":"CategoryTheory.Limits.Cotrident.app_one","line":223,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.app_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.app_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">app_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L222-L222","name":"CategoryTheory.Limits.Cotrident.app_one_assoc","line":222,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.app_one_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.app_one_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">app_one_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L218-L219","name":"CategoryTheory.Limits.Trident.app_zero","line":218,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.app_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.app_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">app_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L217-L217","name":"CategoryTheory.Limits.Trident.app_zero_assoc","line":217,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.app_zero_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.app_zero_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">app_zero_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L213-L214","name":"CategoryTheory.Limits.Cotrident.π_eq_app_one","line":213,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π_eq_app_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π_eq_app_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">π_eq_app_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\">CategoryTheory.Limits.Cotrident.π</a> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L208-L209","name":"CategoryTheory.Limits.Trident.ι_eq_app_zero","line":208,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι_eq_app_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι_eq_app_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ι_eq_app_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\">CategoryTheory.Limits.Trident.ι</a> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span>.app</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L203-L204","name":"CategoryTheory.Limits.Cotrident.π","line":203,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π","doc":"A cotrident `t` on the parallel family `f : J → (X ⟶ Y)` consists of two morphisms\n`t.ι.app zero : X ⟶ t.X` and `t.ι.app one : Y ⟶ t.X`. Of these, only the second one is\ninteresting, and we give it the shorter name `Cotrident.π t`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident.π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span>.<span class=\"name\">π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\">CategoryTheory.Limits.Cotrident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span>.obj</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L196-L197","name":"CategoryTheory.Limits.Trident.ι","line":196,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι","doc":"A trident `t` on the parallel family `f : J → (X ⟶ Y)` consists of two morphisms\n`t.π.app zero : t.X ⟶ X` and `t.π.app one : t.X ⟶ Y`. Of these, only the first one is\ninteresting, and we give it the shorter name `Trident.ι t`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident.ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span>.<span class=\"name\">ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\">CategoryTheory.Limits.Trident</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span>.obj</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L187-L188","name":"CategoryTheory.Limits.Cotrident","line":187,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident","doc":"A cotrident on `f` and `g` is just a `Cocone (parallelFamily f)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Cotrident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cotrident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max (max w u) v)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L182-L183","name":"CategoryTheory.Limits.Trident","line":182,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident","doc":"A trident on `f` is just a `Cone (parallelFamily f)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.Trident\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Trident</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max (max w u) v)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L167-L176","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair","line":167,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair","doc":"`WalkingParallelPair` as a category is equivalent to a special case of\n`WalkingParallelFamily`.  "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L166-L166","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_hom_app","line":166,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_counitIso_hom_app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.counitIso</span>.hom</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L166-L166","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_inv_app","line":166,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_counitIso_inv_app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.counitIso</span>.inv</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L166-L166","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_inv_app","line":166,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_unitIso_inv_app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.unitIso</span>.inv</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L166-L166","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_hom_app","line":166,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_unitIso_hom_app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.unitIso</span>.hom</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L166-L166","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_obj","line":166,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_functor_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.functor</span>.obj</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.rec\">CategoryTheory.Limits.WalkingParallelFamily.rec</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>\n    <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L166-L166","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_map","line":166,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_functor_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#ULift\">ULift.{w, 0}</a>    <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.functor</span>.map</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">match <span class=\"fn\">x</span>, <span class=\"fn\">y</span>, <span class=\"fn\">h</span> with\n  | <span class=\"fn\">x</span>, <span class=\"fn\">.(<span class=\"fn\">x</span>)</span>, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.id</a> <span class=\"fn\">.(<span class=\"fn\">x</span>)</span></span> =&gt;\n    <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.rec\">CategoryTheory.Limits.WalkingParallelFamily.rec</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>\n        <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a> <span class=\"fn\">x</span></span>)</span></span>\n  | <span class=\"fn\">.(<span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span>)</span>, <span class=\"fn\">.(<span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span>)</span>,\n    <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span> =&gt;\n    <span class=\"fn\">bif <span class=\"fn\"><span class=\"fn\">j</span>.down</span> then <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a>\n    else <span class=\"fn\">CategoryTheory.Limits.WalkingParallelPairHom.right</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L166-L166","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_map","line":166,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_inverse_map</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ {<span class=\"fn\">X </span>Y : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>} (<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.inverse</span>.map</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\">match <span class=\"fn\">X</span>, <span class=\"fn\">Y</span>, <span class=\"fn\">h</span> with\n    | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">x</a>, <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">.(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">x</a>)</a>, <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.id\">CategoryTheory.Limits.WalkingParallelPairHom.id</a> <span class=\"fn\">.(<span class=\"fn\">x</span>)</span></a> =&gt;\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a>\n        <span class=\"fn\">(<span class=\"fn\">match <span class=\"fn\">x</span> with\n        | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.zero</a> =&gt; <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span>\n        | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a> =&gt; <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelFamily.one</a></span>)</span></span>\n    | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">.(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>)</a>, <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">.(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a>)</a>,\n      <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.left</a> =&gt;\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">{ <span class=\"fn\">down</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>\n    | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">.(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>)</a>, <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">.(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a>)</a>,\n      <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a> =&gt;\n      <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">{ <span class=\"fn\">down</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span></a></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L166-L166","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_obj","line":166,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelFamilyEquivWalkingParallelPair_inverse_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair\">CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair</a>.inverse</span>.obj</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">match <span class=\"fn\">x</span> with\n  | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.zero</a> =&gt; <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span>\n  | <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a> =&gt; <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelFamily.one</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L156-L159","name":"CategoryTheory.Limits.diagramIsoParallelFamily","line":156,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily","doc":"Every functor indexing a wide (co)equalizer is naturally isomorphic (actually, equal) to a\n`parallelFamily` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">diagramIsoParallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L155-L155","name":"CategoryTheory.Limits.diagramIsoParallelFamily_inv_app","line":155,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">diagramIsoParallelFamily_inv_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily\">CategoryTheory.Limits.diagramIsoParallelFamily</a> <span class=\"fn\">F</span></span>)</span>.inv</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L155-L155","name":"CategoryTheory.Limits.diagramIsoParallelFamily_hom_app","line":155,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">diagramIsoParallelFamily_hom_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.diagramIsoParallelFamily\">CategoryTheory.Limits.diagramIsoParallelFamily</a> <span class=\"fn\">F</span></span>)</span>.hom</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L147-L148","name":"CategoryTheory.Limits.parallelFamily_map_left","line":147,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_map_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_map_left\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelFamily_map_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{j : <span class=\"fn\">J</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\">CategoryTheory.Limits.WalkingParallelFamily.Hom.line</a> <span class=\"fn\">j</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L142-L143","name":"CategoryTheory.Limits.parallelFamily_obj_one","line":142,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_obj_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_obj_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelFamily_obj_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span>.obj</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L137-L138","name":"CategoryTheory.Limits.parallelFamily_obj_zero","line":137,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_obj_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily_obj_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelFamily_obj_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\">CategoryTheory.Limits.parallelFamily</a> <span class=\"fn\">f</span></span>)</span>.obj</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L125-L133","name":"CategoryTheory.Limits.parallelFamily","line":125,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily","doc":"`parallelFamily f` is the diagram in `C` consisting of the given family of morphisms, each with\ncommon domain and codomain.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.parallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L112-L114","name":"CategoryTheory.Limits.WalkingParallelFamily.hom_id","line":112,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.hom_id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.hom_id\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">hom_id</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.id\">CategoryTheory.Limits.WalkingParallelFamily.Hom.id</a> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L101-L106","name":"CategoryTheory.Limits.WalkingParallelFamily.category","line":101,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.category","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.category\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">category</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory\">CategoryTheory.SmallCategory</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L90-L94","name":"CategoryTheory.Limits.WalkingParallelFamily.Hom.comp","line":90,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.comp","doc":"Composition of morphisms in the indexing diagram for wide (co)equalizers. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.comp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">Hom</span>.<span class=\"name\">comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">Y</span> <span class=\"fn\">Z</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">X</span> <span class=\"fn\">Z</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L85-L85","name":"CategoryTheory.Limits.instInhabitedHomZero","line":85,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instInhabitedHomZero","doc":"Satisfying the inhabited linter "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instInhabitedHomZero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">instInhabitedHomZero</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> v)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L79-L79","name":"CategoryTheory.Limits.WalkingParallelFamily.instDecidableEqHom","line":79,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.instDecidableEqHom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.instDecidableEqHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">instDecidableEqHom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{<span class=\"fn\">J</span> : <a href=\"./foundational_types.html\">Type</a> u_1} →\n  <span class=\"fn\">{<span class=\"fn\">a </span>a_1 : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>} →\n    <span class=\"fn\">[<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">J</span></span>] → <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">a</span> <span class=\"fn\">a_1</span></span>)</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L78-L78","name":"CategoryTheory.Limits.WalkingParallelFamily.Hom.line","line":78,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.line\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">Hom</span>.<span class=\"name\">line</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">J</span> →\n  <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.zero</span>\n    <span class=\"fn\">CategoryTheory.Limits.WalkingParallelFamily.one</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L77-L77","name":"CategoryTheory.Limits.WalkingParallelFamily.Hom.id","line":77,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom.id\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">Hom</span>.<span class=\"name\">id</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\">CategoryTheory.Limits.WalkingParallelFamily.Hom</a> <span class=\"fn\">J</span> <span class=\"fn\">X</span> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L75-L79","name":"CategoryTheory.Limits.WalkingParallelFamily.Hom","line":75,"kind":"inductive","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom","doc":"The type family of morphisms for the diagram indexing a wide (co)equalizer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.Hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">Hom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span> → <a href=\"./foundational_types.html\">Type</a> w</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L71-L72","name":"CategoryTheory.Limits.instInhabitedWalkingParallelFamily","line":71,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instInhabitedWalkingParallelFamily","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instInhabitedWalkingParallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">instInhabitedWalkingParallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L65-L69","name":"CategoryTheory.Limits.instDecidableEqWalkingParallelFamily","line":65,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instDecidableEqWalkingParallelFamily","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.instDecidableEqWalkingParallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">instDecidableEqWalkingParallelFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L60-L60","name":"CategoryTheory.Limits.WalkingParallelFamily.one","line":60,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L59-L59","name":"CategoryTheory.Limits.WalkingParallelFamily.zero","line":59,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily.zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span>.<span class=\"name\">zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\">CategoryTheory.Limits.WalkingParallelFamily</a> <span class=\"fn\">J</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean#L58-L60","name":"CategoryTheory.Limits.WalkingParallelFamily","line":58,"kind":"inductive","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily","doc":"The type of objects for the diagram indexing a wide (co)equalizer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.html#CategoryTheory.Limits.WalkingParallelFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelFamily</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> w</div></div>"}]}