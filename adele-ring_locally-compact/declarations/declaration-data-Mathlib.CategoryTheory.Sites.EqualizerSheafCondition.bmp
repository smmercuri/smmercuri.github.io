{"name":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","instances":[{"typeNames":["CategoryTheory.Equalizer.FirstObj"],"name":"CategoryTheory.Equalizer.instInhabitedFirstObjBotPresieve","className":"Inhabited"},{"typeNames":["CategoryTheory.Equalizer.FirstObj"],"name":"CategoryTheory.Equalizer.instInhabitedFirstObjArrowsBotSieve","className":"Inhabited"},{"typeNames":["CategoryTheory.Equalizer.Sieve.SecondObj"],"name":"CategoryTheory.Equalizer.Sieve.instInhabitedSecondObjBotSieve","className":"Inhabited"},{"typeNames":["CategoryTheory.Equalizer.Presieve.SecondObj"],"name":"CategoryTheory.Equalizer.Presieve.instInhabitedSecondObjBotPresieve","className":"Inhabited"}],"imports":["Init","Mathlib.CategoryTheory.Sites.IsSheafFor","Mathlib.CategoryTheory.Limits.Shapes.Types","Mathlib.Tactic.ApplyFun"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L329-L345","name":"CategoryTheory.Equalizer.Presieve.Arrows.sheaf_condition","line":329,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.sheaf_condition","doc":"`P` is a sheaf for `Presieve.ofArrows X π`, iff the fork given by `w` is an equalizer.\nSee <https://stacks.math.columbia.edu/tag/00VM>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.sheaf_condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">sheaf_condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> w)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap\">CategoryTheory.Equalizer.Presieve.Arrows.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L314-L323","name":"CategoryTheory.Equalizer.Presieve.Arrows.compatible_iff","line":314,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.compatible_iff","doc":"The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.compatible_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">compatible_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> w)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.Arrows.Compatible\">CategoryTheory.Presieve.Arrows.Compatible</a> <span class=\"fn\">P</span> <span class=\"fn\">π</span>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso\">CategoryTheory.Limits.Types.productIso</a> <span class=\"fn\">fun (<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span>)</span></span>)</span></span></span></span>)</span>.hom</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.firstMap\">CategoryTheory.Equalizer.Presieve.Arrows.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.secondMap\">CategoryTheory.Equalizer.Presieve.Arrows.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span> <span class=\"fn\">x</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L305-L308","name":"CategoryTheory.Equalizer.Presieve.Arrows.w","line":305,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.w","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.w\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">w</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> w)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap\">CategoryTheory.Equalizer.Presieve.Arrows.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.firstMap\">CategoryTheory.Equalizer.Presieve.Arrows.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap\">CategoryTheory.Equalizer.Presieve.Arrows.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.secondMap\">CategoryTheory.Equalizer.Presieve.Arrows.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L302-L303","name":"CategoryTheory.Equalizer.Presieve.Arrows.secondMap","line":302,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.secondMap","doc":"The second of the two parallel morphisms of the fork diagram, induced by the second projection in\neach pullback.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.secondMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">secondMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> w)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj\">CategoryTheory.Equalizer.Presieve.Arrows.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L295-L296","name":"CategoryTheory.Equalizer.Presieve.Arrows.firstMap","line":295,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.firstMap","doc":"The first of the two parallel morphisms of the fork diagram, induced by the first projection in\neach pullback.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.firstMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">firstMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> w)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj\">CategoryTheory.Equalizer.Presieve.Arrows.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L289-L289","name":"CategoryTheory.Equalizer.Presieve.Arrows.forkMap","line":289,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap","doc":"The left morphism of the fork diagram.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">forkMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> w)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">B</span></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L280-L284","name":"CategoryTheory.Equalizer.Presieve.Arrows.SecondObj.ext","line":280,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">SecondObj</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> w)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(z₁ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj\">CategoryTheory.Equalizer.Presieve.Arrows.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(z₂ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj\">CategoryTheory.Equalizer.Presieve.Arrows.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">ij</span> : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">I</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">ij</span> : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">I</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.pullback\">CategoryTheory.Limits.pullback</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">π</span> <span class=\"fn\"><span class=\"fn\">ij</span>.1</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">π</span> <span class=\"fn\"><span class=\"fn\">ij</span>.2</span></span>)</span></span>)</span></span>)</span></span></span>)</span> <span class=\"fn\">ij</span> <span class=\"fn\">z₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">ij</span> : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">I</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.pullback\">CategoryTheory.Limits.pullback</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">π</span> <span class=\"fn\"><span class=\"fn\">ij</span>.1</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">π</span> <span class=\"fn\"><span class=\"fn\">ij</span>.2</span></span>)</span></span>)</span></span>)</span></span></span>)</span> <span class=\"fn\">ij</span> <span class=\"fn\">z₂</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">z₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">z₂</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L276-L277","name":"CategoryTheory.Equalizer.Presieve.Arrows.SecondObj","line":276,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj","doc":"The rightmost object of the fork diagram of https://stacks.math.columbia.edu/tag/00VM.\nThe difference between this and `Equalizer.Presieve.SecondObj P (ofArrows X π)` arrises if the\nfamily of arrows `π` contains duplicates. The `Presieve.ofArrows` doesn't see those.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">SecondObj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> w)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> w</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L265-L269","name":"CategoryTheory.Equalizer.Presieve.Arrows.FirstObj.ext","line":265,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">FirstObj</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> w)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(z₁ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(z₂ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">I</span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span>)</span></span>)</span></span></span>)</span> <span class=\"fn\">i</span> <span class=\"fn\">z₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span>)</span></span>)</span></span></span>)</span> <span class=\"fn\">i</span> <span class=\"fn\">z₂</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">z₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">z₂</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L262-L262","name":"CategoryTheory.Equalizer.Presieve.Arrows.FirstObj","line":262,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj","doc":"The middle object of the fork diagram of <https://stacks.math.columbia.edu/tag/00VM>.\nThe difference between this and `Equalizer.FirstObj P (ofArrows X π)` arrises if the family of\narrows `π` contains duplicates. The `Presieve.ofArrows` doesn't see those.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">FirstObj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> w)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> w</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L230-L245","name":"CategoryTheory.Equalizer.Presieve.sheaf_condition","line":230,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.sheaf_condition","doc":"`P` is a sheaf for `R`, iff the fork given by `w` is an equalizer.\nSee <https://stacks.math.columbia.edu/tag/00VM>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.sheaf_condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">sheaf_condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">R</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L215-L225","name":"CategoryTheory.Equalizer.Presieve.compatible_iff","line":215,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.compatible_iff","doc":"The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.compatible_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">compatible_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">R</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily\">CategoryTheory.Equalizer.firstObjEqFamily</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>.hom</span> <span class=\"fn\">x</span></span>)</span>.Compatible</span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.firstMap\">CategoryTheory.Equalizer.Presieve.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.secondMap\">CategoryTheory.Equalizer.Presieve.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span> <span class=\"fn\">x</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L202-L209","name":"CategoryTheory.Equalizer.Presieve.w","line":202,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.w","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.w\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">w</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">R</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.firstMap\">CategoryTheory.Equalizer.Presieve.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.secondMap\">CategoryTheory.Equalizer.Presieve.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L197-L200","name":"CategoryTheory.Equalizer.Presieve.secondMap","line":197,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.secondMap","doc":"The map `pr₁*` of <https://stacks.math.columbia.edu/tag/00VL>. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.secondMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">secondMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">R</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.SecondObj\">CategoryTheory.Equalizer.Presieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L193-L194","name":"CategoryTheory.Equalizer.Presieve.instInhabitedSecondObjBotPresieve","line":193,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.instInhabitedSecondObjBotPresieve","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.instInhabitedSecondObjBotPresieve\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">instInhabitedSecondObjBotPresieve</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPullbacks\">CategoryTheory.Limits.HasPullbacks</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.SecondObj\">CategoryTheory.Equalizer.Presieve.SecondObj</a> <span class=\"fn\">P</span> <a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L188-L191","name":"CategoryTheory.Equalizer.Presieve.firstMap","line":188,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.firstMap","doc":"The map `pr₀*` of <https://stacks.math.columbia.edu/tag/00VL>. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.firstMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">firstMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">R</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.SecondObj\">CategoryTheory.Equalizer.Presieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L182-L185","name":"CategoryTheory.Equalizer.Presieve.SecondObj","line":182,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.SecondObj","doc":"The rightmost object of the fork diagram of https://stacks.math.columbia.edu/tag/00VM, which\ncontains the data used to check a family of elements for a presieve is compatible.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.SecondObj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">SecondObj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">R</span>.hasPullbacks</span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max v u)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L146-L164","name":"CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition","line":146,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition","doc":"`P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">equalizer_sheaf_condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L133-L143","name":"CategoryTheory.Equalizer.Sieve.compatible_iff","line":133,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.compatible_iff","doc":"The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.compatible_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">compatible_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily\">CategoryTheory.Equalizer.firstObjEqFamily</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span>.hom</span> <span class=\"fn\">x</span></span>)</span>.Compatible</span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.firstMap\">CategoryTheory.Equalizer.Sieve.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.secondMap\">CategoryTheory.Equalizer.Sieve.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span> <span class=\"fn\">x</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L125-L127","name":"CategoryTheory.Equalizer.Sieve.w","line":125,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.w","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.w\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">w</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.firstMap\">CategoryTheory.Equalizer.Sieve.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.secondMap\">CategoryTheory.Equalizer.Sieve.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L122-L123","name":"CategoryTheory.Equalizer.Sieve.secondMap","line":122,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.secondMap","doc":"The map `a` of Equations (3,4) [MM92]. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.secondMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">secondMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\">CategoryTheory.Equalizer.Sieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L118-L119","name":"CategoryTheory.Equalizer.Sieve.instInhabitedSecondObjBotSieve","line":118,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.instInhabitedSecondObjBotSieve","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.instInhabitedSecondObjBotSieve\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">instInhabitedSecondObjBotSieve</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\">CategoryTheory.Equalizer.Sieve.SecondObj</a> <span class=\"fn\">P</span> <a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L114-L116","name":"CategoryTheory.Equalizer.Sieve.firstMap","line":114,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.firstMap","doc":"The map `p` of Equations (3,4) [MM92]. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.firstMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">firstMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\">CategoryTheory.Equalizer.Sieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L104-L109","name":"CategoryTheory.Equalizer.Sieve.SecondObj.ext","line":104,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">SecondObj</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(z₁ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\">CategoryTheory.Equalizer.Sieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(z₂ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\">CategoryTheory.Equalizer.Sieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">Y </span><span class=\"fn\">Z</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>) (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>) (<span class=\"fn\">hf</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">S</span>.arrows</span> <span class=\"fn\">f</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>) × <span class=\"fn\">(<span class=\"fn\">Z</span> : <span class=\"fn\">C</span>) × <span class=\"fn\">(_ : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>) × <span class=\"fn\">{ <span class=\"fn\">f'</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">S</span>.arrows</span> <span class=\"fn\">f'</span></span> }</span></span></span></span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.snd</span>.fst</span></span>)</span></span></span>)</span>\n      <span class=\"fn\">⟨<span class=\"fn\">Y</span>, <span class=\"fn\">⟨<span class=\"fn\">Z</span>, <span class=\"fn\">⟨<span class=\"fn\">g</span>, <span class=\"fn\">⟨<span class=\"fn\">f</span>, <span class=\"fn\">hf</span>⟩</span>⟩</span>⟩</span>⟩</span> <span class=\"fn\">z₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>) × <span class=\"fn\">(<span class=\"fn\">Z</span> : <span class=\"fn\">C</span>) × <span class=\"fn\">(_ : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>) × <span class=\"fn\">{ <span class=\"fn\">f'</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">S</span>.arrows</span> <span class=\"fn\">f'</span></span> }</span></span></span></span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.snd</span>.fst</span></span>)</span></span></span>)</span>\n      <span class=\"fn\">⟨<span class=\"fn\">Y</span>, <span class=\"fn\">⟨<span class=\"fn\">Z</span>, <span class=\"fn\">⟨<span class=\"fn\">g</span>, <span class=\"fn\">⟨<span class=\"fn\">f</span>, <span class=\"fn\">hf</span>⟩</span>⟩</span>⟩</span>⟩</span> <span class=\"fn\">z₂</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">z₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">z₂</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L97-L98","name":"CategoryTheory.Equalizer.Sieve.SecondObj","line":97,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj","doc":"The rightmost object of the fork diagram of Equation (3) [MM92], which contains the data used\nto check a family is compatible.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">SecondObj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max v u)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L83-L84","name":"CategoryTheory.Equalizer.forkMap","line":83,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap","doc":"The left morphism of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram\nof <https://stacks.math.columbia.edu/tag/00VM>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">forkMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">X</span></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L76-L77","name":"CategoryTheory.Equalizer.instInhabitedFirstObjArrowsBotSieve","line":76,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.instInhabitedFirstObjArrowsBotSieve","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.instInhabitedFirstObjArrowsBotSieve\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">instInhabitedFirstObjArrowsBotSieve</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\"><a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a>.arrows</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L72-L73","name":"CategoryTheory.Equalizer.instInhabitedFirstObjBotPresieve","line":72,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.instInhabitedFirstObjBotPresieve","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.instInhabitedFirstObjBotPresieve\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">instInhabitedFirstObjBotPresieve</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L68-L70","name":"CategoryTheory.Equalizer.firstObjEqFamily","line":68,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily","doc":"Show that `FirstObj` is isomorphic to `FamilyOfElements`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">firstObjEqFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements\">CategoryTheory.Presieve.FamilyOfElements</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L67-L67","name":"CategoryTheory.Equalizer.firstObjEqFamily_inv","line":67,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">firstObjEqFamily_inv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements\">CategoryTheory.Presieve.FamilyOfElements</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily\">CategoryTheory.Equalizer.firstObjEqFamily</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>.inv</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.lift\">CategoryTheory.Limits.Pi.lift</a>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>) × <span class=\"fn\">{ <span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span> }</span></span>) (<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements\">CategoryTheory.Presieve.FamilyOfElements</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <span class=\"fn\">↑<span class=\"fn\"><span class=\"fn\">f</span>.snd</span></span> <span class=\"fn\">⋯</span></span></span>)</span> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L67-L67","name":"CategoryTheory.Equalizer.firstObjEqFamily_hom","line":67,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">firstObjEqFamily_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily\">CategoryTheory.Equalizer.firstObjEqFamily</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>.hom</span> <span class=\"fn\">t</span> <span class=\"fn\">f</span> <span class=\"fn\">hf</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>) × <span class=\"fn\">{ <span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span> }</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\"><span class=\"fn\">f</span>.fst</span></span>)</span></span></span>)</span> <span class=\"fn\">⟨<span class=\"fn\">Y</span>, <span class=\"fn\">⟨<span class=\"fn\">f</span>, <span class=\"fn\">hf</span>⟩</span>⟩</span> <span class=\"fn\">t</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L57-L62","name":"CategoryTheory.Equalizer.FirstObj.ext","line":57,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">FirstObj</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(z₁ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(z₂ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>) (<span class=\"fn\">hf</span> : <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>) × <span class=\"fn\">{ <span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span> }</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\"><span class=\"fn\">f</span>.fst</span></span>)</span></span></span>)</span> <span class=\"fn\">⟨<span class=\"fn\">Y</span>, <span class=\"fn\">⟨<span class=\"fn\">f</span>, <span class=\"fn\">hf</span>⟩</span>⟩</span> <span class=\"fn\">z₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>) × <span class=\"fn\">{ <span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span> }</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\"><span class=\"fn\">f</span>.fst</span></span>)</span></span></span>)</span> <span class=\"fn\">⟨<span class=\"fn\">Y</span>, <span class=\"fn\">⟨<span class=\"fn\">f</span>, <span class=\"fn\">hf</span>⟩</span>⟩</span> <span class=\"fn\">z₂</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">z₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">z₂</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L50-L51","name":"CategoryTheory.Equalizer.FirstObj","line":50,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj","doc":"The middle object of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram\nof <https://stacks.math.columbia.edu/tag/00VM>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">FirstObj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max v u)</div></div>"}]}