{"name":"Mathlib.Data.Ordmap.Ordnode","instances":[{"typeNames":["Ordnode"],"name":"Ordnode.instEmptyCollectionOrdnode","className":"EmptyCollection"},{"typeNames":["Ordnode"],"name":"Ordnode.instInhabitedOrdnode","className":"Inhabited"},{"typeNames":["Ordnode"],"name":"Ordnode.instSingletonOrdnode","className":"Singleton"},{"typeNames":["Ordnode"],"name":"Ordnode.instReprOrdnode","className":"Repr"},{"typeNames":["Ordnode.All"],"name":"Ordnode.All.decidable","className":"Decidable"},{"typeNames":["Ordnode.Any"],"name":"Ordnode.Any.decidable","className":"Decidable"},{"typeNames":["Ordnode.Emem"],"name":"Ordnode.Emem.decidable","className":"Decidable"},{"typeNames":["Ordnode.Amem"],"name":"Ordnode.Amem.decidable","className":"Decidable"},{"typeNames":["Ordnode"],"name":"Ordnode.instToStringOrdnode","className":"ToString"},{"typeNames":["Ordnode"],"name":"Ordnode.instToFormatOrdnode","className":"Std.ToFormat"},{"typeNames":["Ordnode.Equiv"],"name":"Ordnode.instDecidableRelOrdnodeEquiv","className":"Decidable"},{"typeNames":["Ordnode"],"name":"Ordnode.instMembershipOrdnode","className":"Membership"},{"typeNames":["Membership.mem"],"name":"Ordnode.mem.decidable","className":"Decidable"},{"typeNames":["Ordnode"],"name":"Ordnode.instInsertOrdnode","className":"Insert"}],"imports":["Init","Mathlib.Order.Compare","Mathlib.Data.List.Defs","Mathlib.Data.Nat.PSub","Mathlib.Data.Option.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1355-L1356","name":"Ordnode.image","line":1355,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image","doc":"O(n * log n). Map a function on a set. Unlike `map` this has no requirements on\n`f`, and the resulting set may be smaller than the input if `f` is noninjective.\nEquivalent elements are selected with a preference for smaller source elements.\n\n    image (fun x ↦ x + 2) {1, 2, 4} = {3, 4, 6}\n    image (fun x : ℕ ↦ x - 2) {1, 2, 4} = {0, 2} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image\"><span class=\"name\">Ordnode</span>.<span class=\"name\">image</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">β</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1344-L1346","name":"Ordnode.ofList'","line":1344,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'","doc":"O(n * log n). Adaptively chooses between the linear and log-linear algorithm depending\non whether the input list is already sorted.\n\n  ofList' [1, 2, 3] = {1, 2, 3}\n  ofList' [2, 1, 1, 3] = {1, 2, 3} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofList'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1335-L1336","name":"Ordnode.ofList","line":1335,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList","doc":"O(n * log n). Build a set from a list, preferring elements that appear earlier in the list\nin the case of equivalent elements.\n\n    ofList [1, 2, 3] = {1, 2, 3}\n    ofList [2, 1, 1, 3] = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    ofList [(1, 1), (0, 1), (1, 2)] = {(0, 1), (1, 1)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1316-L1323","name":"Ordnode.inter","line":1316,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter","doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. Intersection of two sets, preferring members of\n`t₁` over those of `t₂` when equivalent elements are encountered.\n\n    inter {1, 2} {2, 3} = {2}\n    inter {1, 3} {2} = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter\"><span class=\"name\">Ordnode</span>.<span class=\"name\">inter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1301-L1308","name":"Ordnode.diff","line":1301,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff","doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. Difference of two sets.\n\ndiff {1, 2} {2, 3} = {1}\ndiff {1, 2, 3} {2} = {1, 3} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff\"><span class=\"name\">Ordnode</span>.<span class=\"name\">diff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1285-L1294","name":"Ordnode.union","line":1285,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union","doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. The union of two sets, preferring members of\n`t₁` over those of `t₂` when equivalent elements are encountered.\n\n  union {1, 2} {2, 3} = {1, 2, 3}\n  union {1, 3} {2} = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n  union {(1, 1)} {(0, 1), (1, 2)} = {(0, 1), (1, 1)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union\"><span class=\"name\">Ordnode</span>.<span class=\"name\">union</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1268-L1273","name":"Ordnode.disjoint","line":1268,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint","doc":"O(m + n). Is every element of `t₁` not equivalent to any element of `t₂`?\n\ndisjoint {1, 3} {2, 4} = tt\ndisjoint {1, 2} {2, 4} = ff "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint\"><span class=\"name\">Ordnode</span>.<span class=\"name\">disjoint</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1260-L1261","name":"Ordnode.isSubset","line":1260,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset","doc":"O(m + n). Is every element of `t₁` equivalent to some element of `t₂`?\n\nis_subset {1, 4} {1, 2, 4} = tt\nis_subset {1, 3} {1, 2, 4} = ff "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset\"><span class=\"name\">Ordnode</span>.<span class=\"name\">isSubset</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t₁ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t₂ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1248-L1253","name":"Ordnode.isSubsetAux","line":1248,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux","doc":"Auxiliary definition for `isSubset`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">isSubsetAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1243-L1244","name":"Ordnode.findIndex","line":1243,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex","doc":"O(log n). Get the index, counting from the left,\nof an element equivalent to `x` if it exists.\n\n    findIndex 2 {1, 2, 4} = some 1\n    findIndex 4 {1, 2, 4} = some 2\n    findIndex 5 {1, 2, 4} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findIndex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1228-L1234","name":"Ordnode.findIndexAux","line":1228,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux","doc":"Auxiliary definition for `findIndex`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findIndexAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1218-L1224","name":"Ordnode.findGe","line":1218,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe","doc":"O(log n). Get the smallest element in the tree that is `≥ x`.\n\nfindGe 2 {1, 2, 4} = some 2\nfindGe 3 {1, 2, 4} = some 4\nfindGe 5 {1, 2, 4} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1203-L1209","name":"Ordnode.findGeAux","line":1203,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux","doc":"Auxiliary definition for `findGe`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGeAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1193-L1199","name":"Ordnode.findLe","line":1193,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe","doc":"O(log n). Get the largest element in the tree that is `≤ x`.\n\nfindLe 2 {1, 2, 4} = some 2\nfindLe 3 {1, 2, 4} = some 2\nfindLe 0 {1, 2, 4} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1179-L1185","name":"Ordnode.findLeAux","line":1179,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux","doc":"Auxiliary definition for `findLe`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLeAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1173-L1175","name":"Ordnode.findGt","line":1173,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt","doc":"O(log n). Get the smallest element in the tree that is `> x`.\n\nfindGt 2 {1, 2, 4} = some 4\nfindGt 3 {1, 2, 4} = some 4\nfindGt 4 {1, 2, 4} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1163-L1165","name":"Ordnode.findGtAux","line":1163,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux","doc":"Auxiliary definition for `findGt`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGtAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1157-L1159","name":"Ordnode.findLt","line":1157,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt","doc":"O(log n). Get the largest element in the tree that is `< x`.\n\nfindLt 2 {1, 2, 4} = some 1\nfindLt 3 {1, 2, 4} = some 2\nfindLt 0 {1, 2, 4} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1147-L1149","name":"Ordnode.findLtAux","line":1147,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux","doc":"Auxiliary definition for `findLt`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLtAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1137-L1143","name":"Ordnode.erase","line":1137,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase","doc":"O(log n). Remove an element from the set equivalent to `x`. Does nothing if there\nis no such element.\n\n    erase 1 {1, 2, 3} = {2, 3}\n    erase 4 {1, 2, 3} = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    erase (1, 1) {(0, 1), (1, 2)} = {(0, 1)}\n    erase (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase\"><span class=\"name\">Ordnode</span>.<span class=\"name\">erase</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1114-L1124","name":"Ordnode.split3","line":1114,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3","doc":"O(log n). Split the tree into those smaller than `x` and those greater than it,\nplus an element equivalent to `x`, if it exists.\n\n    split3 2 {1, 2, 4} = ({1}, some 2, {4})\n    split3 3 {1, 2, 4} = ({1, 2}, none, {4})\n    split3 4 {1, 2, 4} = ({1, 2}, some 4, ∅)\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    split3 (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, some (1, 2), ∅)\n    split3 (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, none, ∅) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3\"><span class=\"name\">Ordnode</span>.<span class=\"name\">split3</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1090-L1100","name":"Ordnode.split","line":1090,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split","doc":"O(log n). Split the tree into those smaller than `x` and those greater than it.\nIf an element equivalent to `x` is in the set, it is discarded.\n\n    split 2 {1, 2, 4} = ({1}, {4})\n    split 3 {1, 2, 4} = ({1, 2}, {4})\n    split 4 {1, 2, 4} = ({1, 2}, ∅)\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    split (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, ∅)\n    split (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, ∅) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split\"><span class=\"name\">Ordnode</span>.<span class=\"name\">split</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1070-L1076","name":"Ordnode.insert'","line":1070,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'","doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, the set is returned as is.\n\n    insert' 1 {1, 2, 3} = {1, 2, 3}\n    insert' 4 {1, 2, 3} = {1, 2, 3, 4}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insert' (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)}\n    insert' (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insert'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1057-L1058","name":"Ordnode.instInsertOrdnode","line":1057,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInsertOrdnode","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInsertOrdnode\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instInsertOrdnode</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Insert\">Insert</a> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1048-L1054","name":"Ordnode.insert","line":1048,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert","doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, this replaces it.\n\n    insert 1 {1, 2, 3} = {1, 2, 3}\n    insert 4 {1, 2, 3} = {1, 2, 3, 4}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insert (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 1)}\n    insert (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insert</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1026-L1035","name":"Ordnode.alter","line":1026,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter","doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    alter f 0 {1, 2, 3} = {1, 2, 3}     if f none = none\n                        = {a, 1, 2, 3}  if f none = some a\n    alter f 1 {1, 2, 3} = {2, 3}     if f 1 = none\n                        = {a, 2, 3}  if f 1 = some a "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter\"><span class=\"name\">Ordnode</span>.<span class=\"name\">alter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L1006-L1015","name":"Ordnode.updateWith","line":1006,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith","doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    updateWith f 0 {1, 2, 3} = {1, 2, 3}\n    updateWith f 1 {1, 2, 3} = {2, 3}     if f 1 = none\n                              = {a, 2, 3}  if f 1 = some a "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith\"><span class=\"name\">Ordnode</span>.<span class=\"name\">updateWith</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L990-L996","name":"Ordnode.adjustWith","line":990,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith","doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    adjustWith f 0 {1, 2, 3} = {1, 2, 3}\n    adjustWith f 1 {1, 2, 3} = {f 1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    adjustWith f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}\n    adjustWith f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith\"><span class=\"name\">Ordnode</span>.<span class=\"name\">adjustWith</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L970-L976","name":"Ordnode.insertWith","line":970,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith","doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, the function `f` is used to generate\nthe element to insert (being passed the current value in the set).\n\n    insertWith f 0 {1, 2, 3} = {0, 1, 2, 3}\n    insertWith f 1 {1, 2, 3} = {f 1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insertWith f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}\n    insertWith f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insertWith</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L955-L956","name":"Ordnode.mem.decidable","line":955,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">mem</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">t</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L952-L953","name":"Ordnode.instMembershipOrdnode","line":952,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instMembershipOrdnode","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instMembershipOrdnode\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instMembershipOrdnode</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Membership\">Membership</a> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L943-L949","name":"Ordnode.find","line":943,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find","doc":"O(log n). Retrieve an element in the set that is equivalent to `x` in the order,\nif it exists.\n\n    find 1 {1, 2, 3} = some 1\n    find 4 {1, 2, 3} = none\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    find (1, 1) {(0, 1), (1, 2)} = some (1, 2)\n    find (3, 1) {(0, 1), (1, 2)} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find\"><span class=\"name\">Ordnode</span>.<span class=\"name\">find</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L924-L930","name":"Ordnode.mem","line":924,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem","doc":"O(log n). Does the set (approximately) contain the element `x`? That is,\nis there an element that is equivalent to `x` in the order?\n\n    1 ∈ {1, 2, 3} = true\n    4 ∈ {1, 2, 3} = false\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    (1, 1) ∈ {(0, 1), (1, 2)} = true\n    (3, 1) ∈ {(0, 1), (1, 2)} = false "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem\"><span class=\"name\">Ordnode</span>.<span class=\"name\">mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L905-L907","name":"Ordnode.ofAscList","line":905,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList","doc":"O(n). Build a set from a list which is already sorted. Performs no comparisons.\n\nofAscList [1, 2, 3] = {1, 2, 3}\nofAscList [3, 2, 1] = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofAscList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L891-L898","name":"Ordnode.ofAscListAux₂","line":891,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂","doc":"Auxiliary definition for `ofAscList`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofAscListAux₂</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L876-L887","name":"Ordnode.ofAscListAux₁","line":876,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₁","doc":"Auxiliary definition for `ofAscList`.\n\n**Note:** This function is defined by well founded recursion, so it will probably not compute\nin the kernel, meaning that you probably can't prove things like\n`ofAscList [1, 2, 3] = {1, 2, 3}` by `rfl`.\nThis implementation is optimized for VM evaluation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₁\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofAscListAux₁</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">{ <span class=\"fn\">l'</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> // <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List.length\">List.length</a> <span class=\"fn\">l'</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List.length\">List.length</a> <span class=\"fn\">l</span></span></span> }</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L859-L867","name":"Ordnode.span","line":859,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span","doc":"O(log n). Split the set into those satisfying and not satisfying the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    span (fun x ↦ x < 4) {1, 2, 3, 4, 5} = ({1, 2, 3}, {4, 5})\n    span (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span\"><span class=\"name\">Ordnode</span>.<span class=\"name\">span</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L849-L851","name":"Ordnode.dropWhile","line":849,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile","doc":"O(log n). Remove an initial segment of the set that satisfies the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    dropWhile (fun x ↦ x < 4) {1, 2, 3, 4, 5} = {4, 5}\n    dropWhile (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile\"><span class=\"name\">Ordnode</span>.<span class=\"name\">dropWhile</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L839-L841","name":"Ordnode.takeWhile","line":839,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile","doc":"O(log n). Get an initial segment of the set that satisfies the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    takeWhile (fun x ↦ x < 4) {1, 2, 3, 4, 5} = {1, 2, 3}\n    takeWhile (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile\"><span class=\"name\">Ordnode</span>.<span class=\"name\">takeWhile</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L830-L831","name":"Ordnode.splitAt","line":830,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt","doc":"O(log n). Split a set at the `i`th element, getting the first `i` and everything else.\n\nsplitAt 2 {a, b, c, d} = ({a, b}, {c, d})\nsplitAt 5 {a, b, c, d} = ({a, b, c, d}, ∅) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitAt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L811-L823","name":"Ordnode.splitAtAux","line":811,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux","doc":"Auxiliary definition for `splitAt`. (Can also be used in lieu of `splitAt` if you know the\nindex is within the range of the data structure.)\n\n    splitAtAux {a, b, c, d} 2 = ({a, b}, {c, d})\n    splitAtAux {a, b, c, d} 5 = ({a, b, c, d}, ∅) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitAtAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L802-L803","name":"Ordnode.drop","line":802,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop","doc":"O(log n). Remove the first `i` elements of the set, counted from the left.\n\ndrop 2 {a, b, c, d} = {c, d}\ndrop 5 {a, b, c, d} = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop\"><span class=\"name\">Ordnode</span>.<span class=\"name\">drop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L787-L795","name":"Ordnode.dropAux","line":787,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux","doc":"Auxiliary definition for `drop`. (Can also be used in lieu of `drop` if you know the\nindex is within the range of the data structure.)\n\n    drop_aux {a, b, c, d} 2 = {c, d}\n    drop_aux {a, b, c, d} 5 = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">dropAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L778-L779","name":"Ordnode.take","line":778,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take","doc":"O(log n). Get the first `i` elements of the set, counted from the left.\n\ntake 2 {a, b, c, d} = {a, b}\ntake 5 {a, b, c, d} = {a, b, c, d} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take\"><span class=\"name\">Ordnode</span>.<span class=\"name\">take</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L763-L771","name":"Ordnode.takeAux","line":763,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux","doc":"Auxiliary definition for `take`. (Can also be used in lieu of `take` if you know the\nindex is within the range of the data structure.)\n\n    takeAux {a, b, c, d} 2 = {a, b}\n    takeAux {a, b, c, d} 5 = {a, b, c, d} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">takeAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L749-L755","name":"Ordnode.removeNth","line":749,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth","doc":"O(log n). Remove the `i`th element of the set, by its index from left to right.\n\nremove_nth {a, b, c, d} 2 = {a, b, d}\nremove_nth {a, b, c, d} 5 = {a, b, c, d} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth\"><span class=\"name\">Ordnode</span>.<span class=\"name\">removeNth</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L736-L742","name":"Ordnode.nth","line":736,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth","doc":"O(log n). Get the `i`th element of the set, by its index from left to right.\n\nnth {a, b, c, d} 2 = some c\nnth {a, b, c, d} 5 = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth\"><span class=\"name\">Ordnode</span>.<span class=\"name\">nth</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L728-L729","name":"Ordnode.attach'","line":728,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'","doc":"O(n). \"Attach\" the information that every element of `t` satisfies property\nP to these elements inside the set, producing a set in the subtype.\n\n    attach' (fun x ↦ x < 4) {1, 2} H = ({1, 2} : Ordnode {x // x<4}) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">attach'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\">Ordnode.All</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">{ <span class=\"fn\">a</span> : <span class=\"fn\">α</span> // <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">a</span></span> }</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L719-L721","name":"Ordnode.pmap","line":719,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap","doc":"O(n). Map a partial function across a set. The result depends on a proof\nthat the function is defined on all members of the set.\n\n    pmap (fin.mk : ∀ n, n < 4 → fin 4) {1, 2} H = {(1 : fin 4), (2 : fin 4)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap\"><span class=\"name\">Ordnode</span>.<span class=\"name\">pmap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">a</span></span> → <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\">Ordnode.All</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L703-L704","name":"Ordnode.copair","line":703,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair","doc":"O(m + n). Build a set on the disjoint union by combining sets on the factors.\n`Or.inl a ∈ s.copair t` iff `a ∈ s`, and `Or.inr b ∈ s.copair t` iff `b ∈ t`.\n\n    copair {1, 2} {2, 3} = {inl 1, inl 2, inr 2, inr 3} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair\"><span class=\"name\">Ordnode</span>.<span class=\"name\">copair</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t₁ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t₂ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">β</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L695-L696","name":"Ordnode.prod","line":695,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod","doc":"O(m * n). The cartesian product of two sets: `(a, b) ∈ s.prod t` iff `a ∈ s` and `b ∈ t`.\n\nprod {1, 2} {2, 3} = {(1, 2), (1, 3), (2, 2), (2, 3)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod\"><span class=\"name\">Ordnode</span>.<span class=\"name\">prod</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t₁ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t₂ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">β</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L688-L689","name":"Ordnode.powerset","line":688,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.powerset","doc":"O(2^n). Constructs the powerset of a given set, that is, the set of all subsets.\n\npowerset {1, 2, 3} = {∅, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.powerset\"><span class=\"name\">Ordnode</span>.<span class=\"name\">powerset</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L683-L683","name":"Ordnode.instDecidableRelOrdnodeEquiv","line":683,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelOrdnodeEquiv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelOrdnodeEquiv\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instDecidableRelOrdnodeEquiv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">Ordnode.Equiv</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L679-L680","name":"Ordnode.Equiv","line":679,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv","doc":"O(n). True if the trees have the same elements, ignoring structural differences.\n\nEquiv {1, 2, 4} {2, 1, 1, 4} = true\nEquiv {1, 2, 4} {1, 2, 3} = false "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Equiv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t₁ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t₂ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L672-L673","name":"Ordnode.instToFormatOrdnode","line":672,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToFormatOrdnode","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToFormatOrdnode\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instToFormatOrdnode</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Lean.ToFormat</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Lean.ToFormat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L668-L669","name":"Ordnode.instToStringOrdnode","line":668,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToStringOrdnode","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToStringOrdnode\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instToStringOrdnode</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L664-L665","name":"Ordnode.toRevList","line":664,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList","doc":"O(n). Build a list of elements in descending order from the tree.\n\ntoRevList {1, 2, 4} = [4, 2, 1]\ntoRevList {2, 1, 1, 4} = [4, 2, 1] "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">toRevList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L656-L657","name":"Ordnode.toList","line":656,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList","doc":"O(n). Build a list of elements in ascending order from the tree.\n\ntoList {1, 2, 4} = [1, 2, 4]\ntoList {2, 1, 1, 4} = [1, 2, 4] "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">toList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L647-L649","name":"Ordnode.foldr","line":647,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr","doc":"O(n). Fold a function from right to left (in decreasing order) across the tree.\n\nfoldr f {1, 2, 4} z = f 1 (f 2 (f 4 z)) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr\"><span class=\"name\">Ordnode</span>.<span class=\"name\">foldr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L633-L635","name":"Ordnode.foldl","line":633,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl","doc":"O(n). Fold a function from left to right (in increasing order) across the tree.\n\nfoldl f z {1, 2, 4} = f (f (f z 1) 2) 4 "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl\"><span class=\"name\">Ordnode</span>.<span class=\"name\">foldl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\">β</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L619-L621","name":"Ordnode.fold","line":619,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold","doc":"O(n). Fold a function across the structure of a tree.\n\n     fold z f {1, 2, 4} = f (f z 1 z) 2 (f z 4 z)\n\nThe exact structure of function applications depends on the tree and so\nis unspecified. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold\"><span class=\"name\">Ordnode</span>.<span class=\"name\">fold</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(z : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L602-L604","name":"Ordnode.map","line":602,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map","doc":"O(n). Map a function across a tree, without changing the structure. Only valid when\nthe function is strictly monotone, i.e. `x < y → f x < f y`.\n\n     partition (fun x ↦ x + 2) {1, 2, 4} = {2, 3, 6}\n     partition (fun x : ℕ ↦ x - 2) {1, 2, 4} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map\"><span class=\"name\">Ordnode</span>.<span class=\"name\">map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L583-L588","name":"Ordnode.partition","line":583,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition","doc":"O(n). Split the elements of a tree into those satisfying, and not satisfying, a predicate.\n\npartition (fun x ↦ x < 3) {1, 2, 4} = ({1, 2}, {3}) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition\"><span class=\"name\">Ordnode</span>.<span class=\"name\">partition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L573-L577","name":"Ordnode.filter","line":573,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter","doc":"O(n). Filter the elements of a tree satisfying a predicate.\n\nfilter (fun x ↦ x < 3) {1, 2, 4} = {1, 2}\nfilter (fun x ↦ x > 5) {1, 2, 4} = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter\"><span class=\"name\">Ordnode</span>.<span class=\"name\">filter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L550-L566","name":"Ordnode.link","line":550,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link","doc":"O(log(m+n)). Build a tree from an element between two trees, without any\nassumption on the relative sizes.\n\n    link {1, 2} 4 {5, 6} = {1, 2, 4, 5, 6}\n    link {1, 3} 2 {5} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link\"><span class=\"name\">Ordnode</span>.<span class=\"name\">link</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L540-L542","name":"Ordnode.insertMin","line":540,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin","doc":"O(log n). Insert an element below all the others, without any comparisons.\n(Assumes that the element is in fact below all the others).\n\n    insertMin {1, 2} 0 = {0, 1, 2}\n    insertMin {1, 2} 4 = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insertMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L530-L532","name":"Ordnode.insertMax","line":530,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax","doc":"O(log n). Insert an element above all the others, without any comparisons.\n(Assumes that the element is in fact above all the others).\n\n    insertMax {1, 2} 4 = {1, 2, 4}\n    insertMax {1, 2} 0 = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insertMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L514-L522","name":"Ordnode.merge","line":514,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge","doc":"O(log(m + n)). Concatenate two trees that are ordered with respect to each other.\n\nmerge {1, 2} {3, 4} = {1, 2, 3, 4}\nmerge {3, 4} {1, 2} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge\"><span class=\"name\">Ordnode</span>.<span class=\"name\">merge</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L498-L507","name":"Ordnode.glue","line":498,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue","doc":"**Internal use only**\n\nO(log(m + n)). Concatenate two trees that are balanced and ordered with respect to each other. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue\"><span class=\"name\">Ordnode</span>.<span class=\"name\">glue</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L490-L492","name":"Ordnode.splitMax","line":490,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax","doc":"O(log n). Extract and remove the maximum element from the tree, if it exists.\n\nsplit_max {1, 2, 3} = some ({1, 2}, 3)\nsplit_max ∅ = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">α</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L479-L483","name":"Ordnode.splitMax'","line":479,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'","doc":"**Internal use only**, because it requires a balancing constraint on the inputs.\n\nO(log n). Extract and remove the maximum element from a nonempty tree. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMax'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">α</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L471-L473","name":"Ordnode.splitMin","line":471,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin","doc":"O(log n). Extract and remove the minimum element from the tree, if it exists.\n\nsplit_min {1, 2, 3} = some (1, {2, 3})\nsplit_min ∅ = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L460-L464","name":"Ordnode.splitMin'","line":460,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'","doc":"**Internal use only**, because it requires a balancing constraint on the inputs.\n\nO(log n). Extract and remove the minimum element from a nonempty tree. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMin'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L451-L454","name":"Ordnode.eraseMax","line":451,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax","doc":"O(log n). Remove the maximum element from the tree, or do nothing if it is already empty.\n\neraseMax {1, 2, 3} = {1, 2}\neraseMax ∅ = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">eraseMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L441-L444","name":"Ordnode.eraseMin","line":441,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin","doc":"O(log n). Remove the minimum element from the tree, or do nothing if it is already empty.\n\neraseMin {1, 2, 3} = {2, 3}\neraseMin ∅ = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">eraseMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L432-L434","name":"Ordnode.findMax","line":432,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax","doc":"O(log n). Return the maximum element of the tree, if it exists.\n\nfindMax {1, 2, 3} = some 3\nfindMax ∅ = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L423-L425","name":"Ordnode.findMax'","line":423,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'","doc":"O(log n). Return the maximum element of the tree, or the provided default value.\n\nfindMax' 37 {1, 2, 3} = 3\nfindMax' 37 ∅ = 37 "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMax'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L414-L416","name":"Ordnode.findMin","line":414,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin","doc":"O(log n). Return the minimum element of the tree, if it exists.\n\nfindMin {1, 2, 3} = some 1\nfindMin ∅ = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L405-L407","name":"Ordnode.findMin'","line":405,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'","doc":"O(log n). Return the minimum element of the tree, or the provided default value.\n\nfindMin' 37 {1, 2, 3} = 1\nfindMin' 37 ∅ = 37 "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMin'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L396-L398","name":"Ordnode.Amem.decidable","line":396,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Amem</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem\">Ordnode.Amem</a> <span class=\"fn\">x</span> <span class=\"fn\">t</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L392-L393","name":"Ordnode.Amem","line":392,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem","doc":"O(n). Approximate membership in the set, that is, whether some element in the\nset is equivalent to this one in the preorder. This is useful primarily for stating\ncorrectness properties; use `∈` for a version that actually uses the BST property\nof the tree.\n\n    Amem 2 {1, 2, 3} = true\n    Amem 4 {1, 2, 3} = false\n\nTo see the difference with `Emem`, we need a preorder that is not a partial order.\nFor example, suppose we compare pairs of numbers using only their first coordinate. Then:\n-- Porting note: Verify below example\n    emem (0, 1) {(0, 0), (1, 2)} = false\n    amem (0, 1) {(0, 0), (1, 2)} = true\n    (0, 1) ∈ {(0, 0), (1, 2)} = true\n\nThe `∈` relation is equivalent to `Amem` as long as the `Ordnode` is well formed,\nand should always be used instead of `Amem`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Amem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L371-L372","name":"Ordnode.Emem.decidable","line":371,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Emem</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem\">Ordnode.Emem</a> <span class=\"fn\">x</span> <span class=\"fn\">t</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L367-L368","name":"Ordnode.Emem","line":367,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem","doc":"O(n). Exact membership in the set. This is useful primarily for stating\ncorrectness properties; use `∈` for a version that actually uses the BST property\nof the tree.\n\n    Emem 2 {1, 2, 3} = true\n    Emem 4 {1, 2, 3} = false "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Emem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L353-L358","name":"Ordnode.Any.decidable","line":353,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Any</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">P</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any\">Ordnode.Any</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L348-L350","name":"Ordnode.Any","line":348,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any","doc":"O(n). Does any element of the map satisfy property `P`?\n\nAny (fun x ↦ x < 2) {1, 2, 3} = True\nAny (fun x ↦ x < 2) {2, 3, 5} = False "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Any</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L336-L341","name":"Ordnode.All.decidable","line":336,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">All</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">P</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\">Ordnode.All</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L331-L333","name":"Ordnode.All","line":331,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All","doc":"O(n). Does every element of the map satisfy property `P`?\n\nAll (fun x ↦ x < 5) {1, 2, 3} = True\nAll (fun x ↦ x < 5) {1, 2, 3, 5} = False "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\"><span class=\"name\">Ordnode</span>.<span class=\"name\">All</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L273-L324","name":"Ordnode.balance","line":273,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balance","doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had one side change\nby at most 1. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balance\"><span class=\"name\">Ordnode</span>.<span class=\"name\">balance</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L237-L266","name":"Ordnode.balanceR","line":237,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR","doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had its right\nside grow by 1, or its left side shrink by 1. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR\"><span class=\"name\">Ordnode</span>.<span class=\"name\">balanceR</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L201-L230","name":"Ordnode.balanceL","line":201,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL","doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had its left\nside grow by 1, or its right side shrink by 1. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL\"><span class=\"name\">Ordnode</span>.<span class=\"name\">balanceL</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L193-L194","name":"Ordnode.instReprOrdnode","line":193,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instReprOrdnode","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instReprOrdnode\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instReprOrdnode</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L183-L190","name":"Ordnode.repr","line":183,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr","doc":"Basic pretty printing for `Ordnode α` that shows the structure of the tree.\n\nrepr {3, 1, 2, 4} = ((∅ 1 ∅) 2 ((∅ 3 ∅) 4 ∅)) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr\"><span class=\"name\">Ordnode</span>.<span class=\"name\">repr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(o : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Format/Basic.html#Std.Format\">Lean.Format</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L176-L177","name":"Ordnode.node'","line":176,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'","doc":"**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">node'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L167-L169","name":"Ordnode.dual","line":167,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual","doc":"**Internal use only**, because it violates the BST property on the original order.\n\nO(n). The dual of a tree is a tree with its left and right sides reversed throughout.\nThe dual of a valid BST is valid under the dual order. This is convenient for exploiting\nsymmetries in the algorithms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual\"><span class=\"name\">Ordnode</span>.<span class=\"name\">dual</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L156-L158","name":"Ordnode.empty","line":156,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty","doc":"O(1). Is the set empty?\n\nempty ∅ = tt\nempty {1, 2, 3} = ff "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty\"><span class=\"name\">Ordnode</span>.<span class=\"name\">empty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L147-L149","name":"Ordnode.size_node","line":147,"kind":"theorem","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_node","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_node\"><span class=\"name\">Ordnode</span>.<span class=\"name\">size_node</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(sz : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size\">Ordnode.size</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node\">Ordnode.node</a> <span class=\"fn\">sz</span> <span class=\"fn\">l</span> <span class=\"fn\">x</span> <span class=\"fn\">r</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">sz</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L145-L146","name":"Ordnode.size_nil","line":145,"kind":"theorem","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_nil\"><span class=\"name\">Ordnode</span>.<span class=\"name\">size_nil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size\">Ordnode.size</a> <span class=\"fn\">Ordnode.nil</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L136-L138","name":"Ordnode.size","line":136,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size","doc":"O(1). Get the size of the set.\n\nsize {2, 1, 1, 4} = 3  "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size\"><span class=\"name\">Ordnode</span>.<span class=\"name\">size</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L129-L130","name":"Ordnode.instSingletonOrdnode","line":129,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instSingletonOrdnode","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instSingletonOrdnode\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instSingletonOrdnode</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Singleton\">Singleton</a> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L122-L123","name":"Ordnode.singleton","line":122,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton","doc":"O(1). Construct a singleton set containing value `a`.\n\nsingleton 3 = {3} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton\"><span class=\"name\">Ordnode</span>.<span class=\"name\">singleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L114-L115","name":"Ordnode.ratio","line":114,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio","doc":"**Internal use only**\n\nThe ratio between an outer and inner sibling of the\nheavier subtree in an unbalanced setting. It determines\nwhether a double or single rotation should be performed\nto restore balance. It is corresponds with the inverse\nof `α` in Adam's article. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ratio</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L102-L103","name":"Ordnode.delta","line":102,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta","doc":"**Internal use only**\n\nThe maximal relative difference between the sizes of\ntwo trees, it corresponds with the `w` in Adams' paper.\n\nAccording to the Haskell comment, only `(delta, ratio)` settings\nof `(3, 2)` and `(4, 2)` will work, and the proofs in\n`Ordset.lean` assume `delta := 3` and `ratio := 2`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta\"><span class=\"name\">Ordnode</span>.<span class=\"name\">delta</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L90-L91","name":"Ordnode.instInhabitedOrdnode","line":90,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInhabitedOrdnode","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInhabitedOrdnode\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instInhabitedOrdnode</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L87-L88","name":"Ordnode.instEmptyCollectionOrdnode","line":87,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instEmptyCollectionOrdnode","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instEmptyCollectionOrdnode\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instEmptyCollectionOrdnode</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection\">EmptyCollection</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L77-L77","name":"Ordnode.node","line":77,"kind":"ctor","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node\"><span class=\"name\">Ordnode</span>.<span class=\"name\">node</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(size : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L76-L76","name":"Ordnode.nil","line":76,"kind":"ctor","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil\"><span class=\"name\">Ordnode</span>.<span class=\"name\">nil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Data/Ordmap/Ordnode.lean#L75-L77","name":"Ordnode","line":75,"kind":"inductive","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode","doc":"An `Ordnode α` is a finite set of values, represented as a tree.\nThe operations on this type maintain that the tree is balanced\nand correctly stores subtree sizes at each level. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\"><span class=\"name\">Ordnode</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>"}]}