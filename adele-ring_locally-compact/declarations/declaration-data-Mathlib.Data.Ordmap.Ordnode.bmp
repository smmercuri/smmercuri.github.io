{"name":"Mathlib.Data.Ordmap.Ordnode","instances":[{"typeNames":["Ordnode"],"name":"Ordnode.instEmptyCollection","className":"EmptyCollection"},{"typeNames":["Ordnode"],"name":"Ordnode.instInhabited","className":"Inhabited"},{"typeNames":["Ordnode"],"name":"Ordnode.instSingleton","className":"Singleton"},{"typeNames":["Ordnode"],"name":"Ordnode.instRepr","className":"Repr"},{"typeNames":["Ordnode.All"],"name":"Ordnode.All.decidable","className":"Decidable"},{"typeNames":["Ordnode.Any"],"name":"Ordnode.Any.decidable","className":"Decidable"},{"typeNames":["Ordnode.Emem"],"name":"Ordnode.Emem.decidable","className":"Decidable"},{"typeNames":["Ordnode.Amem"],"name":"Ordnode.Amem.decidable","className":"Decidable"},{"typeNames":["Ordnode"],"name":"Ordnode.instToString","className":"ToString"},{"typeNames":["Ordnode"],"name":"Ordnode.instToFormat","className":"Std.ToFormat"},{"typeNames":["Ordnode.Equiv"],"name":"Ordnode.instDecidableRelEquivOfDecidableEq","className":"Decidable"},{"typeNames":["Ordnode"],"name":"Ordnode.instMembership","className":"Membership"},{"typeNames":["Membership.mem"],"name":"Ordnode.mem.decidable","className":"Decidable"},{"typeNames":["Ordnode"],"name":"Ordnode.instInsert","className":"Insert"}],"imports":["Init","Mathlib.Order.Compare","Mathlib.Data.List.Defs","Mathlib.Data.Nat.PSub","Mathlib.Data.Option.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1222-L1223","name":"Ordnode.image","line":1222,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image","doc":"O(n * log n). Map a function on a set. Unlike `map` this has no requirements on\n`f`, and the resulting set may be smaller than the input if `f` is noninjective.\nEquivalent elements are selected with a preference for smaller source elements.\n\n    image (fun x ↦ x + 2) {1, 2, 4} = {3, 4, 6}\n    image (fun x : ℕ ↦ x - 2) {1, 2, 4} = {0, 2} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image\"><span class=\"name\">Ordnode</span>.<span class=\"name\">image</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">β</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1212-L1214","name":"Ordnode.ofList'","line":1212,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'","doc":"O(n * log n). Adaptively chooses between the linear and log-linear algorithm depending\non whether the input list is already sorted.\n\n  ofList' [1, 2, 3] = {1, 2, 3}\n  ofList' [2, 1, 1, 3] = {1, 2, 3} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofList'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1204-L1205","name":"Ordnode.ofList","line":1204,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList","doc":"O(n * log n). Build a set from a list, preferring elements that appear earlier in the list\nin the case of equivalent elements.\n\n    ofList [1, 2, 3] = {1, 2, 3}\n    ofList [2, 1, 1, 3] = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    ofList [(1, 1), (0, 1), (1, 2)] = {(0, 1), (1, 1)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1186-L1193","name":"Ordnode.inter","line":1186,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter","doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. Intersection of two sets, preferring members of\n`t₁` over those of `t₂` when equivalent elements are encountered.\n\n    inter {1, 2} {2, 3} = {2}\n    inter {1, 3} {2} = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter\"><span class=\"name\">Ordnode</span>.<span class=\"name\">inter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1172-L1179","name":"Ordnode.diff","line":1172,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff","doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. Difference of two sets.\n\ndiff {1, 2} {2, 3} = {1}\ndiff {1, 2, 3} {2} = {1, 3} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff\"><span class=\"name\">Ordnode</span>.<span class=\"name\">diff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1157-L1166","name":"Ordnode.union","line":1157,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union","doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. The union of two sets, preferring members of\n`t₁` over those of `t₂` when equivalent elements are encountered.\n\n  union {1, 2} {2, 3} = {1, 2, 3}\n  union {1, 3} {2} = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n  union {(1, 1)} {(0, 1), (1, 2)} = {(0, 1), (1, 1)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union\"><span class=\"name\">Ordnode</span>.<span class=\"name\">union</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1141-L1146","name":"Ordnode.disjoint","line":1141,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint","doc":"O(m + n). Is every element of `t₁` not equivalent to any element of `t₂`?\n\ndisjoint {1, 3} {2, 4} = tt\ndisjoint {1, 2} {2, 4} = ff "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint\"><span class=\"name\">Ordnode</span>.<span class=\"name\">disjoint</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1134-L1135","name":"Ordnode.isSubset","line":1134,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset","doc":"O(m + n). Is every element of `t₁` equivalent to some element of `t₂`?\n\nis_subset {1, 4} {1, 2, 4} = tt\nis_subset {1, 3} {1, 2, 4} = ff "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset\"><span class=\"name\">Ordnode</span>.<span class=\"name\">isSubset</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t₁ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t₂ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1123-L1128","name":"Ordnode.isSubsetAux","line":1123,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux","doc":"Auxiliary definition for `isSubset`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">isSubsetAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1119-L1120","name":"Ordnode.findIndex","line":1119,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex","doc":"O(log n). Get the index, counting from the left,\nof an element equivalent to `x` if it exists.\n\n    findIndex 2 {1, 2, 4} = some 1\n    findIndex 4 {1, 2, 4} = some 2\n    findIndex 5 {1, 2, 4} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findIndex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1105-L1111","name":"Ordnode.findIndexAux","line":1105,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux","doc":"Auxiliary definition for `findIndex`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findIndexAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1096-L1102","name":"Ordnode.findGe","line":1096,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe","doc":"O(log n). Get the smallest element in the tree that is `≥ x`.\n\nfindGe 2 {1, 2, 4} = some 2\nfindGe 3 {1, 2, 4} = some 4\nfindGe 5 {1, 2, 4} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1082-L1088","name":"Ordnode.findGeAux","line":1082,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux","doc":"Auxiliary definition for `findGe`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGeAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1073-L1079","name":"Ordnode.findLe","line":1073,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe","doc":"O(log n). Get the largest element in the tree that is `≤ x`.\n\nfindLe 2 {1, 2, 4} = some 2\nfindLe 3 {1, 2, 4} = some 2\nfindLe 0 {1, 2, 4} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1060-L1066","name":"Ordnode.findLeAux","line":1060,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux","doc":"Auxiliary definition for `findLe`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLeAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1055-L1057","name":"Ordnode.findGt","line":1055,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt","doc":"O(log n). Get the smallest element in the tree that is `> x`.\n\nfindGt 2 {1, 2, 4} = some 4\nfindGt 3 {1, 2, 4} = some 4\nfindGt 4 {1, 2, 4} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1046-L1048","name":"Ordnode.findGtAux","line":1046,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux","doc":"Auxiliary definition for `findGt`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGtAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1041-L1043","name":"Ordnode.findLt","line":1041,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt","doc":"O(log n). Get the largest element in the tree that is `< x`.\n\nfindLt 2 {1, 2, 4} = some 1\nfindLt 3 {1, 2, 4} = some 2\nfindLt 0 {1, 2, 4} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1032-L1034","name":"Ordnode.findLtAux","line":1032,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux","doc":"Auxiliary definition for `findLt`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLtAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1023-L1029","name":"Ordnode.erase","line":1023,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase","doc":"O(log n). Remove an element from the set equivalent to `x`. Does nothing if there\nis no such element.\n\n    erase 1 {1, 2, 3} = {2, 3}\n    erase 4 {1, 2, 3} = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    erase (1, 1) {(0, 1), (1, 2)} = {(0, 1)}\n    erase (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase\"><span class=\"name\">Ordnode</span>.<span class=\"name\">erase</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L1001-L1011","name":"Ordnode.split3","line":1001,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3","doc":"O(log n). Split the tree into those smaller than `x` and those greater than it,\nplus an element equivalent to `x`, if it exists.\n\n    split3 2 {1, 2, 4} = ({1}, some 2, {4})\n    split3 3 {1, 2, 4} = ({1, 2}, none, {4})\n    split3 4 {1, 2, 4} = ({1, 2}, some 4, ∅)\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    split3 (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, some (1, 2), ∅)\n    split3 (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, none, ∅) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3\"><span class=\"name\">Ordnode</span>.<span class=\"name\">split3</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L978-L988","name":"Ordnode.split","line":978,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split","doc":"O(log n). Split the tree into those smaller than `x` and those greater than it.\nIf an element equivalent to `x` is in the set, it is discarded.\n\n    split 2 {1, 2, 4} = ({1}, {4})\n    split 3 {1, 2, 4} = ({1, 2}, {4})\n    split 4 {1, 2, 4} = ({1, 2}, ∅)\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    split (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, ∅)\n    split (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, ∅) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split\"><span class=\"name\">Ordnode</span>.<span class=\"name\">split</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L959-L965","name":"Ordnode.insert'","line":959,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'","doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, the set is returned as is.\n\n    insert' 1 {1, 2, 3} = {1, 2, 3}\n    insert' 4 {1, 2, 3} = {1, 2, 3, 4}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insert' (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)}\n    insert' (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insert'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L946-L947","name":"Ordnode.instInsert","line":946,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInsert","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInsert\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instInsert</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Insert\">Insert</a> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L938-L944","name":"Ordnode.insert","line":938,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert","doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, this replaces it.\n\n    insert 1 {1, 2, 3} = {1, 2, 3}\n    insert 4 {1, 2, 3} = {1, 2, 3, 4}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insert (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 1)}\n    insert (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insert</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L917-L926","name":"Ordnode.alter","line":917,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter","doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    alter f 0 {1, 2, 3} = {1, 2, 3}     if f none = none\n                        = {a, 1, 2, 3}  if f none = some a\n    alter f 1 {1, 2, 3} = {2, 3}     if f 1 = none\n                        = {a, 2, 3}  if f 1 = some a "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter\"><span class=\"name\">Ordnode</span>.<span class=\"name\">alter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L898-L907","name":"Ordnode.updateWith","line":898,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith","doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    updateWith f 0 {1, 2, 3} = {1, 2, 3}\n    updateWith f 1 {1, 2, 3} = {2, 3}     if f 1 = none\n                              = {a, 2, 3}  if f 1 = some a "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith\"><span class=\"name\">Ordnode</span>.<span class=\"name\">updateWith</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L883-L889","name":"Ordnode.adjustWith","line":883,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith","doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    adjustWith f 0 {1, 2, 3} = {1, 2, 3}\n    adjustWith f 1 {1, 2, 3} = {f 1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    adjustWith f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}\n    adjustWith f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith\"><span class=\"name\">Ordnode</span>.<span class=\"name\">adjustWith</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L864-L870","name":"Ordnode.insertWith","line":864,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith","doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, the function `f` is used to generate\nthe element to insert (being passed the current value in the set).\n\n    insertWith f 0 {1, 2, 3} = {0, 1, 2, 3}\n    insertWith f 1 {1, 2, 3} = {f 1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insertWith f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}\n    insertWith f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insertWith</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L850-L851","name":"Ordnode.mem.decidable","line":850,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">mem</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">t</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L847-L848","name":"Ordnode.instMembership","line":847,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instMembership","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instMembership\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instMembership</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Membership\">Membership</a> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L839-L845","name":"Ordnode.find","line":839,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find","doc":"O(log n). Retrieve an element in the set that is equivalent to `x` in the order,\nif it exists.\n\n    find 1 {1, 2, 3} = some 1\n    find 4 {1, 2, 3} = none\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    find (1, 1) {(0, 1), (1, 2)} = some (1, 2)\n    find (3, 1) {(0, 1), (1, 2)} = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find\"><span class=\"name\">Ordnode</span>.<span class=\"name\">find</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L821-L827","name":"Ordnode.mem","line":821,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem","doc":"O(log n). Does the set (approximately) contain the element `x`? That is,\nis there an element that is equivalent to `x` in the order?\n\n    1 ∈ {1, 2, 3} = true\n    4 ∈ {1, 2, 3} = false\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    (1, 1) ∈ {(0, 1), (1, 2)} = true\n    (3, 1) ∈ {(0, 1), (1, 2)} = false "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem\"><span class=\"name\">Ordnode</span>.<span class=\"name\">mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L803-L805","name":"Ordnode.ofAscList","line":803,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList","doc":"O(n). Build a set from a list which is already sorted. Performs no comparisons.\n\nofAscList [1, 2, 3] = {1, 2, 3}\nofAscList [3, 2, 1] = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofAscList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L790-L797","name":"Ordnode.ofAscListAux₂","line":790,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂","doc":"Auxiliary definition for `ofAscList`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofAscListAux₂</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L776-L787","name":"Ordnode.ofAscListAux₁","line":776,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₁","doc":"Auxiliary definition for `ofAscList`.\n\n**Note:** This function is defined by well founded recursion, so it will probably not compute\nin the kernel, meaning that you probably can't prove things like\n`ofAscList [1, 2, 3] = {1, 2, 3}` by `rfl`.\nThis implementation is optimized for VM evaluation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₁\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofAscListAux₁</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">{ <span class=\"fn\">l'</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> // <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">l'</span>.length</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><span class=\"fn\">l</span>.length</span></span> }</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L760-L768","name":"Ordnode.span","line":760,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span","doc":"O(log n). Split the set into those satisfying and not satisfying the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    span (fun x ↦ x < 4) {1, 2, 3, 4, 5} = ({1, 2, 3}, {4, 5})\n    span (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span\"><span class=\"name\">Ordnode</span>.<span class=\"name\">span</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L751-L753","name":"Ordnode.dropWhile","line":751,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile","doc":"O(log n). Remove an initial segment of the set that satisfies the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    dropWhile (fun x ↦ x < 4) {1, 2, 3, 4, 5} = {4, 5}\n    dropWhile (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile\"><span class=\"name\">Ordnode</span>.<span class=\"name\">dropWhile</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L742-L744","name":"Ordnode.takeWhile","line":742,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile","doc":"O(log n). Get an initial segment of the set that satisfies the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    takeWhile (fun x ↦ x < 4) {1, 2, 3, 4, 5} = {1, 2, 3}\n    takeWhile (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile\"><span class=\"name\">Ordnode</span>.<span class=\"name\">takeWhile</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L734-L735","name":"Ordnode.splitAt","line":734,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt","doc":"O(log n). Split a set at the `i`th element, getting the first `i` and everything else.\n\nsplitAt 2 {a, b, c, d} = ({a, b}, {c, d})\nsplitAt 5 {a, b, c, d} = ({a, b, c, d}, ∅) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitAt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L716-L728","name":"Ordnode.splitAtAux","line":716,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux","doc":"Auxiliary definition for `splitAt`. (Can also be used in lieu of `splitAt` if you know the\nindex is within the range of the data structure.)\n\n    splitAtAux {a, b, c, d} 2 = ({a, b}, {c, d})\n    splitAtAux {a, b, c, d} 5 = ({a, b, c, d}, ∅) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitAtAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L708-L709","name":"Ordnode.drop","line":708,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop","doc":"O(log n). Remove the first `i` elements of the set, counted from the left.\n\ndrop 2 {a, b, c, d} = {c, d}\ndrop 5 {a, b, c, d} = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop\"><span class=\"name\">Ordnode</span>.<span class=\"name\">drop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L694-L702","name":"Ordnode.dropAux","line":694,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux","doc":"Auxiliary definition for `drop`. (Can also be used in lieu of `drop` if you know the\nindex is within the range of the data structure.)\n\n    drop_aux {a, b, c, d} 2 = {c, d}\n    drop_aux {a, b, c, d} 5 = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">dropAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L686-L687","name":"Ordnode.take","line":686,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take","doc":"O(log n). Get the first `i` elements of the set, counted from the left.\n\ntake 2 {a, b, c, d} = {a, b}\ntake 5 {a, b, c, d} = {a, b, c, d} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take\"><span class=\"name\">Ordnode</span>.<span class=\"name\">take</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L672-L680","name":"Ordnode.takeAux","line":672,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux","doc":"Auxiliary definition for `take`. (Can also be used in lieu of `take` if you know the\nindex is within the range of the data structure.)\n\n    takeAux {a, b, c, d} 2 = {a, b}\n    takeAux {a, b, c, d} 5 = {a, b, c, d} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">takeAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L659-L665","name":"Ordnode.removeNth","line":659,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth","doc":"O(log n). Remove the `i`th element of the set, by its index from left to right.\n\nremove_nth {a, b, c, d} 2 = {a, b, d}\nremove_nth {a, b, c, d} 5 = {a, b, c, d} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth\"><span class=\"name\">Ordnode</span>.<span class=\"name\">removeNth</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L647-L653","name":"Ordnode.nth","line":647,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth","doc":"O(log n). Get the `i`th element of the set, by its index from left to right.\n\nnth {a, b, c, d} 2 = some c\nnth {a, b, c, d} 5 = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth\"><span class=\"name\">Ordnode</span>.<span class=\"name\">nth</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L640-L641","name":"Ordnode.attach'","line":640,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'","doc":"O(n). \"Attach\" the information that every element of `t` satisfies property\nP to these elements inside the set, producing a set in the subtype.\n\n    attach' (fun x ↦ x < 4) {1, 2} H = ({1, 2} : Ordnode {x // x<4}) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">attach'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\">Ordnode.All</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">{ <span class=\"fn\">a</span> : <span class=\"fn\">α</span> // <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">a</span></span> }</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L632-L634","name":"Ordnode.pmap","line":632,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap","doc":"O(n). Map a partial function across a set. The result depends on a proof\nthat the function is defined on all members of the set.\n\n    pmap (fin.mk : ∀ n, n < 4 → fin 4) {1, 2} H = {(1 : fin 4), (2 : fin 4)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap\"><span class=\"name\">Ordnode</span>.<span class=\"name\">pmap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">a</span></span> → <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\">Ordnode.All</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L625-L626","name":"Ordnode.copair","line":625,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair","doc":"O(m + n). Build a set on the disjoint union by combining sets on the factors.\n`Or.inl a ∈ s.copair t` iff `a ∈ s`, and `Or.inr b ∈ s.copair t` iff `b ∈ t`.\n\n    copair {1, 2} {2, 3} = {inl 1, inl 2, inr 2, inr 3} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair\"><span class=\"name\">Ordnode</span>.<span class=\"name\">copair</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t₁ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t₂ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">β</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L618-L619","name":"Ordnode.prod","line":618,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod","doc":"O(m * n). The cartesian product of two sets: `(a, b) ∈ s.prod t` iff `a ∈ s` and `b ∈ t`.\n\nprod {1, 2} {2, 3} = {(1, 2), (1, 3), (2, 2), (2, 3)} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod\"><span class=\"name\">Ordnode</span>.<span class=\"name\">prod</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t₁ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t₂ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">β</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L612-L613","name":"Ordnode.powerset","line":612,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.powerset","doc":"O(2^n). Constructs the powerset of a given set, that is, the set of all subsets.\n\npowerset {1, 2, 3} = {∅, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.powerset\"><span class=\"name\">Ordnode</span>.<span class=\"name\">powerset</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L607-L607","name":"Ordnode.instDecidableRelEquivOfDecidableEq","line":607,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelEquivOfDecidableEq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelEquivOfDecidableEq\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instDecidableRelEquivOfDecidableEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">Ordnode.Equiv</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L604-L605","name":"Ordnode.Equiv","line":604,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv","doc":"O(n). True if the trees have the same elements, ignoring structural differences.\n\nEquiv {1, 2, 4} {2, 1, 1, 4} = true\nEquiv {1, 2, 4} {1, 2, 3} = false "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Equiv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t₁ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t₂ : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L597-L598","name":"Ordnode.instToFormat","line":597,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToFormat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToFormat\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instToFormat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Lean.ToFormat</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Lean.ToFormat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L593-L594","name":"Ordnode.instToString","line":593,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToString","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToString\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instToString</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L590-L591","name":"Ordnode.toRevList","line":590,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList","doc":"O(n). Build a list of elements in descending order from the tree.\n\ntoRevList {1, 2, 4} = [4, 2, 1]\ntoRevList {2, 1, 1, 4} = [4, 2, 1] "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">toRevList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L583-L584","name":"Ordnode.toList","line":583,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList","doc":"O(n). Build a list of elements in ascending order from the tree.\n\ntoList {1, 2, 4} = [1, 2, 4]\ntoList {2, 1, 1, 4} = [1, 2, 4] "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">toList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L575-L577","name":"Ordnode.foldr","line":575,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr","doc":"O(n). Fold a function from right to left (in decreasing order) across the tree.\n\nfoldr f {1, 2, 4} z = f 1 (f 2 (f 4 z)) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr\"><span class=\"name\">Ordnode</span>.<span class=\"name\">foldr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L568-L570","name":"Ordnode.foldl","line":568,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl","doc":"O(n). Fold a function from left to right (in increasing order) across the tree.\n\nfoldl f z {1, 2, 4} = f (f (f z 1) 2) 4 "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl\"><span class=\"name\">Ordnode</span>.<span class=\"name\">foldl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\">β</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L561-L563","name":"Ordnode.fold","line":561,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold","doc":"O(n). Fold a function across the structure of a tree.\n\n     fold z f {1, 2, 4} = f (f z 1 z) 2 (f z 4 z)\n\nThe exact structure of function applications depends on the tree and so\nis unspecified. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold\"><span class=\"name\">Ordnode</span>.<span class=\"name\">fold</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(z : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L551-L553","name":"Ordnode.map","line":551,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map","doc":"O(n). Map a function across a tree, without changing the structure. Only valid when\nthe function is strictly monotone, i.e. `x < y → f x < f y`.\n\n     partition (fun x ↦ x + 2) {1, 2, 4} = {2, 3, 6}\n     partition (fun x : ℕ ↦ x - 2) {1, 2, 4} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map\"><span class=\"name\">Ordnode</span>.<span class=\"name\">map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L539-L544","name":"Ordnode.partition","line":539,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition","doc":"O(n). Split the elements of a tree into those satisfying, and not satisfying, a predicate.\n\npartition (fun x ↦ x < 3) {1, 2, 4} = ({1, 2}, {3}) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition\"><span class=\"name\">Ordnode</span>.<span class=\"name\">partition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L530-L534","name":"Ordnode.filter","line":530,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter","doc":"O(n). Filter the elements of a tree satisfying a predicate.\n\nfilter (fun x ↦ x < 3) {1, 2, 4} = {1, 2}\nfilter (fun x ↦ x > 5) {1, 2, 4} = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter\"><span class=\"name\">Ordnode</span>.<span class=\"name\">filter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L508-L524","name":"Ordnode.link","line":508,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link","doc":"O(log(m+n)). Build a tree from an element between two trees, without any\nassumption on the relative sizes.\n\n    link {1, 2} 4 {5, 6} = {1, 2, 4, 5, 6}\n    link {1, 3} 2 {5} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link\"><span class=\"name\">Ordnode</span>.<span class=\"name\">link</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L499-L501","name":"Ordnode.insertMin","line":499,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin","doc":"O(log n). Insert an element below all the others, without any comparisons.\n(Assumes that the element is in fact below all the others).\n\n    insertMin {1, 2} 0 = {0, 1, 2}\n    insertMin {1, 2} 4 = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insertMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L490-L492","name":"Ordnode.insertMax","line":490,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax","doc":"O(log n). Insert an element above all the others, without any comparisons.\n(Assumes that the element is in fact above all the others).\n\n    insertMax {1, 2} 4 = {1, 2, 4}\n    insertMax {1, 2} 0 = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insertMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L475-L483","name":"Ordnode.merge","line":475,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge","doc":"O(log(m + n)). Concatenate two trees that are ordered with respect to each other.\n\nmerge {1, 2} {3, 4} = {1, 2, 3, 4}\nmerge {3, 4} {1, 2} = precondition violation "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge\"><span class=\"name\">Ordnode</span>.<span class=\"name\">merge</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L460-L469","name":"Ordnode.glue","line":460,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue","doc":"**Internal use only**\n\nO(log(m + n)). Concatenate two trees that are balanced and ordered with respect to each other. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue\"><span class=\"name\">Ordnode</span>.<span class=\"name\">glue</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L453-L455","name":"Ordnode.splitMax","line":453,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax","doc":"O(log n). Extract and remove the maximum element from the tree, if it exists.\n\nsplit_max {1, 2, 3} = some ({1, 2}, 3)\nsplit_max ∅ = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">α</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L443-L447","name":"Ordnode.splitMax'","line":443,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'","doc":"**Internal use only**, because it requires a balancing constraint on the inputs.\n\nO(log n). Extract and remove the maximum element from a nonempty tree. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMax'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">α</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L436-L438","name":"Ordnode.splitMin","line":436,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin","doc":"O(log n). Extract and remove the minimum element from the tree, if it exists.\n\nsplit_min {1, 2, 3} = some (1, {2, 3})\nsplit_min ∅ = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L426-L430","name":"Ordnode.splitMin'","line":426,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'","doc":"**Internal use only**, because it requires a balancing constraint on the inputs.\n\nO(log n). Extract and remove the minimum element from a nonempty tree. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMin'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L418-L421","name":"Ordnode.eraseMax","line":418,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax","doc":"O(log n). Remove the maximum element from the tree, or do nothing if it is already empty.\n\neraseMax {1, 2, 3} = {1, 2}\neraseMax ∅ = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">eraseMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L409-L412","name":"Ordnode.eraseMin","line":409,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin","doc":"O(log n). Remove the minimum element from the tree, or do nothing if it is already empty.\n\neraseMin {1, 2, 3} = {2, 3}\neraseMin ∅ = ∅ "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">eraseMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L401-L403","name":"Ordnode.findMax","line":401,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax","doc":"O(log n). Return the maximum element of the tree, if it exists.\n\nfindMax {1, 2, 3} = some 3\nfindMax ∅ = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L393-L395","name":"Ordnode.findMax'","line":393,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'","doc":"O(log n). Return the maximum element of the tree, or the provided default value.\n\nfindMax' 37 {1, 2, 3} = 3\nfindMax' 37 ∅ = 37 "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMax'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L385-L387","name":"Ordnode.findMin","line":385,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin","doc":"O(log n). Return the minimum element of the tree, if it exists.\n\nfindMin {1, 2, 3} = some 1\nfindMin ∅ = none "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L377-L379","name":"Ordnode.findMin'","line":377,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'","doc":"O(log n). Return the minimum element of the tree, or the provided default value.\n\nfindMin' 37 {1, 2, 3} = 1\nfindMin' 37 ∅ = 37 "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMin'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L369-L371","name":"Ordnode.Amem.decidable","line":369,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Amem</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x_1</span></span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem\">Ordnode.Amem</a> <span class=\"fn\">x</span> <span class=\"fn\">t</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L366-L367","name":"Ordnode.Amem","line":366,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem","doc":"O(n). Approximate membership in the set, that is, whether some element in the\nset is equivalent to this one in the preorder. This is useful primarily for stating\ncorrectness properties; use `∈` for a version that actually uses the BST property\nof the tree.\n\n    Amem 2 {1, 2, 3} = true\n    Amem 4 {1, 2, 3} = false\n\nTo see the difference with `Emem`, we need a preorder that is not a partial order.\nFor example, suppose we compare pairs of numbers using only their first coordinate. Then:\n-- Porting note: Verify below example\n    emem (0, 1) {(0, 0), (1, 2)} = false\n    amem (0, 1) {(0, 0), (1, 2)} = true\n    (0, 1) ∈ {(0, 0), (1, 2)} = true\n\nThe `∈` relation is equivalent to `Amem` as long as the `Ordnode` is well formed,\nand should always be used instead of `Amem`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Amem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L346-L347","name":"Ordnode.Emem.decidable","line":346,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Emem</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem\">Ordnode.Emem</a> <span class=\"fn\">x</span> <span class=\"fn\">t</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L343-L344","name":"Ordnode.Emem","line":343,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem","doc":"O(n). Exact membership in the set. This is useful primarily for stating\ncorrectness properties; use `∈` for a version that actually uses the BST property\nof the tree.\n\n    Emem 2 {1, 2, 3} = true\n    Emem 4 {1, 2, 3} = false "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Emem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L330-L335","name":"Ordnode.Any.decidable","line":330,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Any</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">P</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any\">Ordnode.Any</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L326-L328","name":"Ordnode.Any","line":326,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any","doc":"O(n). Does any element of the map satisfy property `P`?\n\nAny (fun x ↦ x < 2) {1, 2, 3} = True\nAny (fun x ↦ x < 2) {2, 3, 5} = False "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Any</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L315-L320","name":"Ordnode.All.decidable","line":315,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">All</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">P</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\">Ordnode.All</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L311-L313","name":"Ordnode.All","line":311,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All","doc":"O(n). Does every element of the map satisfy property `P`?\n\nAll (fun x ↦ x < 5) {1, 2, 3} = True\nAll (fun x ↦ x < 5) {1, 2, 3, 5} = False "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\"><span class=\"name\">Ordnode</span>.<span class=\"name\">All</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L254-L305","name":"Ordnode.balance","line":254,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balance","doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had one side change\nby at most 1. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balance\"><span class=\"name\">Ordnode</span>.<span class=\"name\">balance</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L219-L248","name":"Ordnode.balanceR","line":219,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR","doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had its right\nside grow by 1, or its left side shrink by 1. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR\"><span class=\"name\">Ordnode</span>.<span class=\"name\">balanceR</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L184-L213","name":"Ordnode.balanceL","line":184,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL","doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had its left\nside grow by 1, or its right side shrink by 1. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL\"><span class=\"name\">Ordnode</span>.<span class=\"name\">balanceL</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L176-L177","name":"Ordnode.instRepr","line":176,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instRepr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instRepr\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instRepr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L167-L174","name":"Ordnode.repr","line":167,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr","doc":"Basic pretty printing for `Ordnode α` that shows the structure of the tree.\n\nrepr {3, 1, 2, 4} = ((∅ 1 ∅) 2 ((∅ 3 ∅) 4 ∅)) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr\"><span class=\"name\">Ordnode</span>.<span class=\"name\">repr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(o : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Format/Basic.html#Std.Format\">Lean.Format</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L161-L162","name":"Ordnode.node'","line":161,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'","doc":"**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">node'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L153-L155","name":"Ordnode.dual","line":153,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual","doc":"**Internal use only**, because it violates the BST property on the original order.\n\nO(n). The dual of a tree is a tree with its left and right sides reversed throughout.\nThe dual of a valid BST is valid under the dual order. This is convenient for exploiting\nsymmetries in the algorithms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual\"><span class=\"name\">Ordnode</span>.<span class=\"name\">dual</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L143-L145","name":"Ordnode.empty","line":143,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty","doc":"O(1). Is the set empty?\n\nempty ∅ = tt\nempty {1, 2, 3} = ff "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty\"><span class=\"name\">Ordnode</span>.<span class=\"name\">empty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L134-L136","name":"Ordnode.size_node","line":134,"kind":"theorem","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_node","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_node\"><span class=\"name\">Ordnode</span>.<span class=\"name\">size_node</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(sz : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node\">Ordnode.node</a> <span class=\"fn\">sz</span> <span class=\"fn\">l</span> <span class=\"fn\">x</span> <span class=\"fn\">r</span></span>)</span>.size</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">sz</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L132-L133","name":"Ordnode.size_nil","line":132,"kind":"theorem","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_nil\"><span class=\"name\">Ordnode</span>.<span class=\"name\">size_nil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">Ordnode.nil</span>.size</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L125-L127","name":"Ordnode.size","line":125,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size","doc":"O(1). Get the size of the set.\n\nsize {2, 1, 1, 4} = 3  "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size\"><span class=\"name\">Ordnode</span>.<span class=\"name\">size</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L118-L119","name":"Ordnode.instSingleton","line":118,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instSingleton","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instSingleton\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instSingleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Singleton\">Singleton</a> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L113-L114","name":"Ordnode.singleton","line":113,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton","doc":"O(1). Construct a singleton set containing value `a`.\n\nsingleton 3 = {3} "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton\"><span class=\"name\">Ordnode</span>.<span class=\"name\">singleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L106-L107","name":"Ordnode.ratio","line":106,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio","doc":"**Internal use only**\n\nThe ratio between an outer and inner sibling of the\nheavier subtree in an unbalanced setting. It determines\nwhether a double or single rotation should be performed\nto restore balance. It is corresponds with the inverse\nof `α` in Adam's article. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ratio</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L95-L96","name":"Ordnode.delta","line":95,"kind":"def","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta","doc":"**Internal use only**\n\nThe maximal relative difference between the sizes of\ntwo trees, it corresponds with the `w` in Adams' paper.\n\nAccording to the Haskell comment, only `(delta, ratio)` settings\nof `(3, 2)` and `(4, 2)` will work, and the proofs in\n`Ordset.lean` assume `delta := 3` and `ratio := 2`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta\"><span class=\"name\">Ordnode</span>.<span class=\"name\">delta</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L83-L84","name":"Ordnode.instInhabited","line":83,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInhabited","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInhabited\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instInhabited</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L80-L81","name":"Ordnode.instEmptyCollection","line":80,"kind":"instance","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instEmptyCollection","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instEmptyCollection\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instEmptyCollection</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection\">EmptyCollection</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L71-L71","name":"Ordnode.node","line":71,"kind":"ctor","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node\"><span class=\"name\">Ordnode</span>.<span class=\"name\">node</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(size : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L70-L70","name":"Ordnode.nil","line":70,"kind":"ctor","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil\"><span class=\"name\">Ordnode</span>.<span class=\"name\">nil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Data/Ordmap/Ordnode.lean#L69-L71","name":"Ordnode","line":69,"kind":"inductive","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode","doc":"An `Ordnode α` is a finite set of values, represented as a tree.\nThe operations on this type maintain that the tree is balanced\nand correctly stores subtree sizes at each level. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\"><span class=\"name\">Ordnode</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>"}]}