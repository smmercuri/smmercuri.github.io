{"name":"Mathlib.Lean.Meta.CongrTheorems","instances":[{"typeNames":[],"name":"Lean.Meta.instFastSubsingletonOfFastIsEmpty","className":"Lean.Meta.FastSubsingleton"},{"typeNames":[],"name":"Lean.Meta.instFastSubsingleton","className":"Lean.Meta.FastSubsingleton"},{"typeNames":["Decidable"],"name":"Lean.Meta.instFastSubsingletonDecidable","className":"Lean.Meta.FastSubsingleton"},{"typeNames":["Fin"],"name":"Lean.Meta.instFastSubsingletonFinOfNatNat","className":"Lean.Meta.FastSubsingleton"},{"typeNames":["PUnit"],"name":"Lean.Meta.instFastSubsingletonPUnit","className":"Lean.Meta.FastSubsingleton"},{"typeNames":["Empty"],"name":"Lean.Meta.instFastIsEmptyEmpty","className":"Lean.Meta.FastIsEmpty"},{"typeNames":["False"],"name":"Lean.Meta.instFastIsEmptyFalse","className":"Lean.Meta.FastIsEmpty"},{"typeNames":["Fin"],"name":"Lean.Meta.instFastIsEmptyFinOfNatNat","className":"Lean.Meta.FastIsEmpty"},{"typeNames":[],"name":"Lean.Meta.instFastSubsingletonForallOfFastIsEmpty","className":"Lean.Meta.FastSubsingleton"},{"typeNames":[],"name":"Lean.Meta.instFastSubsingletonForall","className":"Lean.Meta.FastSubsingleton"}],"imports":["Init","Lean.Meta.Tactic.Cleanup","Lean.Meta.Tactic.Cases","Lean.Meta.Tactic.Refl","Mathlib.Logic.IsEmpty"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L349-L356","name":"Lean.Meta.mkRichHCongr.trySolve","line":349,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolve","doc":"Driver for `trySolveCore`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolve\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">trySolve</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ty : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L334-L347","name":"Lean.Meta.mkRichHCongr.trySolveCore","line":334,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolveCore","doc":"Given a type that is a bunch of equalities implying a goal (for example, a basic\ncongruence lemma), prove it if possible. Basic congruence lemmas should be provable by this.\nThere are some extra tricks for handling arguments to richer congruence lemmas. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolveCore\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">trySolveCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L313-L329","name":"Lean.Meta.mkRichHCongr.withNewEqs.loop","line":313,"kind":"opaque","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs.loop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs.loop\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">withNewEqs</span>.<span class=\"name\">loop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(info : <a href=\"./Lean/Meta/Basic.html#Lean.Meta.FunInfo\">Lean.Meta.FunInfo</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(xs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ys : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixedParams : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">Lean.Meta.CongrArgKind</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(kinds : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">Lean.Meta.CongrArgKind</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(eqs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L311-L330","name":"Lean.Meta.mkRichHCongr.withNewEqs","line":311,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs","doc":"Introduce variables for equalities between the arrays of variables. Uses `fixedParams`\nto control whether to introduce an equality for each pair. The array of triples passed to `k`\nconsists of (1) the simple congr lemma HEq arg, (2) the richer HEq arg, and (3) how to\ncompute 1 in terms of 2. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">withNewEqs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(info : <a href=\"./Lean/Meta/Basic.html#Lean.Meta.FunInfo\">Lean.Meta.FunInfo</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(xs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ys : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixedParams : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">Lean.Meta.CongrArgKind</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L285-L305","name":"Lean.Meta.mkRichHCongr.doubleTelescope.loop","line":285,"kind":"opaque","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope.loop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope.loop\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">doubleTelescope</span>.<span class=\"name\">loop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(numVars : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixed : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ftyx : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ftyy : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(xs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ys : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixed' : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L283-L306","name":"Lean.Meta.mkRichHCongr.doubleTelescope","line":283,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope","doc":"Similar to doing `forallBoundedTelescope` twice, but makes use of the `fixed` array, which\nis used as a hint for whether both variables should be the same. This is only a hint though,\nsince we respect it only if the binding domains are equal.\nWe affix `'` to the second list of variables, and all the variables are introduced\nwith default binder info. Calls `k` with the xs, ys, and a revised `fixed` array "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">doubleTelescope</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(fty : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(numVars : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixed : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L210-L356","name":"Lean.Meta.mkRichHCongr","line":210,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr","doc":"`mkRichHCongr fType funInfo fixedFun fixedParams forceHEq`\ncreate a congruence lemma to prove that `Eq/HEq (f a₁ ... aₙ) (f' a₁' ... aₙ')`.\nThe functions have type `fType` and the number of arguments is governed by the `funInfo` data.\nEach argument produces an `Eq/HEq aᵢ aᵢ'` hypothesis, but we also provide these hypotheses\nthe additional facts that the preceding equalities have been proved (unlike in `mkHCongrWithArity`).\nThe first two arguments of the resulting theorem are for `f` and `f'`, followed by a proof\nof `f = f'`, unless `fixedFun` is `true` (see below).\n\nWhen including hypotheses about previous hypotheses, we make use of dependency information\nand only include relevant equalities.\n\nThe argument `fty` denotes the type of `f`. The arity of the resulting congruence lemma is\ncontrolled by the size of the `info` array.\n\nFor the purpose of generating nicer lemmas (to help `to_additive` for example),\nthis function supports generating lemmas where certain parameters\nare meant to be fixed:\n\n* If `fixedFun` is `false` (the default) then the lemma starts with three arguments for `f`, `f'`,\nand `h : f = f'`. Otherwise, if `fixedFun` is `true` then the lemma starts with just `f`.\n\n* If the `fixedParams` argument has `true` for a particular argument index, then this is a hint\nthat the congruence lemma may use the same parameter for both sides of the equality. There is\nno guarantee -- it respects it if the types are equal for that parameter (i.e., if the parameter\ndoes not depend on non-fixed parameters).\n\nIf `forceHEq` is `true` then the conclusion of the generated theorem is a `HEq`.\nOtherwise it might be an `Eq` if the equality is homogeneous.\n\nThis is the interpretation of the `CongrArgKind`s in the generated congruence theorem:\n* `.eq` corresponds to having three arguments `(x : α) (x' : α) (h : x = x')`.\n  Note that `h` might have additional hypotheses.\n* `.heq` corresponds to having three arguments `(x : α) (x' : α') (h : HEq x x')`\n  Note that `h` might have additional hypotheses.\n* `.fixed` corresponds to having a single argument `(x : α)` that is fixed between the LHS and RHS\n* `.subsingletonInst` corresponds to having two arguments `(x : α) (x' : α')` for which the\n  congruence generator was able to prove that `HEq x x'` already. This is a slight abuse of\n  this `CongrArgKind` since this is used even for types that are not subsingleton typeclasses.\n\nNote that the first entry in this array is for the function itself.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fType : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(info : <a href=\"./Lean/Meta/Basic.html#Lean.Meta.FunInfo\">Lean.Meta.FunInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixedFun : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixedParams : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span> <span class=\"fn\">#[]</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(forceHEq : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L155-L166","name":"Lean.Meta.fastSubsingletonElim","line":155,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.fastSubsingletonElim","doc":"Like `subsingletonElim` but uses `FastSubsingleton` to fail fast. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.fastSubsingletonElim\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">fastSubsingletonElim</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L140-L152","name":"Lean.Meta.withSubsingletonAsFast","line":140,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.withSubsingletonAsFast","doc":"Runs `mx` in a context where all local `Subsingleton` and `IsEmpty` instances\nhave associated `FastSubsingleton` and `FastIsEmpty` instances.\nThe function passed to `mx` eliminates these instances from expressions,\nsince they are only locally valid inside this context.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.withSubsingletonAsFast\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">withSubsingletonAsFast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(mx : <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L130-L132","name":"Lean.Meta.instFastSubsingletonForall","line":130,"kind":"instance","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonForall","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonForall\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonForall</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[inst : <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">Lean.Meta.FastSubsingleton</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">x</span></span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">Lean.Meta.FastSubsingleton</a> <span class=\"fn\">(<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">x</span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L126-L128","name":"Lean.Meta.instFastSubsingletonForallOfFastIsEmpty","line":126,"kind":"instance","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonForallOfFastIsEmpty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonForallOfFastIsEmpty\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonForallOfFastIsEmpty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[inst : <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">Lean.Meta.FastIsEmpty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">Lean.Meta.FastSubsingleton</a> <span class=\"fn\">(<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">x</span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L124-L124","name":"Lean.Meta.instFastIsEmptyFinOfNatNat","line":124,"kind":"instance","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyFinOfNatNat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyFinOfNatNat\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastIsEmptyFinOfNatNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">Lean.Meta.FastIsEmpty</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Fin\">Fin</a> <span class=\"fn\">0</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L122-L122","name":"Lean.Meta.instFastIsEmptyFalse","line":122,"kind":"instance","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyFalse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyFalse\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastIsEmptyFalse</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">Lean.Meta.FastIsEmpty</a> <a href=\"./Init/Prelude.html#False\">False</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L120-L120","name":"Lean.Meta.instFastIsEmptyEmpty","line":120,"kind":"instance","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyEmpty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyEmpty\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastIsEmptyEmpty</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">Lean.Meta.FastIsEmpty</a> <a href=\"./Init/Prelude.html#Empty\">Empty</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L118-L118","name":"Lean.Meta.instFastSubsingletonPUnit","line":118,"kind":"instance","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonPUnit","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonPUnit\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonPUnit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">Lean.Meta.FastSubsingleton</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit.{u_1}</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L116-L116","name":"Lean.Meta.instFastSubsingletonFinOfNatNat","line":116,"kind":"instance","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonFinOfNatNat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonFinOfNatNat\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonFinOfNatNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">Lean.Meta.FastSubsingleton</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Fin\">Fin</a> <span class=\"fn\">1</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L114-L114","name":"Lean.Meta.instFastSubsingletonDecidable","line":114,"kind":"instance","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonDecidable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonDecidable\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonDecidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">Lean.Meta.FastSubsingleton</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">p</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L112-L112","name":"Lean.Meta.instFastSubsingleton","line":112,"kind":"instance","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingleton","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingleton\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">Lean.Meta.FastSubsingleton</a> <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L109-L110","name":"Lean.Meta.instFastSubsingletonOfFastIsEmpty","line":109,"kind":"instance","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonOfFastIsEmpty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonOfFastIsEmpty\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonOfFastIsEmpty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[inst : <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">Lean.Meta.FastIsEmpty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">Lean.Meta.FastSubsingleton</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L106-L107","name":"Lean.Meta.FastSubsingleton.elim","line":106,"kind":"theorem","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.elim","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.elim\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastSubsingleton</span>.<span class=\"name\">elim</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[h : <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">Lean.Meta.FastSubsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L104-L104","name":"Lean.Meta.FastIsEmpty.inst","line":104,"kind":"theorem","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty.inst","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty.inst\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastIsEmpty</span>.<span class=\"name\">inst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[self : <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">Lean.Meta.FastIsEmpty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/IsEmpty.html#IsEmpty\">IsEmpty</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L103-L103","name":"Lean.Meta.FastIsEmpty.mk","line":103,"kind":"ctor","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastIsEmpty</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[inst : <span class=\"fn\"><a href=\"./Mathlib/Logic/IsEmpty.html#IsEmpty\">IsEmpty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">Lean.Meta.FastIsEmpty</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L103-L104","name":"Lean.Meta.FastIsEmpty","line":103,"kind":"class","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty","doc":"A version of `IsEmpty` with few instances. It should fail fast. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastIsEmpty</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Sort</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L100-L100","name":"Lean.Meta.FastSubsingleton.inst","line":100,"kind":"theorem","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.inst","doc":"The subsingleton instance. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.inst\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastSubsingleton</span>.<span class=\"name\">inst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[self : <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">Lean.Meta.FastSubsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L98-L98","name":"Lean.Meta.FastSubsingleton.mk","line":98,"kind":"ctor","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastSubsingleton</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[inst : <span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">Lean.Meta.FastSubsingleton</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L98-L100","name":"Lean.Meta.FastSubsingleton","line":98,"kind":"class","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton","doc":"A version of `Subsingleton` with few instances. It should fail fast. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastSubsingleton</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Sort</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L79-L93","name":"Lean.Meta.mkHCongrWithArity'.prove","line":79,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.prove","doc":"Close the goal given only the fvars in `params`, or else fails. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.prove\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkHCongrWithArity'</span>.<span class=\"name\">prove</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(params : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L47-L77","name":"Lean.Meta.mkHCongrWithArity'.process","line":47,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.process","doc":"Process the congruence theorem by trying to pre-prove arguments using `prove`.\n\n- `cthm` is the original `CongrTheorem`, modified only after visiting every argument.\n- `type` is type of the congruence theorem, after all the parameters so far have been applied.\n- `argKinds` is the list of `CongrArgKind`s, which this function recurses on.\n- `argKinds'` is the accumulated array of `CongrArgKind`s, which is the original array but\n  with some kinds replaced by `.subsingletonInst`.\n- `params` is the *new* list of parameters, as fvars that need to be abstracted at the end.\n- `args` is the list of arguments (fvars) to supply to `cthm.proof` before abstracting `params`.\n- `letArgs` records `(fvar, expr)` assignments for each `fvar` that was solved for by `prove`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.process\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkHCongrWithArity'</span>.<span class=\"name\">process</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cthm : <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(type : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(argKinds : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">Lean.Meta.CongrArgKind</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(argKinds' : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">Lean.Meta.CongrArgKind</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(params : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(letArgs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Lean/Meta/CongrTheorems.lean#L31-L93","name":"Lean.Meta.mkHCongrWithArity'","line":31,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'","doc":"Generates a congruence lemma for a function `f` for `numArgs` of its arguments.\nThe only `Lean.Meta.CongrArgKind` kinds that appear in such a lemma\nare `.eq`, `.heq`, and `.subsingletonInst`.\nThe resulting lemma proves either an `Eq` or a `HEq` depending on whether the types\nof the LHS and RHS are equal or not.\n\nThis function is a wrapper around `Lean.Meta.mkHCongrWithArity`.\nIt transforms the resulting congruence lemma by trying to automatically prove hypotheses\nusing subsingleton lemmas, and if they are so provable they are recorded with `.subsingletonInst`.\nNote that this is slightly abusing `.subsingletonInst` since\n(1) the argument might not be for a `Decidable` instance and\n(2) the argument might not even be an instance. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkHCongrWithArity'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(numArgs : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a></span></div></div>"}]}