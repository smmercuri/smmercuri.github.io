{"name":"Mathlib.ModelTheory.Satisfiability","instances":[{"typeNames":["FirstOrder.Language.BoundedFormula","FirstOrder.Language.Theory.SemanticallyEquivalent"],"name":"FirstOrder.Language.Theory.instIsReflBoundedFormulaSemanticallyEquivalent","className":"IsRefl"}],"imports":["Init","Mathlib.ModelTheory.Ultraproducts","Mathlib.ModelTheory.Bundled","Mathlib.ModelTheory.Skolem"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L632-L636","name":"Cardinal.empty_infinite_Theory_isComplete","line":632,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.empty_infinite_Theory_isComplete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.empty_infinite_Theory_isComplete\"><span class=\"name\">Cardinal</span>.<span class=\"name\">empty_infinite_Theory_isComplete</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.empty\">FirstOrder.Language.empty</a>.infiniteTheory</span>.IsComplete</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L629-L630","name":"Cardinal.empty_theory_categorical","line":629,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.empty_theory_categorical","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.empty_theory_categorical\"><span class=\"name\">Cardinal</span>.<span class=\"name\">empty_theory_categorical</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.empty\">FirstOrder.Language.empty</a>.Theory</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">κ</span>.Categorical</span> <span class=\"fn\">T</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L610-L627","name":"Cardinal.Categorical.isComplete","line":610,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical.isComplete","doc":"The Łoś–Vaught Test : a criterion for categorical theories to be complete. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical.isComplete\"><span class=\"name\">Cardinal</span>.<span class=\"name\">Categorical</span>.<span class=\"name\">isComplete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">κ</span>.Categorical</span> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0\">Cardinal.aleph0</a> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\"><span class=\"fn\">L</span>.card</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hS : <span class=\"fn\"><span class=\"fn\">T</span>.IsSatisfiable</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hT : <span class=\"fn\">∀ (<span class=\"fn\">M</span> : <span class=\"fn\"><span class=\"fn\">T</span>.ModelType</span>), <span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">↑<span class=\"fn\">M</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">T</span>.IsComplete</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L606-L607","name":"Cardinal.Categorical","line":606,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical","doc":"A theory is `κ`-categorical if all models of size `κ` are isomorphic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical\"><span class=\"name\">Cardinal</span>.<span class=\"name\">Categorical</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L582-L591","name":"FirstOrder.Language.BoundedFormula.induction_on_exists_not","line":582,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.induction_on_exists_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.induction_on_exists_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">induction_on_exists_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">{<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hqf : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">ψ</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">ψ</span>.IsQF</span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">ψ</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hnot : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">φ</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">φ</span>.not</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hex : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">φ</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">φ</span>.ex</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hse : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">φ₁ </span><span class=\"fn\">φ₂</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>.SemanticallyEquivalent</span> <span class=\"fn\">φ₁</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L567-L580","name":"FirstOrder.Language.BoundedFormula.induction_on_all_ex","line":567,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.induction_on_all_ex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.induction_on_all_ex\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">induction_on_all_ex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">{<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hqf : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">ψ</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">ψ</span>.IsQF</span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">ψ</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hall : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">ψ</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">ψ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">ψ</span>.all</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hex : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">φ</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">φ</span>.ex</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hse : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">φ₁ </span><span class=\"fn\">φ₂</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>.SemanticallyEquivalent</span> <span class=\"fn\">φ₁</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L563-L565","name":"FirstOrder.Language.BoundedFormula.semanticallyEquivalent_toPrenex","line":563,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_toPrenex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_toPrenex\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">semanticallyEquivalent_toPrenex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\"><span class=\"fn\">φ</span>.toPrenex</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L551-L561","name":"FirstOrder.Language.BoundedFormula.IsQF.induction_on_inf_not","line":551,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.IsQF.induction_on_inf_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.IsQF.induction_on_inf_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">IsQF</span>.<span class=\"name\">induction_on_inf_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">φ</span>.IsQF</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ha : <span class=\"fn\">∀ (<span class=\"fn\">ψ</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">ψ</span>.IsAtomic</span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">ψ</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hinf : <span class=\"fn\">∀ {<span class=\"fn\">φ₁ </span><span class=\"fn\">φ₂</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ₁</span> <a href=\"./Mathlib/Order/Notation.html#Inf.inf\">⊓</a> <span class=\"fn\">φ₂</span></span>)</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hnot : <span class=\"fn\">∀ {<span class=\"fn\">φ</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">φ</span>.not</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hse : <span class=\"fn\">∀ {<span class=\"fn\">φ₁ </span><span class=\"fn\">φ₂</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>.SemanticallyEquivalent</span> <span class=\"fn\">φ₁</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L541-L549","name":"FirstOrder.Language.BoundedFormula.IsQF.induction_on_sup_not","line":541,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.IsQF.induction_on_sup_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.IsQF.induction_on_sup_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">IsQF</span>.<span class=\"name\">induction_on_sup_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">φ</span>.IsQF</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ha : <span class=\"fn\">∀ (<span class=\"fn\">ψ</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">ψ</span>.IsAtomic</span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">ψ</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hsup : <span class=\"fn\">∀ {<span class=\"fn\">φ₁ </span><span class=\"fn\">φ₂</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ₁</span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\">φ₂</span></span>)</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hnot : <span class=\"fn\">∀ {<span class=\"fn\">φ</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">φ</span>.not</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hse : <span class=\"fn\">∀ {<span class=\"fn\">φ₁ </span><span class=\"fn\">φ₂</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>.SemanticallyEquivalent</span> <span class=\"fn\">φ₁</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L533-L535","name":"FirstOrder.Language.Formula.inf_semanticallyEquivalent_not_sup_not","line":533,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.inf_semanticallyEquivalent_not_sup_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.inf_semanticallyEquivalent_not_sup_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Formula</span>.<span class=\"name\">inf_semanticallyEquivalent_not_sup_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Formula</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Formula</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Mathlib/Order/Notation.html#Inf.inf\">⊓</a> <span class=\"fn\">ψ</span></span>)</span> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.not</span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\"><span class=\"fn\">ψ</span>.not</span></span>)</span>.not</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L529-L531","name":"FirstOrder.Language.Formula.sup_semanticallyEquivalent_not_inf_not","line":529,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.sup_semanticallyEquivalent_not_inf_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.sup_semanticallyEquivalent_not_inf_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Formula</span>.<span class=\"name\">sup_semanticallyEquivalent_not_inf_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Formula</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Formula</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\">ψ</span></span>)</span> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.not</span> <a href=\"./Mathlib/Order/Notation.html#Inf.inf\">⊓</a> <span class=\"fn\"><span class=\"fn\">ψ</span>.not</span></span>)</span>.not</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L526-L527","name":"FirstOrder.Language.Formula.imp_semanticallyEquivalent_not_sup","line":526,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.imp_semanticallyEquivalent_not_sup","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.imp_semanticallyEquivalent_not_sup\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Formula</span>.<span class=\"name\">imp_semanticallyEquivalent_not_sup</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Formula</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Formula</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.imp</span> <span class=\"fn\">ψ</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.not</span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\">ψ</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L523-L524","name":"FirstOrder.Language.Formula.semanticallyEquivalent_not_not","line":523,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.semanticallyEquivalent_not_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.semanticallyEquivalent_not_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Formula</span>.<span class=\"name\">semanticallyEquivalent_not_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Formula</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.not</span>.not</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L513-L515","name":"FirstOrder.Language.BoundedFormula.semanticallyEquivalent_all_liftAt","line":513,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_all_liftAt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_all_liftAt\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">semanticallyEquivalent_all_liftAt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.liftAt\">FirstOrder.Language.BoundedFormula.liftAt</a> <span class=\"fn\">1</span> <span class=\"fn\">n</span> <span class=\"fn\">φ</span></span>)</span>.all</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L510-L511","name":"FirstOrder.Language.BoundedFormula.ex_semanticallyEquivalent_not_all_not","line":510,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.ex_semanticallyEquivalent_not_all_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.ex_semanticallyEquivalent_not_all_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">ex_semanticallyEquivalent_not_all_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\"><span class=\"fn\">φ</span>.ex</span> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.not</span>.all</span>.not</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L507-L508","name":"FirstOrder.Language.BoundedFormula.all_semanticallyEquivalent_not_ex_not","line":507,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.all_semanticallyEquivalent_not_ex_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.all_semanticallyEquivalent_not_ex_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">all_semanticallyEquivalent_not_ex_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\"><span class=\"fn\">φ</span>.all</span> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.not</span>.ex</span>.not</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L503-L505","name":"FirstOrder.Language.BoundedFormula.inf_semanticallyEquivalent_not_sup_not","line":503,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.inf_semanticallyEquivalent_not_sup_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.inf_semanticallyEquivalent_not_sup_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">inf_semanticallyEquivalent_not_sup_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Mathlib/Order/Notation.html#Inf.inf\">⊓</a> <span class=\"fn\">ψ</span></span>)</span> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.not</span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\"><span class=\"fn\">ψ</span>.not</span></span>)</span>.not</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L500-L501","name":"FirstOrder.Language.BoundedFormula.sup_semanticallyEquivalent_not_inf_not","line":500,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.sup_semanticallyEquivalent_not_inf_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.sup_semanticallyEquivalent_not_inf_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">sup_semanticallyEquivalent_not_inf_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\">ψ</span></span>)</span> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.not</span> <a href=\"./Mathlib/Order/Notation.html#Inf.inf\">⊓</a> <span class=\"fn\"><span class=\"fn\">ψ</span>.not</span></span>)</span>.not</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L497-L498","name":"FirstOrder.Language.BoundedFormula.imp_semanticallyEquivalent_not_sup","line":497,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.imp_semanticallyEquivalent_not_sup","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.imp_semanticallyEquivalent_not_sup\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">imp_semanticallyEquivalent_not_sup</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.imp</span> <span class=\"fn\">ψ</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.not</span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\">ψ</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L494-L495","name":"FirstOrder.Language.BoundedFormula.semanticallyEquivalent_not_not","line":494,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_not_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_not_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">semanticallyEquivalent_not_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.not</span>.not</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L485-L486","name":"FirstOrder.Language.completeTheory.isComplete","line":485,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isComplete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isComplete\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">completeTheory</span>.<span class=\"name\">isComplete</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.completeTheory</span> <span class=\"fn\">M</span></span>)</span>.IsComplete</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L482-L483","name":"FirstOrder.Language.completeTheory.isMaximal","line":482,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isMaximal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isMaximal\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">completeTheory</span>.<span class=\"name\">isMaximal</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.completeTheory</span> <span class=\"fn\">M</span></span>)</span>.IsMaximal</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L479-L480","name":"FirstOrder.Language.completeTheory.mem_or_not_mem","line":479,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.mem_or_not_mem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.mem_or_not_mem\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">completeTheory</span>.<span class=\"name\">mem_or_not_mem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.completeTheory</span> <span class=\"fn\">M</span></span></span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.completeTheory</span> <span class=\"fn\">M</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L476-L477","name":"FirstOrder.Language.completeTheory.isSatisfiable","line":476,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isSatisfiable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isSatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">completeTheory</span>.<span class=\"name\">isSatisfiable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.completeTheory</span> <span class=\"fn\">M</span></span>)</span>.IsSatisfiable</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L462-L467","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.imp","line":462,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.imp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.imp\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">imp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ' : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ' : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h' : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ'</span> <span class=\"fn\">ψ'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.imp</span> <span class=\"fn\">φ'</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">ψ</span>.imp</span> <span class=\"fn\">ψ'</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L456-L460","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.not","line":456,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\"><span class=\"fn\">φ</span>.not</span> <span class=\"fn\"><span class=\"fn\">ψ</span>.not</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L450-L454","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.ex","line":450,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.ex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.ex\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">ex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\"><span class=\"fn\">φ</span>.ex</span> <span class=\"fn\"><span class=\"fn\">ψ</span>.ex</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L444-L448","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.all","line":444,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.all","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.all\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">all</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\"><span class=\"fn\">φ</span>.all</span> <span class=\"fn\"><span class=\"fn\">ψ</span>.all</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L440-L442","name":"FirstOrder.Language.Theory.semanticallyEquivalentSetoid","line":440,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.semanticallyEquivalentSetoid","doc":"Semantic equivalence forms an equivalence relation on formulas. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.semanticallyEquivalentSetoid\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">semanticallyEquivalentSetoid</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Setoid\">Setoid</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L434-L437","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.realize_iff","line":434,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.realize_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.realize_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">realize_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Formula</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Formula</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{M : <a href=\"./foundational_types.html\">Type</a> (max u v)}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(_hM : <span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.Realize</span> <span class=\"fn\">v</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">ψ</span>.Realize</span> <span class=\"fn\">v</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L429-L432","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.realize_bd_iff","line":429,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.realize_bd_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.realize_bd_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">realize_bd_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{M : <a href=\"./foundational_types.html\">Type</a> (max u v)}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{xs : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Fin\">Fin</a> <span class=\"fn\">n</span></span> → <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.Realize</span> <span class=\"fn\">v</span> <span class=\"fn\">xs</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">ψ</span>.Realize</span> <span class=\"fn\">v</span> <span class=\"fn\">xs</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L421-L427","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.trans","line":421,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.trans","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.trans\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{θ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">ψ</span> <span class=\"fn\">θ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\">θ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L415-L418","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.symm","line":415,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.symm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.symm\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">symm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">ψ</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L411-L412","name":"FirstOrder.Language.Theory.instIsReflBoundedFormulaSemanticallyEquivalent","line":411,"kind":"instance","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.instIsReflBoundedFormulaSemanticallyEquivalent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.instIsReflBoundedFormulaSemanticallyEquivalent\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">instIsReflBoundedFormulaSemanticallyEquivalent</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/Algebra/Classes.html#IsRefl\">IsRefl</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span> <span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L408-L409","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.refl","line":408,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.refl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.refl\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">refl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.SemanticallyEquivalent</span> <span class=\"fn\">φ</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L404-L405","name":"FirstOrder.Language.Theory.SemanticallyEquivalent","line":404,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent","doc":"Two (bounded) formulas are semantically equivalent over a theory `T` when they have the same\ninterpretation in every model of `T`. (This is also known as logical equivalence, which also has a\nproof-theoretic definition.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L398-L399","name":"FirstOrder.Language.Theory.IsMaximal.mem_iff_models","line":398,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_iff_models","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_iff_models\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsMaximal</span>.<span class=\"name\">mem_iff_models</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">T</span>.IsMaximal</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">T</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L393-L396","name":"FirstOrder.Language.Theory.IsMaximal.mem_of_models","line":393,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_of_models","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_of_models\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsMaximal</span>.<span class=\"name\">mem_of_models</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">T</span>.IsMaximal</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hφ : <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">T</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L390-L391","name":"FirstOrder.Language.Theory.IsMaximal.mem_or_not_mem","line":390,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_or_not_mem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_or_not_mem\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsMaximal</span>.<span class=\"name\">mem_or_not_mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">T</span>.IsMaximal</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">T</span></span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">T</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L387-L388","name":"FirstOrder.Language.Theory.IsMaximal.isComplete","line":387,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.isComplete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.isComplete\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsMaximal</span>.<span class=\"name\">isComplete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">T</span>.IsMaximal</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">T</span>.IsComplete</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L384-L385","name":"FirstOrder.Language.Theory.IsMaximal","line":384,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal","doc":"A theory is maximal when it is satisfiable and contains each sentence or its negation.\nMaximal theories are complete. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsMaximal</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L372-L378","name":"FirstOrder.Language.Theory.IsComplete.realize_sentence_iff","line":372,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete.realize_sentence_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete.realize_sentence_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsComplete</span>.<span class=\"name\">realize_sentence_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">T</span>.IsComplete</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Sentence.Realize\">⊨</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L360-L370","name":"FirstOrder.Language.Theory.IsComplete.models_not_iff","line":360,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete.models_not_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete.models_not_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsComplete</span>.<span class=\"name\">models_not_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">T</span>.IsComplete</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L355-L356","name":"FirstOrder.Language.Theory.IsComplete","line":355,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete","doc":"A theory is complete when it is satisfiable and models each sentence or its negation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsComplete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L338-L352","name":"FirstOrder.Language.Theory.models_iff_finset_models","line":338,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_iff_finset_models","doc":"An alternative statement of the Compactness Theorem. A formula `φ` is modeled by a\ntheory iff there is a finite subset `T0` of the theory such that `φ` is modeled by `T0` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_iff_finset_models\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_iff_finset_models</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">T0</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Basic.html#Finset\">Finset</a> <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">T0</span></span> <a href=\"./Init/Core.html#HasSubset.Subset\">⊆</a> <span class=\"fn\">T</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">T0</span></span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L327-L334","name":"FirstOrder.Language.Theory.models_of_models_theory","line":327,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_of_models_theory","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_of_models_theory\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_of_models_theory</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T' : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ <span class=\"fn\">φ</span> ∈ <span class=\"fn\">T'</span>, <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Formula</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hφ : <span class=\"fn\"><span class=\"fn\">T'</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L316-L325","name":"FirstOrder.Language.Theory.ModelsBoundedFormula.realize_sentence","line":316,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula.realize_sentence","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula.realize_sentence\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">ModelsBoundedFormula</span>.<span class=\"name\">realize_sentence</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Sentence.Realize\">⊨</a> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L299-L314","name":"FirstOrder.Language.Theory.models_iff_not_satisfiable","line":299,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_iff_not_satisfiable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_iff_not_satisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_iff_not_satisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Init/Core.html#Union.union\">∪</a> <span class=\"fn\">{<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span>}</span></span>)</span>.IsSatisfiable</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L296-L297","name":"FirstOrder.Language.Theory.models_sentence_of_mem","line":296,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_sentence_of_mem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_sentence_of_mem\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_sentence_of_mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L293-L294","name":"FirstOrder.Language.Theory.models_sentence_iff","line":293,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_sentence_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_sentence_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_sentence_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\">L</span>.Sentence</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">M</span> : <span class=\"fn\"><span class=\"fn\">T</span>.ModelType</span>), <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">M</span></span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Sentence.Realize\">⊨</a> <span class=\"fn\">φ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L289-L291","name":"FirstOrder.Language.Theory.models_formula_iff","line":289,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_formula_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_formula_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_formula_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Formula</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">M</span> : <span class=\"fn\"><span class=\"fn\">T</span>.ModelType</span>) (<span class=\"fn\">v</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">↑<span class=\"fn\">M</span></span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.Realize</span> <span class=\"fn\">v</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L284-L285","name":"FirstOrder.Language.Theory.«term_⊨ᵇ_»","line":284,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.«term_⊨ᵇ_»","doc":"A theory models a (bounded) formula when any of its nonempty models realizes that formula on all\ninputs. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.«term_⊨ᵇ_»\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">«term_⊨ᵇ_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L280-L281","name":"FirstOrder.Language.Theory.ModelsBoundedFormula","line":280,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula","doc":"A theory models a (bounded) formula when any of its nonempty models realizes that formula on all\ninputs. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">ModelsBoundedFormula</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.BoundedFormula</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L266-L274","name":"FirstOrder.Language.Theory.exists_model_card_eq","line":266,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.exists_model_card_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.exists_model_card_eq\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">exists_model_card_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∃ (<span class=\"fn\">M</span> : <span class=\"fn\"><span class=\"fn\">T</span>.ModelType</span>), <span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">↑<span class=\"fn\">M</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0\">Cardinal.aleph0</a> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\"><span class=\"fn\">L</span>.card</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (<span class=\"fn\">N</span> : <span class=\"fn\"><span class=\"fn\">T</span>.ModelType</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">κ</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L255-L260","name":"FirstOrder.Language.exists_elementarilyEquivalent_card_eq","line":255,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementarilyEquivalent_card_eq","doc":"A consequence of the Löwenheim–Skolem Theorem: If `κ` is a cardinal greater than the\ncardinalities of `L` and an infinite `L`-structure `M`, then there is a structure of cardinality `κ`\nelementarily equivalent to `M`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementarilyEquivalent_card_eq\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">exists_elementarilyEquivalent_card_eq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0\">Cardinal.aleph0</a> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\"><span class=\"fn\">L</span>.card</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (<span class=\"fn\">N</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Bundled.html#CategoryTheory.Bundled\">CategoryTheory.Bundled</a> <span class=\"fn\"><span class=\"fn\">L</span>.Structure</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.ElementarilyEquivalent</span> <span class=\"fn\">M</span> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">κ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L241-L250","name":"FirstOrder.Language.exists_elementaryEmbedding_card_eq","line":241,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq","doc":"The Löwenheim–Skolem Theorem: If `κ` is a cardinal greater than the cardinalities of `L`\nand an infinite `L`-structure `M`, then there is an elementary embedding in the appropriate\ndirection between then `M` and a structure of cardinality `κ`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">exists_elementaryEmbedding_card_eq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[iM : <span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0\">Cardinal.aleph0</a> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\"><span class=\"fn\">L</span>.card</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (<span class=\"fn\">N</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Bundled.html#CategoryTheory.Bundled\">CategoryTheory.Bundled</a> <span class=\"fn\"><span class=\"fn\">L</span>.Structure</span></span>),\n  <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.ElementaryEmbedding</span> <span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">N</span></span>)</span> <span class=\"fn\">M</span></span>)</span></span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.ElementaryEmbedding</span> <span class=\"fn\">M</span> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span>)</span></span></span>)</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">κ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L215-L234","name":"FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_ge","line":215,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_ge","doc":"The **Upward Löwenheim–Skolem Theorem**: If `κ` is a cardinal greater than the cardinalities of\n`L` and an infinite `L`-structure `M`, then `M` has an elementary extension of cardinality `κ`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_ge\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">exists_elementaryEmbedding_card_eq_of_ge</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[iM : <span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\"><span class=\"fn\">L</span>.card</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, w'}</a>     <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">M</span></span>)</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w', w}</a>    <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (<span class=\"fn\">N</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Bundled.html#CategoryTheory.Bundled\">CategoryTheory.Bundled</a> <span class=\"fn\"><span class=\"fn\">L</span>.Structure</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.ElementaryEmbedding</span> <span class=\"fn\">M</span> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span>)</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">κ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L195-L207","name":"FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_le","line":195,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_le","doc":"A version of The Downward Löwenheim–Skolem theorem where the structure `N` elementarily embeds\ninto `M`, but is not by type a substructure of `M`, and thus can be chosen to belong to the universe\nof the cardinal `κ`.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_le\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">exists_elementaryEmbedding_card_eq_of_le</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0\">Cardinal.aleph0</a> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\"><span class=\"fn\">L</span>.card</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h3 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w', w}</a>    <span class=\"fn\">κ</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, w'}</a>     <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">M</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (<span class=\"fn\">N</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Bundled.html#CategoryTheory.Bundled\">CategoryTheory.Bundled</a> <span class=\"fn\"><span class=\"fn\">L</span>.Structure</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.ElementaryEmbedding</span> <span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">N</span></span>)</span> <span class=\"fn\">M</span></span>)</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">κ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L173-L185","name":"FirstOrder.Language.Theory.isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset","line":173,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">ι</span> → <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">(<span class=\"fn\">⋃ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><span class=\"fn\">T</span> <span class=\"fn\">i</span></span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Basic.html#Finset\">Finset</a> <span class=\"fn\">ι</span></span>), <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">(<span class=\"fn\">⋃ <span class=\"fn\">i</span> ∈ <span class=\"fn\">s</span>, <span class=\"fn\"><span class=\"fn\">T</span> <span class=\"fn\">i</span></span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L159-L171","name":"FirstOrder.Language.Theory.exists_large_model_of_infinite_model","line":159,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.exists_large_model_of_infinite_model","doc":"Any theory with an infinite model has arbitrarily large models. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.exists_large_model_of_infinite_model\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">exists_large_model_of_infinite_model</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (<span class=\"fn\">N</span> : <span class=\"fn\"><span class=\"fn\">T</span>.ModelType</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v w, w}</a>           <span class=\"fn\">κ</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L143-L156","name":"FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_infinite","line":143,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_infinite","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_infinite\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_union_distinctConstantsTheory_of_infinite</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.lhomWithConstants</span> <span class=\"fn\">α</span></span>)</span>.onTheory</span> <span class=\"fn\">T</span></span> <a href=\"./Init/Core.html#Union.union\">∪</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.distinctConstantsTheory</span> <span class=\"fn\">s</span></span></span>)</span>.IsSatisfiable</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L125-L141","name":"FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_card_le","line":125,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_card_le","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_card_le\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_union_distinctConstantsTheory_of_card_le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w', w}</a>    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">s</span></span></span>)</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, w'}</a>     <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">M</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.lhomWithConstants</span> <span class=\"fn\">α</span></span>)</span>.onTheory</span> <span class=\"fn\">T</span></span> <a href=\"./Init/Core.html#Union.union\">∪</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.distinctConstantsTheory</span> <span class=\"fn\">s</span></span></span>)</span>.IsSatisfiable</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L117-L123","name":"FirstOrder.Language.Theory.isSatisfiable_directed_union_iff","line":117,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_directed_union_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_directed_union_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_directed_union_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">ι</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">ι</span> → <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Order/Directed.html#Directed\">Directed</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">x</span> <span class=\"fn\">x_1</span> : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Core.html#HasSubset.Subset\">⊆</a> <span class=\"fn\">x_1</span></span></span>)</span> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">(<span class=\"fn\">⋃ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><span class=\"fn\">T</span> <span class=\"fn\">i</span></span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">T</span> <span class=\"fn\">i</span></span>)</span>.IsSatisfiable</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L96-L115","name":"FirstOrder.Language.Theory.isSatisfiable_iff_isFinitelySatisfiable","line":96,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_iff_isFinitelySatisfiable","doc":"The **Compactness Theorem of first-order logic**: A theory is satisfiable if and only if it is\nfinitely satisfiable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_iff_isFinitelySatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_iff_isFinitelySatisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span>.IsSatisfiable</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">T</span>.IsFinitelySatisfiable</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L91-L92","name":"FirstOrder.Language.Theory.IsSatisfiable.isFinitelySatisfiable","line":91,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable.isFinitelySatisfiable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable.isFinitelySatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsSatisfiable</span>.<span class=\"name\">isFinitelySatisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">T</span>.IsSatisfiable</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">T</span>.IsFinitelySatisfiable</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L84-L89","name":"FirstOrder.Language.Theory.isSatisfiable_onTheory_iff","line":84,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_onTheory_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_onTheory_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_onTheory_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L' : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\">L</span> <a href=\"./Mathlib/ModelTheory/LanguageMap.html#FirstOrder.Language.LHom\">→ᴸ</a> <span class=\"fn\">L'</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">φ</span>.Injective</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.onTheory</span> <span class=\"fn\">T</span></span>)</span>.IsSatisfiable</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">T</span>.IsSatisfiable</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L80-L82","name":"FirstOrder.Language.Theory.isSatisfiable_of_isSatisfiable_onTheory","line":80,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_of_isSatisfiable_onTheory","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_of_isSatisfiable_onTheory\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_of_isSatisfiable_onTheory</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L' : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\">L</span> <a href=\"./Mathlib/ModelTheory/LanguageMap.html#FirstOrder.Language.LHom\">→ᴸ</a> <span class=\"fn\">L'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.onTheory</span> <span class=\"fn\">T</span></span>)</span>.IsSatisfiable</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">T</span>.IsSatisfiable</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L77-L78","name":"FirstOrder.Language.Theory.isSatisfiable_empty","line":77,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_empty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_empty\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_empty</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>.IsSatisfiable</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L74-L75","name":"FirstOrder.Language.Theory.IsSatisfiable.mono","line":74,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable.mono","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable.mono\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsSatisfiable</span>.<span class=\"name\">mono</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T' : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">T'</span>.IsSatisfiable</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Init/Core.html#HasSubset.Subset\">⊆</a> <span class=\"fn\">T'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">T</span>.IsSatisfiable</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L70-L72","name":"FirstOrder.Language.Theory.Model.isSatisfiable","line":70,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.Model.isSatisfiable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.Model.isSatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">Model</span>.<span class=\"name\">isSatisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">L</span>.Structure</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">T</span>.IsSatisfiable</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L65-L66","name":"FirstOrder.Language.Theory.IsFinitelySatisfiable","line":65,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsFinitelySatisfiable","doc":"A theory is finitely satisfiable if all of its finite subtheories are satisfiable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsFinitelySatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsFinitelySatisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/ModelTheory/Satisfiability.lean#L61-L62","name":"FirstOrder.Language.Theory.IsSatisfiable","line":61,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable","doc":"A theory is satisfiable if a structure models it. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsSatisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">L</span>.Theory</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"}]}