{"name":"Mathlib.Tactic.Linarith.Oracle.FourierMotzkin","instances":[{"typeNames":["Linarith.CompSource"],"name":"Linarith.instInhabitedCompSource","className":"Inhabited"},{"typeNames":["Linarith.CompSource"],"name":"Linarith.instToFormatCompSource","className":"Std.ToFormat"},{"typeNames":["Linarith.PComp"],"name":"Linarith.instToFormatPComp","className":"Std.ToFormat"},{"typeNames":["Linarith.PComp"],"name":"Linarith.instToStringPComp","className":"ToString"}],"imports":["Init","Mathlib.Tactic.Linarith.Datatypes","Batteries.Data.HashMap.WF"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L329-L333","name":"Linarith.CertificateOracle.fourierMotzkin","line":329,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CertificateOracle.fourierMotzkin","doc":"An oracle that uses Fourier-Motzkin elimination. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CertificateOracle.fourierMotzkin\"><span class=\"name\">Linarith</span>.<span class=\"name\">CertificateOracle</span>.<span class=\"name\">fourierMotzkin</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.CertificateOracle\">Linarith.CertificateOracle</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L325-L326","name":"Linarith.mkLinarithData","line":325,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.mkLinarithData","doc":"`mkLinarithData hyps vars` takes a list of hypotheses and the largest variable present in\nthose hypotheses. It produces an initial state for the elimination monad.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.mkLinarithData\"><span class=\"name\">Linarith</span>.<span class=\"name\">mkLinarithData</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(hyps : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(maxVar : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData\">Linarith.LinarithData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L317-L319","name":"Linarith.elimAllVarsM","line":317,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimAllVarsM","doc":"`elimAllVarsM` eliminates all variables from the linarith state, leaving it with a set of\nground comparisons. If this succeeds without exception, the original `linarith` state is consistent.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimAllVarsM\"><span class=\"name\">Linarith</span>.<span class=\"name\">elimAllVarsM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">Linarith.LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L305-L311","name":"Linarith.elimVarM","line":305,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimVarM","doc":"`elimVarM a` performs one round of Fourier-Motzkin elimination, eliminating the variable `a`\nfrom the `linarith` state.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimVarM\"><span class=\"name\">Linarith</span>.<span class=\"name\">elimVarM</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">Linarith.LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L293-L299","name":"Linarith.splitSetByVarSign","line":293,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.splitSetByVarSign","doc":"`splitSetByVarSign a comps` partitions the set `comps` into three parts.\n* `pos` contains the elements of `comps` in which `a` has a positive coefficient.\n* `neg` contains the elements of `comps` in which `a` has a negative coefficient.\n* `notPresent` contains the elements of `comps` in which `a` has coefficient 0.\n\nReturns `(pos, neg, notPresent)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.splitSetByVarSign\"><span class=\"name\">Linarith</span>.<span class=\"name\">splitSetByVarSign</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(comps : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">Linarith.PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">Linarith.PCompSet</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">Linarith.PCompSet</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">Linarith.PCompSet</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L281-L283","name":"Linarith.update","line":281,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.update","doc":"Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.update\"><span class=\"name\">Linarith</span>.<span class=\"name\">update</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(maxVar : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(comps : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">Linarith.PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">Linarith.LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L272-L275","name":"Linarith.validate","line":272,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.validate","doc":"Throws an exception if a contradictory `PComp` is contained in the current state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.validate\"><span class=\"name\">Linarith</span>.<span class=\"name\">validate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">Linarith.LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L268-L269","name":"Linarith.getPCompSet","line":268,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.getPCompSet","doc":"Return the current comparison set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.getPCompSet\"><span class=\"name\">Linarith</span>.<span class=\"name\">getPCompSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">Linarith.LinarithM</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">Linarith.PCompSet</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L264-L265","name":"Linarith.getMaxVar","line":264,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.getMaxVar","doc":"Returns the current max variable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.getMaxVar\"><span class=\"name\">Linarith</span>.<span class=\"name\">getMaxVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">Linarith.LinarithM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L260-L261","name":"Linarith.LinarithM","line":260,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM","doc":"The linarith monad extends an exceptional monad with a `LinarithData` state.\nAn exception produces a contradictory `PComp`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L254-L254","name":"Linarith.LinarithData.comps","line":254,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.comps","doc":"The set of comparisons. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.comps\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span>.<span class=\"name\">comps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData\">Linarith.LinarithData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">Linarith.PCompSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L252-L252","name":"Linarith.LinarithData.maxVar","line":252,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.maxVar","doc":"The largest variable index that has not been (officially) eliminated. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.maxVar\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span>.<span class=\"name\">maxVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData\">Linarith.LinarithData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L250-L250","name":"Linarith.LinarithData.mk","line":250,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.mk\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(maxVar : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(comps : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">Linarith.PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData\">Linarith.LinarithData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L250-L254","name":"Linarith.LinarithData","line":250,"kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData","doc":"The state for the elimination monad.\n* `maxVar`: the largest variable index that has not been eliminated.\n* `comps`: a set of comparisons\n\nThe elimination procedure proceeds by eliminating variable `v` from `comps` progressively\nin decreasing order.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L236-L240","name":"Linarith.elimWithSet","line":236,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimWithSet","doc":"`elimWithSet a p comps` collects the result of calling `pelimVar p p' a`\nfor every `p' ∈ comps`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimWithSet\"><span class=\"name\">Linarith</span>.<span class=\"name\">elimWithSet</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(comps : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">Linarith.PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">Linarith.PCompSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L230-L230","name":"Linarith.PComp.isContr","line":230,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.isContr","doc":"A `PComp` represents a contradiction if its `Comp` field represents a contradiction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.isContr\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">isContr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L223-L225","name":"Linarith.pelimVar","line":223,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.pelimVar","doc":"`pelimVar p1 p2` calls `elimVar` on the `Comp` components of `p1` and `p2`.\nIf this returns `v1` and `v2`, it creates a new `PComp` equal to `v1*p1 + v2*p2`,\nand tracks this in the `CompSource`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.pelimVar\"><span class=\"name\">Linarith</span>.<span class=\"name\">pelimVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p1 : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p2 : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L210-L216","name":"Linarith.elimVar","line":210,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimVar","doc":"If `c1` and `c2` both contain variable `a` with opposite coefficients,\nproduces `v1` and `v2` such that `a` has been cancelled in `v1*c1 + v2*c2`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimVar\"><span class=\"name\">Linarith</span>.<span class=\"name\">elimVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c1 : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c2 : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L204-L204","name":"Linarith.PCompSet","line":204,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet","doc":"A collection of comparisons. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\"><span class=\"name\">Linarith</span>.<span class=\"name\">PCompSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L200-L201","name":"Linarith.instToStringPComp","line":200,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToStringPComp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToStringPComp\"><span class=\"name\">Linarith</span>.<span class=\"name\">instToStringPComp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L197-L198","name":"Linarith.instToFormatPComp","line":197,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToFormatPComp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToFormatPComp\"><span class=\"name\">Linarith</span>.<span class=\"name\">instToFormatPComp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Lean.ToFormat</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L189-L195","name":"Linarith.PComp.assump","line":189,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.assump","doc":"`PComp.assump c n` creates a `PComp` whose comparison is `c` and whose source is\n`CompSource.assump n`, that is, `c` is derived from the `n`th hypothesis.\nThe history is the singleton set `{n}`.\nNo variables have been eliminated (effectively or implicitly).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.assump\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">assump</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L174-L181","name":"Linarith.PComp.add","line":174,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.add","doc":"`PComp.add c1 c2 elimVar` creates the result of summing the linear comparisons `c1` and `c2`,\nduring the process of eliminating the variable `elimVar`.\nThe computation assumes, but does not enforce, that `elimVar` appears in both `c1` and `c2`\nand does not appear in the sum.\nComputing the sum of the two comparisons is easy; the complicated details lie in tracking the\nadditional fields of `PComp`.\n* The historical set `pcomp.history` of `c1 + c2` is the union of the two historical sets.\n* `vars` is the union of `c1.vars` and `c2.vars`.\n* The effectively eliminated variables of `c1 + c2` are the union of the two effective sets,\n  with `elim_var` inserted.\n* The implicitly eliminated variables of `c1 + c2` are those that appear in\n  `vars` but not `c.vars` or `effective`.\n(Note that the description of the implicitly eliminated variables of `c1 + c2` in the algorithm\ndescribed in Section 6 of https://doi.org/10.1016/B978-0-444-88771-9.50019-2 seems to be wrong:\nthat says it should be `(c1.implicit.union c2.implicit).sdiff explicit`.\nSince the implicitly eliminated sets start off empty for the assumption,\nthis formula would leave them always empty.)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.add\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c1 : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c2 : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(elimVar : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L152-L153","name":"Linarith.PComp.scale","line":152,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.scale","doc":"`PComp.scale c n` scales the coefficients of `c` by `n` and notes this in the `CompSource`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.scale\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">scale</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L149-L149","name":"Linarith.PComp.cmp","line":149,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.cmp","doc":"The `src : CompSource` field is ignored when comparing `PComp`s. Two `PComp`s proving the same\ncomparison, with different sources, are considered equivalent.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.cmp\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">cmp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p1 : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p2 : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L142-L143","name":"Linarith.PComp.maybeMinimal","line":142,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.maybeMinimal","doc":"Any comparison whose history is not minimal is redundant,\nand need not be included in the new set of comparisons.\n`elimedGE : ℕ` is a natural number such that all variables with index ≥ `elimedGE` have been\nremoved from the system.\n\nThis test is an overapproximation to minimality. It gives necessary but not sufficient conditions.\nIf the history of `c` is minimal, then `c.maybeMinimal` is true,\nbut `c.maybeMinimal` may also be true for some `c` with non-minimal history.\nThus, if `c.maybeMinimal` is false, `c` is known not to be minimal and must be redundant.\nSee https://doi.org/10.1016/B978-0-444-88771-9.50019-2 (Theorem 13).\nThe condition described there considers only implicitly eliminated variables that have been\nofficially eliminated from the system. This is not the case for every implicitly eliminated\nvariable. Consider eliminating `z` from `{x + y + z < 0, x - y - z < 0}`. The result is the set\n`{2*x < 0}`; `y` is implicitly but not officially eliminated.\n\nThis implementation of Fourier-Motzkin elimination processes variables in decreasing order of\nindices. Immediately after a step that eliminates variable `k`, variable `k'` has been eliminated\niff `k' ≥ k`. Thus we can compute the intersection of officially and implicitly eliminated variables\nby taking the set of implicitly eliminated variables with indices ≥ `elimedGE`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.maybeMinimal\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">maybeMinimal</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(elimedGE : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L119-L119","name":"Linarith.PComp.vars","line":119,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.vars","doc":"The union of all variables appearing in those original assumptions\nwhich appear in the `history` set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.vars\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">vars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Data/RBMap/Basic.html#Batteries.RBSet\">Batteries.RBSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <span class=\"fn\">compare</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L116-L116","name":"Linarith.PComp.implicit","line":116,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.implicit","doc":"The variables which have been *implicitly eliminated*.\nThese are variables that appear in the historical set,\ndo not appear in `c` itself, and are not in `effective. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.implicit\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">implicit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Data/RBMap/Basic.html#Batteries.RBSet\">Batteries.RBSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <span class=\"fn\">compare</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L112-L112","name":"Linarith.PComp.effective","line":112,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.effective","doc":"The variables which have been *effectively eliminated*,\ni.e. by running the elimination algorithm on that variable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.effective\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">effective</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Data/RBMap/Basic.html#Batteries.RBSet\">Batteries.RBSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <span class=\"fn\">compare</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L109-L109","name":"Linarith.PComp.history","line":109,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.history","doc":"The set of original assumptions which have been used in constructing this comparison. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.history\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">history</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Data/RBMap/Basic.html#Batteries.RBSet\">Batteries.RBSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <span class=\"fn\">compare</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L107-L107","name":"Linarith.PComp.src","line":107,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.src","doc":"We track how the comparison was constructed by adding and scaling previous comparisons,\nback to the original assumptions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.src\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">src</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L104-L104","name":"Linarith.PComp.c","line":104,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.c","doc":"The comparison `Σ cᵢ*xᵢ R 0`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.c\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">c</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L102-L102","name":"Linarith.PComp.mk","line":102,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.mk\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(history : <span class=\"fn\"><a href=\"./Batteries/Data/RBMap/Basic.html#Batteries.RBSet\">Batteries.RBSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <span class=\"fn\">compare</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(effective : <span class=\"fn\"><a href=\"./Batteries/Data/RBMap/Basic.html#Batteries.RBSet\">Batteries.RBSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <span class=\"fn\">compare</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(implicit : <span class=\"fn\"><a href=\"./Batteries/Data/RBMap/Basic.html#Batteries.RBSet\">Batteries.RBSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <span class=\"fn\">compare</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(vars : <span class=\"fn\"><a href=\"./Batteries/Data/RBMap/Basic.html#Batteries.RBSet\">Batteries.RBSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <span class=\"fn\">compare</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">Linarith.PComp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L102-L119","name":"Linarith.PComp","line":102,"kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp","doc":"A `PComp` stores a linear comparison `Σ cᵢ*xᵢ R 0`,\nalong with information about how this comparison was derived.\nThe original expressions fed into `linarith` are each assigned a unique natural number label.\nThe *historical set* `PComp.history` stores the labels of expressions\nthat were used in deriving the current `PComp`.\nVariables are also indexed by natural numbers. The sets `PComp.effective`, `PComp.implicit`,\nand `PComp.vars` contain variable indices.\n* `PComp.vars` contains the variables that appear in any inequality in the historical set.\n* `PComp.effective` contains the variables that have been effectively eliminated from `PComp`.\n  A variable `n` is said to be *effectively eliminated* in `p : PComp` if the elimination of `n`\n  produced at least one of the ancestors of `p` (or `p` itself).\n* `PComp.implicit` contains the variables that have been implicitly eliminated from `PComp`.\n  A variable `n` is said to be *implicitly eliminated* in `p` if it satisfies the following\n  properties:\n  - `n` appears in some inequality in the historical set (i.e. in `p.vars`).\n  - `n` does not appear in `p.c.vars` (i.e. it has been eliminated).\n  - `n` was not effectively eliminated.\n\nWe track these sets in order to compute whether the history of a `PComp` is *minimal*.\nChecking this directly is expensive, but effective approximations can be defined in terms of these\nsets. During the variable elimination process, a `PComp` with non-minimal history can be discarded.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L76-L77","name":"Linarith.instToFormatCompSource","line":76,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToFormatCompSource","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToFormatCompSource\"><span class=\"name\">Linarith</span>.<span class=\"name\">instToFormatCompSource</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Lean.ToFormat</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L71-L74","name":"Linarith.CompSource.toString","line":71,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.toString","doc":"Formats a `CompSource` for printing. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.toString\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">toString</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a> → <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L64-L68","name":"Linarith.CompSource.flatten","line":64,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.flatten","doc":"Given a `CompSource` `cs`, `cs.flatten` maps an assumption index\nto the number of copies of that assumption that appear in the history of `cs`.\n\nFor example, suppose `cs` is produced by scaling assumption 2 by 5,\nand adding to that the sum of assumptions 1 and 2.\n`cs.flatten` maps `1 ↦ 1, 2 ↦ 6`.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.flatten\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">flatten</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a> → <span class=\"fn\"><a href=\"./Batteries/Data/HashMap/Basic.html#Batteries.HashMap\">Batteries.HashMap</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L54-L54","name":"Linarith.instInhabitedCompSource","line":54,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instInhabitedCompSource","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instInhabitedCompSource\"><span class=\"name\">Linarith</span>.<span class=\"name\">instInhabitedCompSource</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L53-L53","name":"Linarith.CompSource.scale","line":53,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.scale","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.scale\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">scale</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L52-L52","name":"Linarith.CompSource.add","line":52,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.add","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.add\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L51-L51","name":"Linarith.CompSource.assump","line":51,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.assump","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.assump\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">assump</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">Linarith.CompSource</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L50-L54","name":"Linarith.CompSource","line":50,"kind":"inductive","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource","doc":"`CompSource` tracks the source of a comparison.\nThe atomic source of a comparison is an assumption, indexed by a natural number.\nTwo comparisons can be added to produce a new comparison,\nand one comparison can be scaled by a natural number to produce a new comparison.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}