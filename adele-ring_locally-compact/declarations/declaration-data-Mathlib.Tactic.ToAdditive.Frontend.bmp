{"name":"Mathlib.Tactic.ToAdditive.Frontend","instances":[{"typeNames":["ToAdditive.Config"],"name":"ToAdditive.instReprConfig","className":"Repr"}],"imports":["Init","Mathlib.Data.Nat.Notation","Mathlib.Data.String.Defs","Mathlib.Data.Array.Defs","Mathlib.Lean.Expr.ReplaceRec","Mathlib.Lean.EnvExtension","Mathlib.Lean.Meta.Simp","Mathlib.Lean.Name","Lean.Elab.Tactic.Ext","Lean.Meta.Tactic.Symm","Lean.Meta.Tactic.Rfl","Batteries.Lean.NameMapAttribute","Batteries.Tactic.Lint","Mathlib.Tactic.Relation.Trans","Mathlib.Tactic.Eqns","Mathlib.Tactic.Simps.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L1218-L1260","name":"ToAdditive.addToAdditiveAttr","line":1218,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.addToAdditiveAttr","doc":"`addToAdditiveAttr src cfg` adds a `@[to_additive]` attribute to `src` with configuration `cfg`.\nSee the attribute implementation for more details.\nIt returns an array with names of additive declarations (usually 1, but more if there are nested\n`to_additive` calls. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.addToAdditiveAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">addToAdditiveAttr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(kind : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind\">Lean.AttributeKind</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind.global\">Lean.AttributeKind.global</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Attributes.html#Lean.AttrM\">Lean.AttrM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L1210-L1212","name":"ToAdditive.transformDecl","line":1210,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.transformDecl","doc":"Make a new copy of a declaration, replacing fragments of the names of identifiers in the type and\nthe body using the `translations` dictionary.\nThis is used to implement `@[to_additive]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.transformDecl\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">transformDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L1191-L1203","name":"ToAdditive.copyMetaData","line":1191,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.copyMetaData","doc":"Copies equation lemmas and attributes from `src` to `tgt`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.copyMetaData\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">copyMetaData</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L1126-L1186","name":"ToAdditive.applyAttributes","line":1126,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyAttributes","doc":"Apply attributes to the multiplicative and additive declarations. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyAttributes\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">applyAttributes</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(rawAttrs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(thisAttr : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L1098-L1122","name":"ToAdditive.elabToAdditive","line":1098,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.elabToAdditive","doc":"Elaboration of the configuration options for `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.elabToAdditive\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">elabToAdditive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L1085-L1095","name":"ToAdditive.proceedFields","line":1085,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.proceedFields","doc":"Add the structure fields of `src` to the translations dictionary\nso that future uses of `to_additive` will map them to the corresponding `tgt` fields. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.proceedFields\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">proceedFields</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L1072-L1081","name":"ToAdditive.proceedFieldsAux","line":1072,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.proceedFieldsAux","doc":"if `f src = #[a_1, ..., a_n]` and `f tgt = #[b_1, ... b_n]` then `proceedFieldsAux src tgt f`\nwill insert translations from `src.a_i` to `tgt.b_i`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.proceedFieldsAux\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">proceedFieldsAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L1051-L1068","name":"ToAdditive.targetName","line":1051,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.targetName","doc":"Return the provided target name or autogenerate one if one was not provided. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.targetName\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">targetName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L1042-L1048","name":"ToAdditive.guessName","line":1042,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.guessName","doc":"Autogenerate additive name.\nThis runs in several steps:\n1) Split according to capitalisation rule and at `_`.\n2) Apply word-by-word translation rules.\n3) Fix up abbreviations that are not word-by-word translations, like \"addComm\" or \"Nonneg\".\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.guessName\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">guessName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#String\">String</a> → <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L963-L1033","name":"ToAdditive.fixAbbreviation","line":963,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.fixAbbreviation","doc":"There are a few abbreviations we use. For example \"Nonneg\" instead of \"ZeroLE\"\nor \"addComm\" instead of \"commAdd\".\nNote: The input to this function is case sensitive!\nTodo: A lot of abbreviations here are manual fixes and there might be room to\n      improve the naming logic to reduce the size of `fixAbbreviation`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.fixAbbreviation\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">fixAbbreviation</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L952-L954","name":"ToAdditive.applyNameDict","line":952,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyNameDict","doc":"Turn each element to lower-case, apply the `nameDict` and\ncapitalize the output like the input.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyNameDict\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">applyNameDict</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L910-L946","name":"ToAdditive.nameDict","line":910,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.nameDict","doc":"Dictionary used by `guessName` to autogenerate names.\n\nNote: `guessName` capitalizes first element of the output according to\ncapitalization of the input. Input and first element should therefore be lower-case,\n2nd element should be capitalized properly.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.nameDict\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">nameDict</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#String\">String</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L899-L901","name":"ToAdditive.capitalizeFirstLike","line":899,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.capitalizeFirstLike","doc":"Capitalize First element of a list like `s`.\nNote that we need to capitalize multiple characters in some cases,\nin examples like `HMul` or `hAdd`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.capitalizeFirstLike\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">capitalizeFirstLike</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L893-L894","name":"ToAdditive.capitalizeLike","line":893,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.capitalizeLike","doc":"Capitalizes `s` char-by-char like `r`. If `s` is longer, it leaves the tail untouched. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.capitalizeLike\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">capitalizeLike</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(r : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L880-L890","name":"ToAdditive.capitalizeLikeAux","line":880,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.capitalizeLikeAux","doc":"Helper for `capitalizeLike`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.capitalizeLikeAux\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">capitalizeLikeAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#String.Pos\">String.Pos</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L860-L877","name":"ToAdditive.firstMultiplicativeArg","line":860,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.firstMultiplicativeArg","doc":"Find the first argument of `nm` that has a multiplicative type-class on it.\nReturns 1 if there are no types with a multiplicative class as arguments.\nE.g. `Prod.Group` returns 1, and `Pi.One` returns 2.\nNote: we only consider the first argument of each type-class.\nE.g. `[Pow A N]` is a multiplicative type-class on `A`, not on `N`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.firstMultiplicativeArg\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">firstMultiplicativeArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(nm : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L842-L851","name":"ToAdditive.additivizeLemmas","line":842,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additivizeLemmas","doc":"`additivizeLemmas names desc t` runs `t` on all elements of `names`\nand adds translations between the generated lemmas (the output of `t`).\n`names` must be non-empty. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additivizeLemmas\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">additivizeLemmas</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Exception.html#Lean.MonadError\">Lean.MonadError</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(names : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(desc : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L835-L837","name":"ToAdditive.warnParametricAttr","line":835,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.warnParametricAttr","doc":"Warn the user when the multiplicative declaration has a parametric attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.warnParametricAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">warnParametricAttr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attr : <span class=\"fn\"><a href=\"./Lean/Attributes.html#Lean.ParametricAttribute\">Lean.ParametricAttribute</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(thisAttr : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attrName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L830-L832","name":"ToAdditive.warnAttr","line":830,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.warnAttr","doc":"Warn the user when the multiplicative declaration has a simple scoped attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.warnAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">warnAttr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attr : <span class=\"fn\"><a href=\"./Lean/ScopedEnvExtension.html#Lean.SimpleScopedEnvExtension\">Lean.SimpleScopedEnvExtension</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(thisAttr : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attrName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L816-L827","name":"ToAdditive.warnExt","line":816,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.warnExt","doc":"Warn the user when the multiplicative declaration has an attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.warnExt\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">warnExt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{σ : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">σ</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ext : <span class=\"fn\"><a href=\"./Lean/Environment.html#Lean.PersistentEnvExtension\">Lean.PersistentEnvExtension</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">σ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">σ</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(thisAttr : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attrName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L808-L813","name":"ToAdditive.copyInstanceAttribute","line":808,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.copyInstanceAttribute","doc":"Copy the instance attribute in a `to_additive`\n\n[todo] it seems not to work when the `to_additive` is added as an attribute later. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.copyInstanceAttribute\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">copyInstanceAttribute</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L737-L803","name":"ToAdditive.transformDeclAux","line":737,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.transformDeclAux","doc":"transform the declaration `src` and all declarations `pre._proof_i` occurring in `src`\nusing the transforms dictionary.\n`replace_all`, `trace`, `ignore` and `reorder` are configuration options.\n`pre` is the declaration that got the `@[to_additive]` attribute and `tgt_pre` is the target of this\ndeclaration. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.transformDeclAux\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">transformDeclAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pre : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt_pre : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L725-L730","name":"ToAdditive.findAuxDecls","line":725,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findAuxDecls","doc":"Returns a `NameSet` of all auxiliary constants in `e` that might have been generated\nwhen adding `pre` to the environment.\nExamples include `pre.match_5` and\n`_private.Mathlib.MyFile.someOtherNamespace.someOtherDeclaration._eq_2`.\nThe last two examples may or may not have been generated by this declaration.\nThe last example may or may not be the equation lemma of a declaration with the `@[to_additive]`\nattribute. We will only translate it has the `@[to_additive]` attribute.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findAuxDecls\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">findAuxDecls</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pre : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Data/NameMap.html#Lean.NameSet\">Lean.NameSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L700-L715","name":"ToAdditive.findTargetName","line":700,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findTargetName","doc":"Find the target name of `pre` and all created auxiliary declarations. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findTargetName\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">findTargetName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(env : <a href=\"./Lean/Environment.html#Lean.Environment\">Lean.Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pre : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt_pre : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L683-L697","name":"ToAdditive.updateDecl","line":683,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.updateDecl","doc":"Run applyReplacementFun on the given `srcDecl` to make a new declaration with name `tgt` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.updateDecl\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">updateDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(srcDecl : <a href=\"./Lean/Declaration.html#Lean.ConstantInfo\">Lean.ConstantInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(reorder : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>)</span> <span class=\"fn\">[]</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Declaration.html#Lean.ConstantInfo\">Lean.ConstantInfo</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L676-L680","name":"ToAdditive.reorderLambda","line":676,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.reorderLambda","doc":"Reorder lambda-binders. See doc of `reorderAttr` for the interpretation of the argument "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.reorderLambda\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">reorderLambda</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(reorder : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>)</span> <span class=\"fn\">[]</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L669-L673","name":"ToAdditive.reorderForall","line":669,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.reorderForall","doc":"Reorder pi-binders. See doc of `reorderAttr` for the interpretation of the argument "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.reorderForall\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">reorderForall</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(reorder : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>)</span> <span class=\"fn\">[]</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L642-L666","name":"ToAdditive.expand","line":642,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.expand","doc":"`e.expand` eta-expands all expressions that have as head a constant `n` in\n`reorder`. They are expanded until they are applied to one more argument than the maximum in\n`reorder.find n`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.expand\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">expand</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L636-L637","name":"ToAdditive.etaExpandN","line":636,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.etaExpandN","doc":"Eta expands `e` at most `n` times. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.etaExpandN\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">etaExpandN</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L559-L633","name":"ToAdditive.applyReplacementFun.aux","line":559,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementFun.aux","doc":"Implementation of `applyReplacementFun`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementFun.aux\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">applyReplacementFun</span>.<span class=\"name\">aux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(findTranslation? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(reorderFn : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignore : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(changeNumeral? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(relevantArg : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(trace : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L551-L633","name":"ToAdditive.applyReplacementFun","line":551,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementFun","doc":"`applyReplacementFun e` replaces the expression `e` with its additive counterpart.\nIt translates each identifier (inductive type, defined function etc) in an expression, unless\n* The identifier occurs in an application with first argument `arg`; and\n* `test arg` is false.\nHowever, if `f` is in the dictionary `relevant`, then the argument `relevant.find f`\nis tested, instead of the first argument.\n\nIt will also reorder arguments of certain functions, using `reorderFn`:\ne.g. `g x₁ x₂ x₃ ... xₙ` becomes `g x₂ x₁ x₃ ... xₙ` if `reorderFn g = some [1]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementFun\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">applyReplacementFun</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L536-L538","name":"ToAdditive.changeNumeral","line":536,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.changeNumeral","doc":"Change the numeral `nat_lit 1` to the numeral `nat_lit 0`.\nLeave all other expressions unchanged. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.changeNumeral\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">changeNumeral</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L529-L532","name":"List.swapFirstTwo","line":529,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#List.swapFirstTwo","doc":"Swap the first two elements of a list "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#List.swapFirstTwo\"><span class=\"name\">List</span>.<span class=\"name\">swapFirstTwo</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L524-L526","name":"ToAdditive.additiveTest","line":524,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTest","doc":"`additiveTest e` tests whether the expression `e` contains a constant\n`nm` that is not applied to any arguments, and such that `translations.find?[nm] = none`.\nThis is used in `@[to_additive]` for deciding which subexpressions to transform: we only transform\nconstants if `additiveTest` applied to their first argument returns `true`.\nThis means we will replace expression applied to e.g. `α` or `α × β`, but not when applied to\ne.g. `ℕ` or `ℝ × α`.\nWe ignore all arguments specified by the `ignore` `NameMap`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTest\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">additiveTest</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(findTranslation? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignore : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L488-L512","name":"ToAdditive.additiveTestUnsafe.visit","line":488,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTestUnsafe.visit","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">unsafe def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTestUnsafe.visit\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">additiveTestUnsafe</span>.<span class=\"name\">visit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(findTranslation? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignore : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inApp : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/Option.html#OptionT\">OptionT</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Util/PtrSet.html#Lean.PtrSet\">Lean.PtrSet</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L486-L513","name":"ToAdditive.additiveTestUnsafe","line":486,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTestUnsafe","doc":"Implementation function for `additiveTest`.\nWe cache previous applications of the function, using an expression cache using ptr equality\nto avoid visiting the same subexpression many times. Note that we only need to cache the\nexpressions without taking the value of `inApp` into account, since `inApp` only matters when\nthe expression is a constant. However, for this reason we have to make sure that we never\ncache constant expressions, so that's why the `if`s in the implementation are in this order.\n\nNote that this function is still called many times by `applyReplacementFun`\nand we're not remembering the cache between these calls. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">unsafe def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTestUnsafe\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">additiveTestUnsafe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(findTranslation? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignore : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L475-L475","name":"ToAdditive.instReprConfig","line":475,"kind":"instance","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.instReprConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.instReprConfig\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">instReprConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L474-L474","name":"ToAdditive.Config.existing","line":474,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.existing","doc":"An optional flag stating whether the additive declaration already exists.\nIf this flag is set but wrong about whether the additive declaration exists, `to_additive` will\nraise a linter error.\nNote: the linter will never raise an error for inductive types and structures. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.existing\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">existing</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L469-L469","name":"ToAdditive.Config.ref","line":469,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.ref","doc":"The `Syntax` element corresponding to the original multiplicative declaration\n(or the `to_additive` attribute if it is added later),\nwhich we need for adding definition ranges. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.ref\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">ref</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L465-L465","name":"ToAdditive.Config.attrs","line":465,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.attrs","doc":"The attributes which we want to give to both the multiplicative and additive versions.\nFor `simps` this will also add generated lemmas to the translation dictionary. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.attrs\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">attrs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L462-L462","name":"ToAdditive.Config.reorder","line":462,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.reorder","doc":"The arguments that should be reordered by `to_additive`, using cycle notation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.reorder\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">reorder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L460-L460","name":"ToAdditive.Config.allowAutoName","line":460,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.allowAutoName","doc":"If `allowAutoName` is `false` (default) then\n`@[to_additive]` will check whether the given name can be auto-generated. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.allowAutoName\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">allowAutoName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L457-L457","name":"ToAdditive.Config.doc","line":457,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.doc","doc":"An optional doc string. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.doc\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">doc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L455-L455","name":"ToAdditive.Config.tgt","line":455,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.tgt","doc":"The name of the target (the additive declaration). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.tgt\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">tgt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L453-L453","name":"ToAdditive.Config.trace","line":453,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.trace","doc":"View the trace of the to_additive procedure.\nEquivalent to `set_option trace.to_additive true`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.trace\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">trace</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L450-L450","name":"ToAdditive.Config.mk","line":450,"kind":"ctor","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.mk\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(trace : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(doc : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#String\">String</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(allowAutoName : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(reorder : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attrs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(existing : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\">ToAdditive.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L450-L475","name":"ToAdditive.Config","line":450,"kind":"structure","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config","doc":"`Config` is the type of the arguments that can be provided to `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L439-L447","name":"ToAdditive.insertTranslation","line":439,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.insertTranslation","doc":"Add a (multiplicative → additive) name translation to the translations map. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.insertTranslation\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">insertTranslation</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(failIfExists : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L435-L436","name":"ToAdditive.findTranslation?","line":435,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findTranslation?","doc":"Get the multiplicative → additive translation for the given name. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findTranslation?\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">findTranslation?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(env : <a href=\"./Lean/Environment.html#Lean.Environment\">Lean.Environment</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L431-L432","name":"ToAdditive.translations","line":431,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.translations","doc":"Maps multiplicative names to their additive counterparts. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.translations\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">translations</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L406-L429","name":"ToAdditive.changeNumeralAttr","line":406,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.changeNumeralAttr","doc":"An attribute that stores all the declarations that deal with numeric literals on variable types.\n\nNumeral literals occur in expressions without type information, so in order to decide whether `1`\nneeds to be changed to `0`, the context around the numeral is relevant.\nMost numerals will be in an `OfNat.ofNat` application, though tactics can add numeral literals\ninside arbitrary functions. By default we assume that we do not change numerals, unless it is\nin a function application with the `to_additive_change_numeral` attribute.\n\n`@[to_additive_change_numeral n₁ ...]` should be added to all functions that take one or more\nnumerals as argument that should be changed if `additiveTest` succeeds on the first argument,\ni.e. when the numeral is only translated if the first argument is a variable\n(or consists of variables).\nThe arguments `n₁ ...` are the positions of the numeral arguments (starting counting from 1).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.changeNumeralAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">changeNumeralAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L377-L404","name":"ToAdditive.relevantArgAttr","line":377,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.relevantArgAttr","doc":"An attribute that is automatically added to declarations tagged with `@[to_additive]`, if needed.\n\nThis attribute tells which argument is the type where this declaration uses the multiplicative\nstructure. If there are multiple argument, we typically tag the first one.\nIf this argument contains a fixed type, this declaration will note be additivized.\nSee the Heuristics section of `to_additive.attr` for more details.\n\nIf a declaration is not tagged, it is presumed that the first argument is relevant.\n`@[to_additive]` uses the function `to_additive.first_multiplicative_arg` to automatically tag\ndeclarations. It is ok to update it manually if the automatic tagging made an error.\n\nImplementation note: we only allow exactly 1 relevant argument, even though some declarations\n(like `prod.group`) have multiple arguments with a multiplicative structure on it.\nThe reason is that whether we additivize a declaration is an all-or-nothing decision, and if\nwe will not be able to additivize declarations that (e.g.) talk about multiplication on `ℕ × α`\nanyway.\n\nWarning: interactions between this and the `(reorder := ...)` argument are not well-tested.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.relevantArgAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">relevantArgAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L355-L375","name":"ToAdditive.reorderAttr","line":355,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.reorderAttr","doc":"An attribute that stores all the declarations that needs their arguments reordered when\napplying `@[to_additive]`. It is applied automatically by the `(reorder := ...)` syntax of\n`to_additive`, and should not usually be added manually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.reorderAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">reorderAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L338-L353","name":"ToAdditive.ignoreArgsAttr","line":338,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ignoreArgsAttr","doc":"An attribute that tells `@[to_additive]` that certain arguments of this definition are not\ninvolved when using `@[to_additive]`.\nThis helps the heuristic of `@[to_additive]` by also transforming definitions if `ℕ` or another\nfixed type occurs as one of these arguments.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ignoreArgsAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">ignoreArgsAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L330-L335","name":"ToAdditive.linter.toAdditiveExisting","line":330,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.toAdditiveExisting","doc":"Linter to check whether the user correctly specified that the additive declaration already\nexists "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.toAdditiveExisting\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">linter</span>.<span class=\"name\">toAdditiveExisting</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L324-L328","name":"ToAdditive.linter.toAdditiveGenerateName","line":324,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.toAdditiveGenerateName","doc":"Linter to check that the `to_additive` attribute is not given manually "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.toAdditiveGenerateName\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">linter</span>.<span class=\"name\">toAdditiveGenerateName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L317-L322","name":"ToAdditive.linter.existingAttributeWarning","line":317,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.existingAttributeWarning","doc":"Linter, mostly used by `@[to_additive]`, that checks that the source declaration doesn't have\ncertain attributes "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.existingAttributeWarning\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">linter</span>.<span class=\"name\">existingAttributeWarning</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L312-L315","name":"ToAdditive.linter.toAdditiveReorder","line":312,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.toAdditiveReorder","doc":"Linter to check that the `reorder` attribute is not given manually "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.toAdditiveReorder\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">linter</span>.<span class=\"name\">toAdditiveReorder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L283-L305","name":"String.splitCase","line":283,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#String.splitCase","doc":"This function takes a String and splits it into separate parts based on the following\n(naming conventions)[https://github.com/leanprover-community/mathlib4/wiki#naming-convention].\n\nE.g. `#eval \"InvHMulLEConjugate₂SMul_ne_top\".splitCase` yields\n`[\"Inv\", \"HMul\", \"LE\", \"Conjugate₂\", \"SMul\", \"_\", \"ne\", \"_\", \"top\"]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#String.splitCase\"><span class=\"name\">String</span>.<span class=\"name\">splitCase</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i₀ : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#String.Pos\">String.Pos</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span>)</span> <span class=\"fn\">[]</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L271-L274","name":"endCapitalNames","line":271,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#endCapitalNames","doc":"A set of strings of names that end in a capital letter.\n* If the string contains a lowercase letter, the string should be split between the first occurrence\n  of a lower-case letter followed by an upper-case letter.\n* If multiple strings have the same prefix, they should be grouped by prefix\n* In this case, the second list should be prefix-free\n  (no element can be a prefix of a later element)\n\nTodo: automate the translation from `String` to an element in this `RBMap`\n  (but this would require having something similar to the `rb_lmap` from Lean 3). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#endCapitalNames\"><span class=\"name\">endCapitalNames</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/RBMap.html#Lean.RBMap\">Lean.RBMap</a> <a href=\"./Init/Prelude.html#String\">String</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span>)</span> <span class=\"fn\">compare</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L260-L260","name":"attrTo_additive?_","line":260,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#attrTo_additive?_","doc":"The `to_additive` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#attrTo_additive?_\"><span class=\"name\">attrTo_additive?_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L256-L257","name":"to_additive","line":256,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#to_additive","doc":"The `to_additive` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#to_additive\"><span class=\"name\">to_additive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L254-L255","name":"toAdditiveRest","line":254,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#toAdditiveRest","doc":"Remaining arguments of `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#toAdditiveRest\"><span class=\"name\">toAdditiveRest</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L252-L253","name":"toAdditiveOption","line":252,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#toAdditiveOption","doc":"Options to `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#toAdditiveOption\"><span class=\"name\">toAdditiveOption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L250-L251","name":"toAdditiveParenthesizedOption","line":250,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#toAdditiveParenthesizedOption","doc":"Options to `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#toAdditiveParenthesizedOption\"><span class=\"name\">toAdditiveParenthesizedOption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L248-L249","name":"toAdditiveReorderOption","line":248,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#toAdditiveReorderOption","doc":"A `reorder := ...` option for `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#toAdditiveReorderOption\"><span class=\"name\">toAdditiveReorderOption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L246-L247","name":"toAdditiveAttrOption","line":246,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#toAdditiveAttrOption","doc":"An `attr := ...` option for `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#toAdditiveAttrOption\"><span class=\"name\">toAdditiveAttrOption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L244-L245","name":"to_additive_change_numeral","line":244,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#to_additive_change_numeral","doc":"The `to_additive_change_numeral` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#to_additive_change_numeral\"><span class=\"name\">to_additive_change_numeral</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L242-L243","name":"to_additive_reorder","line":242,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#to_additive_reorder","doc":"The `to_additive_reorder` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#to_additive_reorder\"><span class=\"name\">to_additive_reorder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L240-L241","name":"to_additive_relevant_arg","line":240,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#to_additive_relevant_arg","doc":"The `to_additive_relevant_arg` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#to_additive_relevant_arg\"><span class=\"name\">to_additive_relevant_arg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/caac5b13fb72ba0c5d0b35a0067de108db65e964/Mathlib/Tactic/ToAdditive/Frontend.lean#L238-L239","name":"to_additive_ignore_args","line":238,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive/Frontend.html#to_additive_ignore_args","doc":"The `to_additive_ignore_args` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive/Frontend.html#to_additive_ignore_args\"><span class=\"name\">to_additive_ignore_args</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}