<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Parser.Term</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lean.Parser.Term";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Lean/Parser/Attr.html">Lean.Parser.Attr</a></li><li><a href="../.././Lean/Parser/Level.html">Lean.Parser.Level</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Parser.Term" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">parenthesizer</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody.formatter"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">formatter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.docComment"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">docComment</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.tacticParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">tacticParser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.convParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">convParser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sepByIndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepByIndentSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sepBy1IndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepBy1IndentSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeq1Indented"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq1Indented</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeqBracketed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqBracketed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeqIndentGt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqIndentGt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.seq1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">seq1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.darrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">darrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.semicolonOrLinebreak"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">semicolonOrLinebreak</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.terminationBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.terminationBy?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.decreasingBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">decreasingBy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.suffix"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">suffix</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.byTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.byTactic'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ident"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ident</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.num"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">num</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.scientific"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scientific</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.str"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">str</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.char"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">char</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.type"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">type</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sort"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sort</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">prop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.hole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">hole</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.syntheticHole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">syntheticHole</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.omission"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">omission</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sorry</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.cdot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">cdot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeAscription"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeAscription</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.tuple"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">tuple</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">paren</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.anonymousCtor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">anonymousCtor</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.fromTerm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fromTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.showRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showRhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sufficesDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sufficesDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.suffices"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">suffices</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.show"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">show</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstArrayRef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstArrayRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstLVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstLVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstField"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstField</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstFieldAbbrev"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldAbbrev</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optEllipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optEllipsis</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeSpec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeSpec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.inaccessible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">inaccessible</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderDefault"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderDefault.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span>.<span class="name">parenthesizer</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.implicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">implicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitLeftBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitLeftBracket</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitRightBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitRightBracket</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.bracketedBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.depArrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">depArrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forall"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forall</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAltExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchDiscr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchDiscr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.trueVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trueVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.falseVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">falseVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.generalizingParam"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">generalizingParam</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.motive"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">motive</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.match"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">match</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.nomatch"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nomatch</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.nofun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nofun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funStrictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funStrictImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.basicFun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">basicFun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optExprPrecedence"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optExprPrecedence</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.withAnonymousAntiquot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withAnonymousAntiquot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.leading_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leading_parser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.trailing_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trailing_parser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.borrowed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">borrowed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.quotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">quotedName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.doubleQuotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">doubleQuotedName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdLhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letPatDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letPatDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letEqnsDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_fun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_delayed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_delayed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_tmp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_tmp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdLhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveEqnsDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.have"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">have</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveI</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letI</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.scoped"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scoped</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.local"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">local</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attrKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attrInstance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attributes"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attributes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letRecDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letRecDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letrec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.whereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">whereDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAltsWhereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltsWhereDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noindex"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noindex</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.unsafe"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unsafe</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binrel"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binrel_no_prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel_no_prop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binop_lazy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop_lazy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.leftact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leftact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.rightact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">rightact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.unop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forInMacro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forInMacro'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.declName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">declName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.withDeclName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withDeclName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ensureTypeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureTypeOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ensureExpectedType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureExpectedType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noImplicitLambda"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noImplicitLambda</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">clear</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfTypeMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfTypeContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeContainsMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfContainsMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.defaultOrOfNonempty"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">defaultOrOfNonempty</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noErrorIfUnused"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noErrorIfUnused</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.namedArgument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedArgument</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ellipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ellipsis</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.argument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">argument</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.app"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">app</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.proj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">proj</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.completion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">completion</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.arrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">arrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.isIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">isIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicitUniv"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitUniv</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.namedPattern"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedPattern</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.pipeProj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeProj</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.pipeCompletion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeCompletion</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.bracketedBinderF"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinderF</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.panic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">panic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.unreachable"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unreachable</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dbgTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.assert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">assert</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroDollarArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroDollarArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroLastArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroLastArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.stateRefT"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">stateRefT</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dynamicQuot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dynamicQuot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dotIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dotIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.showTermElabImpl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showTermElabImpl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprElseAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprElseAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.quotSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quotSeq</span></a></div></nav><main>
<div class="decl" id="Lean.Parser.Command.commentBody"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L14-L15">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Command.commentBody" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.commentBody.parenthesizer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L18-L18">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">parenthesizer</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer">Lean.PrettyPrinter.Parenthesizer</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer">Lean.Parser.Command.commentBody.parenthesizer</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer.visitToken">Lean.PrettyPrinter.Parenthesizer.visitToken</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Command.commentBody.parenthesizer" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.commentBody.formatter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L20-L20">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">formatter</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter">Lean.PrettyPrinter.Formatter</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter">Lean.Parser.Command.commentBody.formatter</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter.visitAtom">Lean.PrettyPrinter.Formatter.visitAtom</a> <a href="../.././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Command.commentBody.formatter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.docComment"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L27-L28">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">docComment</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment">docComment</a></code> parses a "documentation comment" like <code>/-- foo -/</code>. This is not treated like
a regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.</p><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment">docComment</a></code> node contains a <code>/--</code> atom and then the remainder of the comment, <code>foo -/</code> in this
example. Use <code>TSyntax.getDocString</code> to extract the body text from a doc string syntax node.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Command.docComment" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.tacticParser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L35-L36">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.tacticParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">tacticParser</span></a></span><span class="decl_args">
<span class="fn">(rbp : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Nat">Nat</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.tacticParser">Lean.Parser.tacticParser</a> <span class="fn">rbp</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.categoryParser">Lean.Parser.categoryParser</a> <span class="fn">`tactic</span> <span class="fn">rbp</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.tacticParser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.convParser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L38-L39">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.convParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">convParser</span></a></span><span class="decl_args">
<span class="fn">(rbp : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Nat">Nat</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.convParser">Lean.Parser.convParser</a> <span class="fn">rbp</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.categoryParser">Lean.Parser.categoryParser</a> <span class="fn">`conv</span> <span class="fn">rbp</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.convParser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sepByIndentSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L53-L54">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepByIndentSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>sepByIndentSemicolon(p)</code> parses a sequence of <code>p</code> optionally followed by <code>;</code>,
similar to <code>manyIndent(p &quot;;&quot;?)</code>, except that if two occurrences of <code>p</code> occur on the same line,
the <code>;</code> is mandatory. This is used by tactic parsing, so that</p><pre><code>example := by
  skip
  skip
</code></pre><p>is legal, but <code>by skip skip</code> is not - it must be written as <code>by skip; skip</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon">Lean.Parser.Tactic.sepByIndentSemicolon</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.sepByIndent">Lean.Parser.sepByIndent</a> <span class="fn">p</span> <span class="fn">&quot;; &quot;</span> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;; &quot;</span></span>)</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.sepByIndentSemicolon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sepBy1IndentSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L66-L67">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepBy1IndentSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>sepBy1IndentSemicolon(p)</code> parses a (nonempty) sequence of <code>p</code> optionally followed by <code>;</code>,
similar to <code>many1Indent(p &quot;;&quot;?)</code>, except that if two occurrences of <code>p</code> occur on the same line,
the <code>;</code> is mandatory. This is used by tactic parsing, so that</p><pre><code>example := by
  skip
  skip
</code></pre><p>is legal, but <code>by skip skip</code> is not - it must be written as <code>by skip; skip</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon">Lean.Parser.Tactic.sepBy1IndentSemicolon</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent">Lean.Parser.sepBy1Indent</a> <span class="fn">p</span> <span class="fn">&quot;; &quot;</span> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;; &quot;</span></span>)</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.sepBy1IndentSemicolon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeq1Indented"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L73-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq1Indented</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeq1Indented" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeqBracketed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L77-L78">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqBracketed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The syntax <code>{ tacs }</code> is an alternative syntax for <code> tacs</code>.
It runs the tactics in sequence, and fails if the goal is not solved.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeqBracketed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L82-L83">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics.
Delimiter-free indentation is determined by the <em>first</em> tactic of the sequence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeqIndentGt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L88-L89">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqIndentGt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Same as [<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq">tacticSeq</a></code>] but requires delimiter-free tactic sequence to have strict indentation.
The strict indentation requirement only apply to <em>nested</em> <code>by</code>s, as top-level <code>by</code>s do not have a
position set.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeqIndentGt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.seq1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L92-L93">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.seq1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">seq1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.seq1">Lean.Parser.Tactic.seq1</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.node">Lean.Parser.node</a> <span class="fn">`Lean.Parser.Tactic.seq1</span>
    <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.sepBy1">Lean.Parser.sepBy1</a> <span class="fn">Lean.Parser.tacticParser</span> <span class="fn">&quot;;\n&quot;</span> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;;\n&quot;</span></span>)</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.seq1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.darrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L97-L97">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.darrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">darrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.darrow">Lean.Parser.darrow</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot; =&gt; &quot;</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.darrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.semicolonOrLinebreak"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L98-L98">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">semicolonOrLinebreak</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.semicolonOrLinebreak" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.terminationBy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L124-L127">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Specify a termination argument for well-founded termination:</p><pre><code>termination_by a - b
</code></pre><p>indicates that termination of the currently defined recursive function follows
because the difference between the the arguments <code>a</code> and <code>b</code>.</p><p>If the fuction takes further argument after the colon, you can name them as follows:</p><pre><code>def example (a : Nat) : <a href="../.././Init/Prelude.html#Nat">Nat</a>  <a href="../.././Init/Prelude.html#Nat">Nat</a>  <a href="../.././Init/Prelude.html#Nat">Nat</a> :=
termination_by b c =&gt; a - b
</code></pre><p>If omitted, a termination argument will be inferred. If written as <code>termination_by?</code>,
the inferrred termination argument will be suggested.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.terminationBy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.terminationBy?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L130-L131">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Specify a termination argument for well-founded termination:</p><pre><code>termination_by a - b
</code></pre><p>indicates that termination of the currently defined recursive function follows
because the difference between the the arguments <code>a</code> and <code>b</code>.</p><p>If the fuction takes further argument after the colon, you can name them as follows:</p><pre><code>def example (a : Nat) : <a href="../.././Init/Prelude.html#Nat">Nat</a>  <a href="../.././Init/Prelude.html#Nat">Nat</a>  <a href="../.././Init/Prelude.html#Nat">Nat</a> :=
termination_by b c =&gt; a - b
</code></pre><p>If omitted, a termination argument will be inferred. If written as <code>termination_by?</code>,
the inferrred termination argument will be suggested.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.terminationBy?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.decreasingBy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L139-L140">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.decreasingBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">decreasingBy</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Manually prove that the termination argument (as specified with <code>termination_by</code> or inferred)
decreases at each recursive call.</p><p>By default, the tactic <code>decreasing_tactic</code> is used.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.decreasingBy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.suffix"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L145-L146">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.suffix"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">suffix</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Termination hints are <code>termination_by</code> and <code>decreasing_by</code>, in that order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.suffix" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Built-in-parsers">Built-in parsers <a class="hover-link" href="#Built-in-parsers">#</a></h1></div><div class="decl" id="Lean.Parser.Term.byTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L155-L156">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.byTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>by tac</code> constructs a term of the expected type by running the tactic(s) <code>tac</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.byTactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.byTactic'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L164-L165">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.byTactic'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.byTactic'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L168-L169">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.optSemicolon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ident"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L172-L173">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ident</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident">Lean.Parser.Term.ident</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.ident">Lean.Parser.ident</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.ident" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.num"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L174-L175">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.num"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">num</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.num">Lean.Parser.Term.num</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.numLit">Lean.Parser.numLit</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.num" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.scientific"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L176-L177">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.scientific"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scientific</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.scientific">Lean.Parser.Term.scientific</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.scientificLit">Lean.Parser.scientificLit</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.scientific" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.str"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L178-L179">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.str"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">str</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.str">Lean.Parser.Term.str</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.strLit">Lean.Parser.strLit</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.str" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.char"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L180-L181">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.char"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">char</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.char">Lean.Parser.Term.char</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.charLit">Lean.Parser.charLit</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.char" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.type"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L183-L184">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.type"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">type</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A type universe. <code>Type  Type 0</code>, <code>Type u  Sort (u + 1)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.type" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sort"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L186-L187">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sort"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sort</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A specific universe in Lean's infinite hierarchy of universes.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.sort" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.prop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L189-L190">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">prop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The universe of propositions. <code>Prop  Sort 0</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.prop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.hole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L192-L193">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.hole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">hole</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A placeholder term, to be synthesized by unification.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.hole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.syntheticHole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L196-L197">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">syntheticHole</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Parses a "synthetic hole", that is, <code>?foo</code> or <code>?_</code>.
This syntax is used to construct named metavariables.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.syntheticHole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.omission"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L203-L204">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.omission"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">omission</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Denotes a term that was omitted by the pretty printer.
This is only meant to be used for pretty printing, however for copy/paste friendliness it elaborates like <code>_</code> while logging a warning.
The presence of <code></code> in pretty printer output is controlled by the <code>pp.deepTerms</code> and <code>pp.proofs</code> options.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.omission" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L205-L205">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderIdent">Lean.Parser.Term.binderIdent</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#HOrElse.hOrElse">HOrElse.hOrElse</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident">Lean.Parser.Term.ident</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.hole">Lean.Parser.Term.hole</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sorry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L207-L208">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sorry</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A temporary placeholder for a missing proof or value.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.sorry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.cdot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L213-L214">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.cdot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">cdot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.
For example, <code>( + )</code> is equivalent to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x y =&gt; x + y</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.cdot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeAscription"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L221-L222">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeAscription"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeAscription</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Type ascription notation: <code>(0 : Int)</code> instructs Lean to process <code>0</code> as a value of type <code><a href="../.././Init/Data/Int/Basic.html#Int">Int</a></code>.
An empty type ascription <code>(e :)</code> elaborates <code>e</code> without the expected type.
This is occasionally useful when Lean's heuristics for filling arguments from the expected type
do not yield the right result.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.typeAscription" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.tuple"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L224-L225">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.tuple"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">tuple</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Tuple notation; <code>()</code> is short for <code><a href="../.././Init/Prelude.html#Unit.unit">Unit.unit</a></code>, <code>(a, b, c)</code> for <code><a href="../.././Init/Prelude.html#Prod.mk">Prod.mk</a> a (Prod.mk b c)</code>, etc.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.tuple" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.paren"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L235-L236">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">paren</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Parentheses, used for grouping expressions (e.g., <code>a * (b + c)</code>).
Can also be used for creating simple functions when combined with <code></code>. Here are some examples:</p><ul>
<li><code>( + 1)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; x + 1</code></li>
<li><code>( + )</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x y =&gt; x + y</code></li>
<li><code>(f  a b)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; f x a b</code></li>
<li><code>(h ( + 1) )</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; h (fun y =&gt; y + 1) x</code></li>
<li>also applies to other parentheses-like notations such as <code>(, 1)</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.paren" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.anonymousCtor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L244-L245">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">anonymousCtor</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The <em>anonymous constructor</em> <code>e, ...</code> is equivalent to <code>c e ...</code> if the
expected type is an inductive type with a single constructor <code>c</code>.
If more terms are given than <code>c</code> has parameters, the remaining arguments
are turned into a new anonymous constructor application. For example,
<code>a, b, c :   (  )</code> is equivalent to <code>a, b, c</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.anonymousCtor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L246-L247">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optIdent">Lean.Parser.Term.optIdent</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.optional">Lean.Parser.optional</a>
    <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.atomic">Lean.Parser.atomic</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident">Lean.Parser.Term.ident</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot; : &quot;</span></span></span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.fromTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L248-L249">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fromTerm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fromTerm</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.fromTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.showRhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L250-L250">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.showRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showRhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.showRhs">Lean.Parser.Term.showRhs</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#HOrElse.hOrElse">HOrElse.hOrElse</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fromTerm">Lean.Parser.Term.fromTerm</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.byTactic'">Lean.Parser.Term.byTactic'</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.showRhs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sufficesDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L253-L254">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sufficesDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl">sufficesDecl</a></code> represents everything that comes after the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.suffices">suffices</a></code> keyword:
an optional <code>x :</code>, then a term <code>ty</code>, then <code>from val</code> or <code>by tac</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.sufficesDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.suffices"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L255-L256">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.suffices"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">suffices</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.suffices" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.show"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L257-L257">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.show"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">show</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.show" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstArrayRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L258-L259">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstArrayRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstArrayRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstLVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L260-L262">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstLVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstLVal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstField"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L263-L264">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstField"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstField</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstField" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstFieldAbbrev"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L265-L267">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldAbbrev</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstFieldAbbrev" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optEllipsis"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L268-L269">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optEllipsis</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.optEllipsis" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L279-L283">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInst</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Structure instance. <code>{ x := e, ... }</code> assigns <code>e</code> to field <code>x</code>, which may be
inherited. If <code>e</code> is itself a variable called <code>x</code>, it can be elided:
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> y =&gt; { x := 1, y }</code>.
A <em>structure update</em> of an existing value can be given via <code>with</code>:
<code>{ point with x := 1 }</code>.
The structure type can be specified if not inferable:
<code>{ x := 1, y := 2 : Point }</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeSpec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L284-L284">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeSpec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeSpec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.typeSpec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L285-L285">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optType">Lean.Parser.Term.optType</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.optional">Lean.Parser.optional</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeSpec">Lean.Parser.Term.typeSpec</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L290-L291">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>@x</code> disables automatic insertion of implicit parameters of the constant <code>x</code>.
<code>@e</code> for any term <code>e</code> also disables the insertion of implicit lambdas at this position.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.explicit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.inaccessible"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L296-L297">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.inaccessible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">inaccessible</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>.(e)</code> marks an "inaccessible pattern", which does not influence evaluation of the pattern match, but may be necessary for type-checking.
In contrast to regular patterns, <code>e</code> may be an arbitrary term of the appropriate type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.inaccessible" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L298-L299">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderType</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L300-L301">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderTactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderTactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderDefault"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L302-L303">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderDefault"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderDefault" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderDefault.parenthesizer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L306-L313">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span>.<span class="name">parenthesizer</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer">Lean.PrettyPrinter.Parenthesizer</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderDefault.parenthesizer" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L315-L316">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.explicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.implicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L321-L322">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">implicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Implicit binder. In regular applications without <code>@</code>, it is automatically inserted
and solved by unification whenever all explicit parameters before it are specified.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.implicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitLeftBracket"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L323-L323">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitLeftBracket</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitLeftBracket" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitRightBracket"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L324-L324">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitRightBracket</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitRightBracket" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L330-L332">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Strict-implicit binder. In contrast to <code>{ ... }</code> regular implicit binders,
a strict-implicit binder is inserted automatically only when at least one subsequent
explicit parameter is specified.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L337-L338">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Instance-implicit binder. In regular applications without <code>@</code>, it is automatically inserted
and solved by typeclass inference of the specified class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.instBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.bracketedBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L345-L348">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder">bracketedBinder</a></code> matches any kind of binder group that uses some kind of brackets:</p><ul>
<li>An explicit binder like <code>(x y : A)</code></li>
<li>An implicit binder like <code>{x y : A}</code></li>
<li>A strict implicit binder, <code>y z : A</code> or its ASCII alternative <code>{{y z : A}}</code></li>
<li>An instance binder <code>[A]</code> or <code>[x : A]</code> (multiple variables are not allowed here)</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.bracketedBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.depArrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L365-L366">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.depArrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">depArrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.depArrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forall"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L369-L372">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forall"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forall</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.forall" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L374-L379">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlt</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a> <span class="fn">Lean.Parser.termParser</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAltExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L383-L383">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Useful for syntax quotations. Note that generic patterns such as <code>`(matchAltExpr| | ... =&gt; $rhs)</code> should also
work with other <code>rhsParser</code>s (of arity 1).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr">Lean.Parser.Term.matchAltExpr</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Lean.Parser.Term.matchAlt</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAltExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L385-L386">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#Coe">Coe</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.matchAltExpr</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.matchAlt</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil">Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">stx</span> : <span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.matchAltExpr</span></span>) =&gt; <span class="fn">{ <span class="fn">raw</span> := <span class="fn"><span class="fn">stx</span>.raw</span> }</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L388-L389">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlts</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a> <span class="fn">Lean.Parser.termParser</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAlts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchDiscr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L393-L394">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchDiscr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr">matchDiscr</a></code> matches a "match discriminant", either <code>h : tm</code> or <code>tm</code>, used in <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> as
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> h1 : e1, e2, h3 : e3 with ...</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchDiscr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.trueVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L396-L396">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.trueVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trueVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.trueVal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.falseVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L397-L397">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.falseVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">falseVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.falseVal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.generalizingParam"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L398-L400">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">generalizingParam</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.generalizingParam" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.motive"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L402-L404">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.motive"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">motive</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.motive" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.match"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L439-L441">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">match</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Pattern matching. <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> e, ... with | p, ... =&gt; f | ...</code> matches each given
term <code>e</code> against each pattern <code>p</code> of a match alternative. When all patterns
of an alternative match, the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> term evaluates to the value of the
corresponding right-hand side <code>f</code> with the pattern variables bound to the
respective matched values.
If used as <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> h : e, ... with | p, ... =&gt; f | ...</code>, <code>h : e = p</code> is available
within <code>f</code>.</p><p>When not constructing a proof, <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> does not automatically substitute variables
matched on in dependent variables' types. Use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> (generalizing := true) ...</code> to
enforce this.</p><p>Syntax quotations can also be used in a pattern match.
This matches a <code>Syntax</code> value against quotations, pattern variables, or <code>_</code>.</p><p>Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.</p><p><code>Syntax.atom</code>s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in</p><pre><code class="language-lean">syntax &quot;c&quot; (&quot;foo&quot; &lt;|&gt; &quot;bar&quot;) ...
</code></pre><p><code>foo</code> and <code>bar</code> are indistinguishable during matching, but in</p><pre><code class="language-lean">syntax foo := &quot;foo&quot;
syntax &quot;c&quot; (foo &lt;|&gt; &quot;bar&quot;) ...
</code></pre><p>they are not.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.match" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.nomatch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L447-L447">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.nomatch"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nomatch</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Empty match/ex falso. <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.nomatch">nomatch</a> e</code> is of arbitrary type <code> : Sort u</code> if
Lean can show that an empty set of patterns is exhaustive given <code>e</code>'s type,
e.g. because it has no constructors.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.nomatch" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.nofun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L449-L449">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.nofun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nofun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.nofun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L451-L452">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funImplicitBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.funImplicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funStrictImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L453-L457">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funStrictImplicitBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.funStrictImplicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L458-L460">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.funBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.basicFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L463-L464">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.basicFun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">basicFun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.basicFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.fun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L465-L466">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.fun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optExprPrecedence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L468-L468">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optExprPrecedence</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.optExprPrecedence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.withAnonymousAntiquot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L469-L471">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withAnonymousAntiquot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.withAnonymousAntiquot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.leading_parser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L472-L473">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.leading_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leading_parser</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.leading_parser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.trailing_parser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L474-L475">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trailing_parser</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.trailing_parser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.borrowed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L477-L478">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.borrowed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">borrowed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.borrowed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.quotedName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L480-L480">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.quotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">quotedName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A literal of type <code>Name</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.quotedName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.doubleQuotedName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L487-L488">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">doubleQuotedName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A resolved name literal. Evaluates to the full name of the given constant if
existent in the current context, or else fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.doubleQuotedName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L490-L492">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letIdBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdLhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L494-L497">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdLhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letIdLhs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L498-L499">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letIdDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letPatDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L500-L501">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letPatDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letPatDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letEqnsDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L518-L519">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letEqnsDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letEqnsDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L524-L528">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letDecl">letDecl</a></code> matches the body of a let declaration <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> f x1 x2 := e</code>,
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> pat := e</code> (where <code>pat</code> is an arbitrary term) or <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> f | pat1 =&gt; e1 | pat2 =&gt; e2 ...</code>
(a pattern matching declaration), except for the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> keyword itself.
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> rec</code> declarations are not handled here.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L550-L551">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> is used to declare a local definition. Example:</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := 1
<a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> y := x + 1
x + y
</code></pre><p>Since functions are first class citizens in Lean, you can use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> to declare
local functions too.</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> double := <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; 2*x
double (double 3)
</code></pre><p>For recursive definitions, you should use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> rec</code>.
You can also perform pattern matching using <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code>. For example,
assume <code>p</code> has type <code><a href="../.././Init/Prelude.html#Nat">Nat</a>  <a href="../.././Init/Prelude.html#Nat">Nat</a></code>, then you can write</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> (x, y) := p
x + y
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_fun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L557-L558">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_fun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a> x := v; b</code> is syntax sugar for <code>(fun x =&gt; b) v</code>.
It is very similar to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := v; b</code>, but they are not equivalent.
In <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a></code>, the value <code>v</code> has been abstracted away and cannot be accessed in <code>b</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let_fun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_delayed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L562-L563">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_delayed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_delayed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_delayed">let_delayed</a> x := v; b</code> is similar to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := v; b</code>, but <code>b</code> is elaborated before <code>v</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let_delayed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_tmp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L568-L569">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_tmp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_tmp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code>-declaration that is only included in the elaborated term if variable is still there.
It is often used when building macros.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let_tmp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveIdLhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L572-L572">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdLhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveIdLhs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveIdDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L573-L574">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveIdDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveEqnsDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L575-L576">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveEqnsDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveEqnsDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L580-L581">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveDecl">haveDecl</a></code> matches the body of a have declaration: <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> := e</code>, <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> f x1 x2 := e</code>,
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> pat := e</code> (where <code>pat</code> is an arbitrary term) or <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> f | pat1 =&gt; e1 | pat2 =&gt; e2 ...</code>
(a pattern matching declaration), except for the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a></code> keyword itself.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.have"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L582-L583">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">have</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.have" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L585-L586">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveI</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveI">haveI</a></code> behaves like <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a></code>, but inlines the value instead of producing a <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a></code> term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveI" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L588-L589">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letI</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letI">letI</a></code> behaves like <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code>, but inlines the value instead of producing a <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a></code> term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letI" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.scoped"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L591-L591">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.scoped"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scoped</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.scoped" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.local"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L592-L592">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.local"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">local</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.local" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attrKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L594-L594">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrKind">attrKind</a></code> matches <code>(&quot;scoped&quot; &lt;|&gt; &quot;local&quot;)?</code>, used before an attribute like <code>@[local simp]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.attrKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attrInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L595-L595">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrInstance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.attrInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attributes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L597-L598">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attributes"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attributes</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.attributes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letRecDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L601-L602">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl">letRecDecl</a></code> matches the body of a let-rec declaration: a doc comment, attributes, and then
a let declaration without the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> keyword, such as <code>/-- foo -/ @[simp] bar := 1</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letRecDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letRecDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L604-L605">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls">letRecDecls</a></code> matches <code>letRecDecl,+</code>, a comma-separated list of let-rec declarations (see <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl">letRecDecl</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letRecDecls" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letrec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L607-L609">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letrec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letrec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.whereDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L612-L613">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.whereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">whereDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.whereDecls" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAltsWhereDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L616-L617">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltsWhereDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAltsWhereDecls" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noindex"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L619-L620">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noindex"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noindex</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.noindex" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.unsafe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L633-L633">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unsafe</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe">unsafe</a> t : </code> is an expression constructor which allows using unsafe declarations inside the
body of <code>t : </code>, by creating an auxiliary definition containing <code>t</code> and using <code>implementedBy</code> to
wrap it in a safe interface. It is required that <code></code> is nonempty for this to be sound,
but even beyond that, an <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe">unsafe</a></code> block should be carefully inspected for memory safety because
the compiler is unable to guarantee the safety of the operation.</p><p>For example, the <code>evalExpr</code> function is unsafe, because the compiler cannot guarantee that when
you call <code>evalExpr Foo ``Foo e</code> that the type <code>Foo</code> corresponds to the name <code>Foo</code>, but in a
particular use case, we can ensure this, so <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe">unsafe</a> (evalExpr Foo ``Foo e)</code> is a correct usage.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.unsafe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binrel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L636-L637">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binrel"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binrel% r a b</code> elaborates <code>r a b</code> as a binary relation using the type propogation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binrel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binrel_no_prop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L639-L640">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel_no_prop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binrel_no_prop% r a b</code> is similar to <code>binrel% r a b</code>, but it coerces <code>Prop</code> arguments into <code><a href="../.././Init/Prelude.html#Bool">Bool</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binrel_no_prop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L642-L643">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binop% f a b</code> elaborates <code>f a b</code> as a binary operation using the type propogation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binop_lazy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L645-L646">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop_lazy</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binop_lazy%</code> is similar to <code>binop% f a b</code>, but it wraps <code>b</code> as a function from <code><a href="../.././Init/Prelude.html#Unit">Unit</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binop_lazy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.leftact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L649-L650">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.leftact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leftact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>leftact% f a b</code> elaborates <code>f a b</code> as a left action using the type propogation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.
In particular, it is like a unary operation with a fixed parameter <code>a</code>, where only the right argument <code>b</code> participates in the operator coercion elaborator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.leftact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.rightact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L653-L654">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.rightact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">rightact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>rightact% f a b</code> elaborates <code>f a b</code> as a right action using the type propogation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.
In particular, it is like a unary operation with a fixed parameter <code>b</code>, where only the left argument <code>a</code> participates in the operator coercion elaborator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.rightact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.unop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L656-L657">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>unop% f a</code> elaborates <code>f a</code> as a unary operation using the type propogation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.unop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forInMacro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L659-L660">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forInMacro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.forInMacro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forInMacro'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L661-L662">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.forInMacro'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.declName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L665-L665">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.declName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">declName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A macro which evaluates to the name of the currently elaborating declaration.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.declName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.withDeclName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L673-L674">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.withDeclName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withDeclName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><ul>
<li><code>with_decl_name% <a href="../.././Init/Prelude.html#id">id</a> e</code> elaborates <code>e</code> in a context while changing the effective
declaration name to <code><a href="../.././Init/Prelude.html#id">id</a></code>.</li>
<li><code>with_decl_name% ?id e</code> does the same, but resolves <code><a href="../.././Init/Prelude.html#id">id</a></code> as a new definition name
(appending the current namespaces).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.withDeclName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L675-L676">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeOf</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.typeOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ensureTypeOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L677-L678">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureTypeOf</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.ensureTypeOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ensureExpectedType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L679-L680">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureExpectedType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.ensureExpectedType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noImplicitLambda"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L681-L682">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noImplicitLambda</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.noImplicitLambda" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.clear"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L688-L689">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">clear</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>clear% x; e</code> elaborates <code>x</code> after clearing the free variable <code>x</code> from the local context.
If <code>x</code> cannot be cleared (due to dependencies), it will keep <code>x</code> without failing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.clear" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L691-L692">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfTypeMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L693-L694">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.waitIfTypeMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfTypeContainsMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L695-L696">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeContainsMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.waitIfTypeContainsMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfContainsMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L697-L698">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfContainsMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.waitIfContainsMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.defaultOrOfNonempty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L700-L701">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">defaultOrOfNonempty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.defaultOrOfNonempty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noErrorIfUnused"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L707-L708">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noErrorIfUnused</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Helper parser for marking <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code>-alternatives that should not trigger errors if unused.
We use them to implement <code>macro_rules</code> and <code>elab_rules</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.noErrorIfUnused" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.namedArgument"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L710-L711">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.namedArgument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedArgument</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.namedArgument" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ellipsis"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L712-L713">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ellipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ellipsis</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.ellipsis" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.argument"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L714-L717">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.argument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">argument</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.argument" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.app"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L721-L721">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.app"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">app</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.app">Lean.Parser.Term.app</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.trailingNode">Lean.Parser.trailingNode</a> <span class="fn">`Lean.Parser.Term.app</span> <a href="../.././Lean/Parser/Types.html#Lean.Parser.leadPrec">Lean.Parser.leadPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a>
    <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.many1">Lean.Parser.many1</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.argument">Lean.Parser.Term.argument</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.app" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.proj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L735-L736">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.proj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">proj</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p>The <em>extended field notation</em> <code>e.f</code> is roughly short for <code>T.f e</code> where <code>T</code> is the type of <code>e</code>.
More precisely,</p><ul>
<li>if <code>e</code> is of a function type, <code>e.f</code> is translated to <code>Function.f (p := e)</code>
where <code>p</code> is the first explicit parameter of function type</li>
<li>if <code>e</code> is of a named type <code>T ...</code> and there is a declaration <code>T.f</code> (possibly from <code>export</code>),
<code>e.f</code> is translated to <code>T.f (p := e)</code> where <code>p</code> is the first explicit parameter of type <code>T ...</code></li>
<li>otherwise, if <code>e</code> is of a structure type,
the above is repeated for every base type of the structure.</li>
</ul><p>The field index notation <code>e.i</code>, where <code>i</code> is a positive number,
is short for accessing the <code>i</code>-th field (1-indexed) of <code>e</code> if it is of a structure type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.proj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.completion"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L737-L738">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.completion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">completion</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.completion">Lean.Parser.Term.completion</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.trailingNode">Lean.Parser.trailingNode</a> <span class="fn">`Lean.Parser.Term.completion</span> <span class="fn">1024</span> <span class="fn">0</span>
    <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">Lean.Parser.checkNoWsBefore</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;.&quot;</span></span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.completion" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.arrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L739-L740">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.arrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">arrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.arrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.isIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L742-L744">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.isIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">isIdent</span></a></span><span class="decl_args">
<span class="fn">(stx : <a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.isIdent">Lean.Parser.Term.isIdent</a> <span class="fn">stx</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Lean/Syntax.html#Lean.Syntax.isAntiquot">Lean.Syntax.isAntiquot</a> <span class="fn">stx</span></span> <a href="../.././Init/Prelude.html#or">||</a> <span class="fn"><a href="../.././Init/Prelude.html#Lean.Syntax.isIdent">Lean.Syntax.isIdent</a> <span class="fn">stx</span></span></span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.isIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicitUniv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L747-L750">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitUniv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>x.{u, ...}</code> explicitly specifies the universes <code>u, ...</code> of the constant <code>x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.explicitUniv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.namedPattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L753-L756">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.namedPattern"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedPattern</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>x@e</code> or <code>x:h@e</code> matches the pattern <code>e</code> and binds its value to the identifier <code>x</code>.
If present, the identifier <code>h</code> is bound to a proof of <code>x = e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.namedPattern" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.pipeProj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L762-L763">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.pipeProj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeProj</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>e |&gt;.x</code> is a shorthand for <code>(e).x</code>.
It is especially useful for avoiding parentheses with repeated applications.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.pipeProj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.pipeCompletion"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L764-L765">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeCompletion</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion">Lean.Parser.Term.pipeCompletion</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.trailingNode">Lean.Parser.trailingNode</a> <span class="fn">`Lean.Parser.Term.pipeCompletion</span> <a href="../.././Lean/Parser/Types.html#Lean.Parser.minPrec">Lean.Parser.minPrec</a> <span class="fn">0</span> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot; |&gt;.&quot;</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.pipeCompletion" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.subst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L775-L776">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">subst</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>h  e</code> is a macro built on top of <code><a href="../.././Init/Prelude.html#Eq.rec">Eq.rec</a></code> and <code><a href="../.././Init/Prelude.html#Eq.symm">Eq.symm</a></code> definitions.
Given <code>h : a = b</code> and <code>e : p a</code>, the term <code>h  e</code> has type <code>p b</code>.
You can also view <code>h  e</code> as a "type casting" operation
where you change the type of <code>e</code> by using <code>h</code>.
See the Chapter "Quantifiers and Equality" in the manual
"Theorem Proving in Lean" for additional information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.subst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.bracketedBinderF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L778-L778">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinderF</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF">Lean.Parser.Term.bracketedBinderF</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Lean.Parser.Term.bracketedBinder</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.bracketedBinderF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L779-L779">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#Coe">Coe</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.bracketedBinderF</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.bracketedBinder</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1">Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.bracketedBinderF</span></span>) =&gt; <span class="fn">{ <span class="fn">raw</span> := <span class="fn"><span class="fn">s</span>.raw</span> }</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Term.panic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L789-L790">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.panic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">panic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>panic! msg</code> formally evaluates to <code>@Inhabited.default </code> if the expected type
<code></code> implements <code><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a></code>.
At runtime, <code>msg</code> and the file position are printed to stderr unless the C
function <code>lean_set_panic_messages(false)</code> has been executed before. If the C
function <code>lean_set_exit_on_panic(true)</code> has been executed before, the process is
then aborted.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.panic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.unreachable"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L792-L793">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unreachable"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unreachable</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A shorthand for <code>panic! &quot;unreachable code has been reached&quot;</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.unreachable" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dbgTrace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L798-L800">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dbgTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>dbg_trace e; body</code> evaluates to <code>body</code> and prints <code>e</code> (which can be an
interpolated string literal) to stderr. It should only be used for debugging.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.dbgTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.assert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L802-L803">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.assert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">assert</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>assert! <a href="../.././Init/Prelude.html#cond">cond</a></code> panics if <code><a href="../.././Init/Prelude.html#cond">cond</a></code> evaluates to <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.assert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L805-L805">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroArg">Lean.Parser.Term.macroArg</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.termParser">Lean.Parser.termParser</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.macroArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroDollarArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L806-L806">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroDollarArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.macroDollarArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroLastArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L807-L807">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroLastArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg">Lean.Parser.Term.macroLastArg</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HOrElse.hOrElse">HOrElse.hOrElse</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg">Lean.Parser.Term.macroDollarArg</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroArg">Lean.Parser.Term.macroArg</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.macroLastArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.stateRefT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L810-L811">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.stateRefT"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">stateRefT</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.stateRefT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dynamicQuot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L813-L814">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dynamicQuot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.dynamicQuot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dotIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L816-L817">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dotIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dotIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.dotIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.showTermElabImpl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L822-L823">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.showTermElabImpl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showTermElabImpl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Implementation of the <code>show_term</code> term elaborator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.showTermElabImpl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p><code>match_expr</code> support.</p></div><div class="decl" id="Lean.Parser.Term.matchExprPat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L829-L829">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExprAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L830-L830">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlt</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExprElseAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L831-L831">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprElseAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprElseAlt</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprElseAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExprAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L832-L835">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlts</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprAlts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L836-L837">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L839-L840">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L844-L845">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.quotSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Term.lean#L846-L847">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quotSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.quotSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>