<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="stylesheet" href="../../.././src/pygments.css"></link><link rel="shortcut icon" href="../../.././favicon.ico"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Bicategory.Functor</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Bicategory.Functor";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Bicategory</span>.<span class="name">Functor</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html">Mathlib.CategoryTheory.Bicategory.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Bicategory.Functor" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.PrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.PrelaxFunctor.hasCoeToPrefunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">hasCoeToPrefunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.PrelaxFunctor.id_map₂"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">id_map₂</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.PrelaxFunctor.id_toPrefunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">id_toPrefunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.PrelaxFunctor.id"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.PrelaxFunctor.instInhabitedPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">instInhabitedPrelaxFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.PrelaxFunctor.comp_toPrefunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">comp_toPrefunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.PrelaxFunctor.comp_map₂"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">comp_map₂</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.PrelaxFunctor.comp"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.map₂_associator_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">map₂_associator_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.mapComp_naturality_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">mapComp_naturality_left_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.mapComp_naturality_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">mapComp_naturality_right_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.map₂_rightUnitor_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">map₂_rightUnitor_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.map₂_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">map₂_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.map₂_leftUnitor_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">map₂_leftUnitor_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.hasCoeToPrelax"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">hasCoeToPrelax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">mapFunctor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">mapFunctor_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">mapFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.id_mapId"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">id_mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.id_mapComp"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">id_mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.id_toPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">id_toPrelaxFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.id"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.instInhabitedOplaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">instInhabitedOplaxFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.comp"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OplaxFunctor.PseudoCore"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">PseudoCore</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.map₂_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.map₂_associator_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_associator_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.map₂_right_unitor_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_right_unitor_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.map₂_whisker_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_whisker_right_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.map₂_left_unitor_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_left_unitor_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.map₂_whisker_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_whisker_left_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">hasCoeToPrelaxFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.toOplax"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">toOplax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.hasCoeToOplax"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">hasCoeToOplax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.to_oplax_obj"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">to_oplax_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.to_oplax_mapId"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">to_oplax_mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.to_oplax_mapComp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">to_oplax_mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mapFunctor_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mapFunctor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mapFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.id_toPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">id_toPrelaxFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.id_mapId"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">id_mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.id_mapComp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">id_mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.id"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.instInhabitedPseudofunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">instInhabitedPseudofunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.comp_mapComp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">comp_mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.comp_mapId"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">comp_mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.comp_toPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">comp_toPrelaxFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.comp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.mkOfOplax_mapId"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax_mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.mkOfOplax_mapComp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax_mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.mkOfOplax_toPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax_toPrelaxFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.mkOfOplax"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.mkOfOplax'_toPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax'_toPrelaxFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.mkOfOplax'_mapId"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax'_mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.mkOfOplax'_mapComp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax'_mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Pseudofunctor.mkOfOplax'"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax'</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Oplax-functors-and-pseudofunctors">Oplax functors and pseudofunctors <a class="hover-link" href="#Oplax-functors-and-pseudofunctors">#</a></h1><p>An oplax functor <code>F</code> between bicategories <code>B</code> and <code>C</code> consists of</p><ul>
<li>a function between objects <code>F.obj : B ⟶ C</code>,</li>
<li>a family of functions between 1-morphisms <code>F.map : (a ⟶ b) → (F.obj a ⟶ F.obj b)</code>,</li>
<li>a family of functions between 2-morphisms <code>F.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.map₂">map₂</a> : (f ⟶ g) → (F.map f ⟶ F.map g)</code>,</li>
<li>a family of 2-morphisms <code>F.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapId">mapId</a> a : F.map (𝟙 a) ⟶ 𝟙 (F.obj a)</code>,</li>
<li>a family of 2-morphisms <code>F.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapComp">mapComp</a> f g : F.map (f ≫ g) ⟶ F.map f ≫ F.map g</code>, and</li>
<li>certain consistency conditions on them.</li>
</ul><p>A pseudofunctor is an oplax functor whose <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapId">mapId</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapComp">mapComp</a></code> are isomorphisms. We provide
several constructors for pseudofunctors:</p><ul>
<li><code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mk">Pseudofunctor.mk</a></code> : the default constructor, which requires <code>map₂_whiskerLeft</code> and
<code>map₂_whiskerRight</code> instead of naturality of <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapComp">mapComp</a></code>.</li>
<li><code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax">Pseudofunctor.mkOfOplax</a></code> : construct a pseudofunctor from an oplax functor whose
<code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapId">mapId</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapComp">mapComp</a></code> are isomorphisms. This constructor uses <code>Iso</code> to describe isomorphisms.</li>
<li><code>pseudofunctor.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax'">mkOfOplax'</a></code> : similar to <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax">mkOfOplax</a></code>, but uses <code>IsIso</code> to describe
isomorphisms.</li>
</ul><p>The additional constructors are useful when constructing a pseudofunctor where the construction
of the oplax functor associated with it is already done. For example, the composition of
pseudofunctors can be defined by using the composition of oplax functors as follows:</p><pre><code class="language-lean">def <a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.comp">comp</a> (F : <a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">Pseudofunctor</a> B C) (G : <a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">Pseudofunctor</a> C D) : <a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">Pseudofunctor</a> B D :=
  <a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax">mkOfOplax</a> ((F : <a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">OplaxFunctor</a> B C).<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.comp">comp</a> G)
  { <a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.PseudoCore.mapIdIso">mapIdIso</a> := fun a ↦ (G.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapFunctor">mapFunctor</a> _ _).mapIso (F.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapId">mapId</a> a) ≪≫ G.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapId">mapId</a> (F.obj a),
    <a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.PseudoCore.mapCompIso">mapCompIso</a> := fun f g ↦
      (G.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapFunctor">mapFunctor</a> _ _).mapIso (F.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapComp">mapComp</a> f g) ≪≫ G.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapComp">mapComp</a> (F.map f) (F.map g) }
</code></pre><p>although the composition of pseudofunctors in this file is defined by using the default constructor
because <code>obviously</code> wasn't smart enough in mathlib3 and the porter of this file was too lazy
to investigate this issue further in mathlib4. Similarly, the composition is also defined by using
<code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax'">mkOfOplax'</a></code> after giving appropriate instances for <code>IsIso</code>. The former constructor
<code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax">mkOfOplax</a></code> requires isomorphisms as data type <code>Iso</code>, and so it is useful if you don't want
to forget the definitions of the inverses. On the other hand, the latter constructor
<code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax'">mkOfOplax'</a></code> is useful if you want to use propositional type class <code>IsIso</code>.</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> B C</code> : an oplax functor between bicategories <code>B</code> and <code>C</code></li>
<li><code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.comp">CategoryTheory.OplaxFunctor.comp</a> F G</code> : the composition of oplax functors</li>
<li><code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> B C</code> : a pseudofunctor between bicategories <code>B</code> and <code>C</code></li>
<li><code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.comp">CategoryTheory.Pseudofunctor.comp</a> F G</code> : the composition of pseudofunctors</li>
</ul><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><p>There are two types of functors between bicategories, called lax and oplax functors, depending on
the directions of <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapId">mapId</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapComp">mapComp</a></code>. We may need both in mathlib in the future, but for
now we only define oplax functors.</p></div><div class="decl" id="CategoryTheory.PrelaxFunctor"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L80-L84">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">B</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">C</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Prefunctor"><span class="name">Prefunctor</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max (max (max (max (max u₁ u₂) v₁) v₂) w₁) w₂)</div></div><p>A prelax functor between bicategories consists of functions between objects,
1-morphisms, and 2-morphisms. This structure will be extended to define <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">OplaxFunctor</a></code>.</p><ul class="structure_fields" id="CategoryTheory.PrelaxFunctor.mk"><li id="CategoryTheory.PrelaxFunctor.obj" class="structure_field"><div class="structure_field_info">obj : <span class="fn"><span class="fn">B</span> → <span class="fn">C</span></span></div></li><li id="CategoryTheory.PrelaxFunctor.map" class="structure_field"><div class="structure_field_info">map : <span class="fn">{<span class="fn">X </span>Y : <span class="fn">B</span>} → <span class="fn"><span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">Y</span></span></span>)</span></span></span></div></li><li id="CategoryTheory.PrelaxFunctor.map₂" class="structure_field"><div class="structure_field_info">map₂ : <span class="fn">{<span class="fn">a </span>b : <span class="fn">B</span>} → <span class="fn">{<span class="fn">f </span>g : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} → <span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span></span>)</span></span></span></span></div><div class="structure_field_doc"><p>The action of a prelax functor on 2-morphisms.</p></div></li></ul><details id="instances-for-list-CategoryTheory.PrelaxFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.PrelaxFunctor.hasCoeToPrefunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L96-L97">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.hasCoeToPrefunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">hasCoeToPrefunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">B</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">C</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Coe.html#Coe">Coe</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">B</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Prefunctor">⥤q</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.PrelaxFunctor.hasCoeToPrefunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">coe</span> := <span class="fn">CategoryTheory.PrelaxFunctor.toPrefunctor</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.PrelaxFunctor.id_map₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L110-L110">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.id_map₂"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">id_map₂</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">B</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">B</span>} {<span class="fn">f </span>g : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.id">CategoryTheory.PrelaxFunctor.id</a> <span class="fn">B</span></span>)</span>.map₂</span> <span class="fn">η</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">η</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.PrelaxFunctor.id_toPrefunctor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L110-L110">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.id_toPrefunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">id_toPrefunctor</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">B</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.id">CategoryTheory.PrelaxFunctor.id</a> <span class="fn">B</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Prefunctor.id">𝟭q</a> <span class="fn">B</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.PrelaxFunctor.id"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L111-L112">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.id"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">id</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">B</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">B</span> <span class="fn">B</span></span></div></div><p>The identity prelax functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.id">CategoryTheory.PrelaxFunctor.id</a> <span class="fn">B</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">let __src := <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Prefunctor.id">𝟭q</a> <span class="fn">B</span></span>;
  <span class="fn">{ <span class="fn">toPrefunctor</span> := <span class="fn">__src</span>, <span class="fn">map₂</span> := <span class="fn">fun {<span class="fn">a </span>b : <span class="fn">B</span>} {<span class="fn">f </span>g : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>) =&gt; <span class="fn">η</span></span> }</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.PrelaxFunctor.id" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.PrelaxFunctor.instInhabitedPrelaxFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L115-L116">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.instInhabitedPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">instInhabitedPrelaxFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">B</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">B</span> <span class="fn">B</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.PrelaxFunctor.instInhabitedPrelaxFunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.id">CategoryTheory.PrelaxFunctor.id</a> <span class="fn">B</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.PrelaxFunctor.comp_toPrefunctor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L120-L120">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.comp_toPrefunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">comp_toPrefunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">B</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">C</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">D</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.comp">CategoryTheory.PrelaxFunctor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">↑<span class="fn">F</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Prefunctor.comp">⋙q</a> <span class="fn">↑<span class="fn">G</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.PrelaxFunctor.comp_map₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L120-L120">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.comp_map₂"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">comp_map₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">B</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">C</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">D</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">B</span>} {<span class="fn">f </span>g : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.comp">CategoryTheory.PrelaxFunctor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.map₂</span> <span class="fn">η</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">G</span>.map₂</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map₂</span> <span class="fn">η</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.PrelaxFunctor.comp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L121-L122">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.comp"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">B</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">C</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span>b : <span class="fn">D</span>) → <span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">B</span> <span class="fn">D</span></span></div></div><p>Composition of prelax functors.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.comp">CategoryTheory.PrelaxFunctor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">let __src := <span class="fn"><span class="fn">↑<span class="fn">F</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Prefunctor.comp">⋙q</a> <span class="fn">↑<span class="fn">G</span></span></span>;
  <span class="fn">{ <span class="fn">toPrefunctor</span> := <span class="fn">__src</span>, <span class="fn">map₂</span> := <span class="fn">fun {<span class="fn">a </span>b : <span class="fn">B</span>} {<span class="fn">f </span>g : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">G</span>.map₂</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map₂</span> <span class="fn">η</span></span>)</span></span></span> }</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.PrelaxFunctor.comp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OplaxFunctor"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L158-L189">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max (max (max (max (max u₁ u₂) v₁) v₂) w₁) w₂)</div></div><p>An oplax functor <code>F</code> between bicategories <code>B</code> and <code>C</code> consists of a function between objects
<code>F.obj</code>, a function between 1-morphisms <code>F.map</code>, and a function between 2-morphisms <code>F.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.map₂">map₂</a></code>.</p><p>Unlike functors between categories, <code>F.map</code> do not need to strictly commute with the composition,
and do not need to strictly preserve the identity. Instead, there are specified 2-morphisms
<code>F.map (𝟙 a) ⟶ 𝟙 (F.obj a)</code> and <code>F.map (f ≫ g) ⟶ F.map f ≫ F.map g</code>.</p><p><code>F.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.map₂">map₂</a></code> strictly commute with compositions and preserve the identity. They also preserve the
associator, the left unitor, and the right unitor modulo some adjustments of domains and codomains
of 2-morphisms.</p><ul class="structure_fields" id="CategoryTheory.OplaxFunctor.mk"><li id="CategoryTheory.OplaxFunctor.obj" class="structure_field"><div class="structure_field_info">obj : <span class="fn"><span class="fn">B</span> → <span class="fn">C</span></span></div></li><li id="CategoryTheory.OplaxFunctor.map" class="structure_field"><div class="structure_field_info">map : <span class="fn">{<span class="fn">X </span>Y : <span class="fn">B</span>} → <span class="fn"><span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">Y</span></span></span>)</span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.map₂" class="structure_field"><div class="structure_field_info">map₂ : <span class="fn">{<span class="fn">a </span>b : <span class="fn">B</span>} → <span class="fn">{<span class="fn">f </span>g : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} → <span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span></span>)</span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.mapId" class="structure_field"><div class="structure_field_info">mapId : <span class="fn">(<span class="fn">a</span> : <span class="fn">B</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">a</span></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.mapComp" class="structure_field"><div class="structure_field_info">mapComp : <span class="fn">{<span class="fn">a </span>b c : <span class="fn">B</span>} →
  <span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) →
    <span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>) →
      <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span>)</span></span></span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.mapComp_naturality_left" class="structure_field"><div class="structure_field_info">mapComp_naturality_left : <span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} {<span class="fn">f </span>f' : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">f'</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>),
  <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">η</span> <span class="fn">g</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f'</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span>)</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.mapComp_naturality_right" class="structure_field"><div class="structure_field_info">mapComp_naturality_right : <span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) {<span class="fn">g </span>g' : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">g</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g'</span></span>),
  <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">f</span> <span class="fn">η</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g'</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.map₂_id" class="structure_field"><div class="structure_field_info">map₂_id : <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">f</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.map₂_comp" class="structure_field"><div class="structure_field_info">map₂_comp : <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">B</span>} {<span class="fn">f </span>g h : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>) (<span class="fn">θ</span> : <span class="fn"><span class="fn">g</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">h</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">η</span> <span class="fn">θ</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">θ</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.map₂_associator" class="structure_field"><div class="structure_field_info">map₂_associator : <span class="fn">∀ {<span class="fn">a </span>b c d : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">d</span></span>),
  <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.associator">CategoryTheory.Bicategory.associator</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span>.hom</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span>)</span>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span>)</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">h</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h</span></span>)</span></span>)</span>
        <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.associator">CategoryTheory.Bicategory.associator</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h</span></span>)</span></span>)</span>.hom</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.map₂_leftUnitor" class="structure_field"><div class="structure_field_info">map₂_leftUnitor : <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.leftUnitor">CategoryTheory.Bicategory.leftUnitor</a> <span class="fn">f</span></span>)</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">a</span></span>)</span> <span class="fn">f</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapId</span> <span class="fn">a</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>
        <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.leftUnitor">CategoryTheory.Bicategory.leftUnitor</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>.hom</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.map₂_rightUnitor" class="structure_field"><div class="structure_field_info">map₂_rightUnitor : <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.rightUnitor">CategoryTheory.Bicategory.rightUnitor</a> <span class="fn">f</span></span>)</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">b</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapId</span> <span class="fn">b</span></span>)</span></span>)</span>
        <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.rightUnitor">CategoryTheory.Bicategory.rightUnitor</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>.hom</span></span>)</span></span></span></span></div></li></ul><details id="instances-for-list-CategoryTheory.OplaxFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.map₂_associator_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L217-L217">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.map₂_associator_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">map₂_associator_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">B</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">d</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">d</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h✝</span></span>)</span></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.associator">CategoryTheory.Bicategory.associator</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h✝</span></span>)</span>.hom</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h✝</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">g</span> <span class="fn">h✝</span></span>)</span></span>)</span> <span class="fn">h</span></span>)</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">h✝</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h✝</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a>
        <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.associator">CategoryTheory.Bicategory.associator</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h✝</span></span>)</span></span>)</span>.hom</span> <span class="fn">h</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.mapComp_naturality_left_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L217-L217">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapComp_naturality_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">mapComp_naturality_left_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f' : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(η : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">f'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">c</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f'</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">η</span> <span class="fn">g</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f'</span> <span class="fn">g</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span>)</span></span>)</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.mapComp_naturality_right_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L217-L217">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapComp_naturality_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">mapComp_naturality_right_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">B</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g' : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(η : <span class="fn"><span class="fn">g</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">c</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g'</span></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">f</span> <span class="fn">η</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g'</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span></span>)</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.map₂_rightUnitor_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L222-L222">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.map₂_rightUnitor_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">map₂_rightUnitor_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">b</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.rightUnitor">CategoryTheory.Bicategory.rightUnitor</a> <span class="fn">f</span></span>)</span>.hom</span></span>)</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">b</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapId</span> <span class="fn">b</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.rightUnitor">CategoryTheory.Bicategory.rightUnitor</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>.hom</span> <span class="fn">h</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.map₂_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L222-L222">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.map₂_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">map₂_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(η : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(θ : <span class="fn"><span class="fn">g</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">h✝</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">b</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h✝</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">η</span> <span class="fn">θ</span></span>)</span></span>)</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">θ</span></span>)</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.map₂_leftUnitor_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L222-L222">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.map₂_leftUnitor_assoc"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">map₂_leftUnitor_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">b</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.leftUnitor">CategoryTheory.Bicategory.leftUnitor</a> <span class="fn">f</span></span>)</span>.hom</span></span>)</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">a</span></span>)</span> <span class="fn">f</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapId</span> <span class="fn">a</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.leftUnitor">CategoryTheory.Bicategory.leftUnitor</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>.hom</span> <span class="fn">h</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.hasCoeToPrelax"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L239-L240">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.hasCoeToPrelax"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">hasCoeToPrelax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Coe.html#Coe">Coe</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.OplaxFunctor.hasCoeToPrelax</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">coe</span> := <span class="fn">CategoryTheory.OplaxFunctor.toPrelaxFunctor</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.mapFunctor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L259-L259">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">mapFunctor_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">B</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapFunctor">CategoryTheory.OplaxFunctor.mapFunctor</a> <span class="fn">F</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span>.obj</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.mapFunctor_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L259-L259">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">mapFunctor_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span>Y : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapFunctor">CategoryTheory.OplaxFunctor.mapFunctor</a> <span class="fn">F</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span>.map</span> <span class="fn">η</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map₂</span> <span class="fn">η</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.mapFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L260-L263">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">mapFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">b</span></span></span>)</span></span></div></div><p>Function between 1-morphisms as a functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapFunctor">CategoryTheory.OplaxFunctor.mapFunctor</a> <span class="fn">F</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">toPrefunctor</span> := <span class="fn">{ <span class="fn">obj</span> := <span class="fn">fun (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">f</span></span></span>, <span class="fn">map</span> := <span class="fn">fun {<span class="fn">X </span>Y : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">F</span>.map₂</span> <span class="fn">η</span></span></span> }</span>,
    <span class="fn">map_id</span> := <span class="fn">⋯</span>, <span class="fn">map_comp</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.OplaxFunctor.mapFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.id_mapId"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L267-L267">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.id_mapId"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">id_mapId</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.id">CategoryTheory.OplaxFunctor.id</a> <span class="fn">B</span></span>)</span>.mapId</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">a</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.id_mapComp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L267-L267">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.id_mapComp"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">id_mapComp</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.id">CategoryTheory.OplaxFunctor.id</a> <span class="fn">B</span></span>)</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.id_toPrelaxFunctor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L267-L267">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.id_toPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">id_toPrelaxFunctor</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.id">CategoryTheory.OplaxFunctor.id</a> <span class="fn">B</span></span>)</span>.toPrelaxFunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.id">CategoryTheory.PrelaxFunctor.id</a> <span class="fn">B</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.id"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L268-L272">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.id"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">id</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">B</span></span></div></div><p>The identity oplax functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.OplaxFunctor.id" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.instInhabitedOplaxFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L275-L276">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.instInhabitedOplaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">instInhabitedOplaxFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">B</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.OplaxFunctor.instInhabitedOplaxFunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.id">CategoryTheory.OplaxFunctor.id</a> <span class="fn">B</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.comp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L280-L310">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.comp"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">D</span></span></div></div><p>Composition of oplax functors.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.OplaxFunctor.comp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OplaxFunctor.PseudoCore"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L320-L325">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.PseudoCore"><span class="name">CategoryTheory</span>.<span class="name">OplaxFunctor</span>.<span class="name">PseudoCore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max (max u₁ v₁) w₂)</div></div><p>A structure on an oplax functor that promotes an oplax functor to a pseudofunctor.
See <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax">Pseudofunctor.mkOfOplax</a></code>.</p><ul class="structure_fields" id="CategoryTheory.OplaxFunctor.PseudoCore.mk"><li id="CategoryTheory.OplaxFunctor.PseudoCore.mapIdIso" class="structure_field"><div class="structure_field_info">mapIdIso : <span class="fn">(<span class="fn">a</span> : <span class="fn">B</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">a</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">a</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.PseudoCore.mapCompIso" class="structure_field"><div class="structure_field_info">mapCompIso : <span class="fn">{<span class="fn">a </span>b c : <span class="fn">B</span>} →
  <span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) →
    <span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>) →
      <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span></span></span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.PseudoCore.mapIdIso_hom" class="structure_field"><div class="structure_field_info">mapIdIso_hom : <span class="fn">∀ {<span class="fn">a</span> : <span class="fn">B</span>}, <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapIdIso</span> <span class="fn">a</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.mapId</span> <span class="fn">a</span></span></span></span></div></li><li id="CategoryTheory.OplaxFunctor.PseudoCore.mapCompIso_hom" class="structure_field"><div class="structure_field_info">mapCompIso_hom : <span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapCompIso</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span></span></span></div></li></ul><details id="instances-for-list-CategoryTheory.OplaxFunctor.PseudoCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Pseudofunctor"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L363-L392">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">PrelaxFunctor</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max (max (max (max (max u₁ u₂) v₁) v₂) w₁) w₂)</div></div><p>A pseudofunctor <code>F</code> between bicategories <code>B</code> and <code>C</code> consists of a function between objects
<code>F.obj</code>, a function between 1-morphisms <code>F.map</code>, and a function between 2-morphisms <code>F.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.map₂">map₂</a></code>.</p><p>Unlike functors between categories, <code>F.map</code> do not need to strictly commute with the compositions,
and do not need to strictly preserve the identity. Instead, there are specified 2-isomorphisms
<code>F.map (𝟙 a) ≅ 𝟙 (F.obj a)</code> and <code>F.map (f ≫ g) ≅ F.map f ≫ F.map g</code>.</p><p><code>F.<a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.map₂">map₂</a></code> strictly commute with compositions and preserve the identity. They also preserve the
associator, the left unitor, and the right unitor modulo some adjustments of domains and codomains
of 2-morphisms.</p><ul class="structure_fields" id="CategoryTheory.Pseudofunctor.mk"><li id="CategoryTheory.Pseudofunctor.obj" class="structure_field"><div class="structure_field_info">obj : <span class="fn"><span class="fn">B</span> → <span class="fn">C</span></span></div></li><li id="CategoryTheory.Pseudofunctor.map" class="structure_field"><div class="structure_field_info">map : <span class="fn">{<span class="fn">X </span>Y : <span class="fn">B</span>} → <span class="fn"><span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">Y</span></span></span>)</span></span></span></div></li><li id="CategoryTheory.Pseudofunctor.map₂" class="structure_field"><div class="structure_field_info">map₂ : <span class="fn">{<span class="fn">a </span>b : <span class="fn">B</span>} → <span class="fn">{<span class="fn">f </span>g : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} → <span class="fn"><span class="fn">(<span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span></span>)</span></span></span></span></div></li><li id="CategoryTheory.Pseudofunctor.mapId" class="structure_field"><div class="structure_field_info">mapId : <span class="fn">(<span class="fn">a</span> : <span class="fn">B</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">a</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.Pseudofunctor.mapComp" class="structure_field"><div class="structure_field_info">mapComp : <span class="fn">{<span class="fn">a </span>b c : <span class="fn">B</span>} →
  <span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) →
    <span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>) →
      <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span>)</span></span></span></span></span></span></div></li><li id="CategoryTheory.Pseudofunctor.map₂_id" class="structure_field"><div class="structure_field_info">map₂_id : <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">f</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.Pseudofunctor.map₂_comp" class="structure_field"><div class="structure_field_info">map₂_comp : <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">B</span>} {<span class="fn">f </span>g h : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>) (<span class="fn">θ</span> : <span class="fn"><span class="fn">g</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">h</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">η</span> <span class="fn">θ</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">θ</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.Pseudofunctor.map₂_whisker_left" class="structure_field"><div class="structure_field_info">map₂_whisker_left : <span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) {<span class="fn">g </span>h : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">g</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">h</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">f</span> <span class="fn">η</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.hom</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span></span>)</span>
        <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">h</span></span>)</span>.inv</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.Pseudofunctor.map₂_whisker_right" class="structure_field"><div class="structure_field_info">map₂_whisker_right : <span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} {<span class="fn">f </span>g : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">η</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">h</span></span>)</span>.hom</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h</span></span>)</span></span>)</span>
        <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span>.inv</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.Pseudofunctor.map₂_associator" class="structure_field"><div class="structure_field_info">map₂_associator : <span class="fn">∀ {<span class="fn">a </span>b c d : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">d</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.associator">CategoryTheory.Bicategory.associator</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">h</span></span>)</span>.hom</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.hom</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h</span></span>)</span></span>)</span>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a>
          <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.associator">CategoryTheory.Bicategory.associator</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h</span></span>)</span></span>)</span>.hom</span>
          <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a>
            <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span>.inv</span></span>)</span>
            <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span>)</span>.inv</span></span>)</span></span>)</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.Pseudofunctor.map₂_left_unitor" class="structure_field"><div class="structure_field_info">map₂_left_unitor : <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.leftUnitor">CategoryTheory.Bicategory.leftUnitor</a> <span class="fn">f</span></span>)</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">a</span></span>)</span> <span class="fn">f</span></span>)</span>.hom</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapId</span> <span class="fn">a</span></span>)</span>.hom</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>
        <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.leftUnitor">CategoryTheory.Bicategory.leftUnitor</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>.hom</span></span>)</span></span></span></span></div></li><li id="CategoryTheory.Pseudofunctor.map₂_right_unitor" class="structure_field"><div class="structure_field_info">map₂_right_unitor : <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.rightUnitor">CategoryTheory.Bicategory.rightUnitor</a> <span class="fn">f</span></span>)</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">b</span></span>)</span></span>)</span>.hom</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapId</span> <span class="fn">b</span></span>)</span>.hom</span></span>)</span>
        <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.rightUnitor">CategoryTheory.Bicategory.rightUnitor</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>.hom</span></span>)</span></span></span></span></div></li></ul><details id="instances-for-list-CategoryTheory.Pseudofunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.map₂_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L400-L400">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.map₂_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(η : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(θ : <span class="fn"><span class="fn">g</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">h✝</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">b</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h✝</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">η</span> <span class="fn">θ</span></span>)</span></span>)</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">θ</span></span>)</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.map₂_associator_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L400-L400">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.map₂_associator_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_associator_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">B</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">d</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">d</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h✝</span></span>)</span></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.associator">CategoryTheory.Bicategory.associator</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h✝</span></span>)</span>.hom</span></span>)</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span> <span class="fn">h✝</span></span>)</span>.hom</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.hom</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h✝</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a>
        <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.associator">CategoryTheory.Bicategory.associator</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h✝</span></span>)</span></span>)</span>.hom</span>
        <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">g</span> <span class="fn">h✝</span></span>)</span>.inv</span></span>)</span>
          <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h✝</span></span>)</span></span>)</span>.inv</span> <span class="fn">h</span></span>)</span></span>)</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.map₂_right_unitor_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L400-L400">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.map₂_right_unitor_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_right_unitor_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">b</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.rightUnitor">CategoryTheory.Bicategory.rightUnitor</a> <span class="fn">f</span></span>)</span>.hom</span></span>)</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">b</span></span>)</span></span>)</span>.hom</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapId</span> <span class="fn">b</span></span>)</span>.hom</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.rightUnitor">CategoryTheory.Bicategory.rightUnitor</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>.hom</span> <span class="fn">h</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.map₂_whisker_right_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L400-L400">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.map₂_whisker_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_whisker_right_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(η : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">c</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h✝</span></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">η</span> <span class="fn">h✝</span></span>)</span></span>)</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">h✝</span></span>)</span>.hom</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">h✝</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">g</span> <span class="fn">h✝</span></span>)</span>.inv</span> <span class="fn">h</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.map₂_left_unitor_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L400-L400">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.map₂_left_unitor_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_left_unitor_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">b</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.leftUnitor">CategoryTheory.Bicategory.leftUnitor</a> <span class="fn">f</span></span>)</span>.hom</span></span>)</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">a</span></span>)</span> <span class="fn">f</span></span>)</span>.hom</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerRight">CategoryTheory.Bicategory.whiskerRight</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapId</span> <span class="fn">a</span></span>)</span>.hom</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.leftUnitor">CategoryTheory.Bicategory.leftUnitor</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span></span>)</span>.hom</span> <span class="fn">h</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.map₂_whisker_left_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L400-L400">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.map₂_whisker_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">map₂_whisker_left_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">B</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(η : <span class="fn"><span class="fn">g</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">h✝</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">self</span>.obj</span> <span class="fn">c</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h✝</span></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">f</span> <span class="fn">η</span></span>)</span></span>)</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.hom</span>
    <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory.whiskerLeft">CategoryTheory.Bicategory.whiskerLeft</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.map₂</span> <span class="fn">η</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.mapComp</span> <span class="fn">f</span> <span class="fn">h✝</span></span>)</span>.inv</span> <span class="fn">h</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L425-L426">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">hasCoeToPrelaxFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Coe.html#Coe">Coe</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor">CategoryTheory.PrelaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Pseudofunctor.hasCoeToPrelaxFunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">coe</span> := <span class="fn">CategoryTheory.Pseudofunctor.toPrelaxFunctor</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.toOplax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L445-L448">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.toOplax"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">toOplax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span></div></div><p>The oplax functor associated with a pseudofunctor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Pseudofunctor.toOplax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.hasCoeToOplax"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L451-L452">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.hasCoeToOplax"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">hasCoeToOplax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Coe.html#Coe">Coe</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Pseudofunctor.hasCoeToOplax</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">coe</span> := <span class="fn">CategoryTheory.Pseudofunctor.toOplax</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.to_oplax_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L459-L460">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.to_oplax_obj"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">to_oplax_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.toOplax">CategoryTheory.Pseudofunctor.toOplax</a> <span class="fn">F</span></span>)</span>.obj</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">F</span>.obj</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.to_oplax_mapId"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L472-L473">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.to_oplax_mapId"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">to_oplax_mapId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.toOplax">CategoryTheory.Pseudofunctor.toOplax</a> <span class="fn">F</span></span>)</span>.mapId</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapId</span> <span class="fn">a</span></span>)</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.to_oplax_mapComp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L477-L479">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.to_oplax_mapComp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">to_oplax_mapComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">B</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">B</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.toOplax">CategoryTheory.Pseudofunctor.toOplax</a> <span class="fn">F</span></span>)</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.mapFunctor_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L485-L485">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mapFunctor_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span>Y : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>} (<span class="fn">η</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mapFunctor">CategoryTheory.Pseudofunctor.mapFunctor</a> <span class="fn">F</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span>.map</span> <span class="fn">η</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.toOplax">CategoryTheory.Pseudofunctor.toOplax</a> <span class="fn">F</span></span>)</span>.map₂</span> <span class="fn">η</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.mapFunctor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L485-L485">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mapFunctor_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">B</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mapFunctor">CategoryTheory.Pseudofunctor.mapFunctor</a> <span class="fn">F</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span>.obj</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.toOplax">CategoryTheory.Pseudofunctor.toOplax</a> <span class="fn">F</span></span>)</span>.map</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.mapFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L486-L487">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mapFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">b</span></span></span>)</span></span></div></div><p>Function on 1-morphisms as a functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mapFunctor">CategoryTheory.Pseudofunctor.mapFunctor</a> <span class="fn">F</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapFunctor">CategoryTheory.OplaxFunctor.mapFunctor</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.toOplax">CategoryTheory.Pseudofunctor.toOplax</a> <span class="fn">F</span></span>)</span> <span class="fn">a</span> <span class="fn">b</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Pseudofunctor.mapFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.id_toPrelaxFunctor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L491-L491">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.id_toPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">id_toPrelaxFunctor</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.id">CategoryTheory.Pseudofunctor.id</a> <span class="fn">B</span></span>)</span>.toPrelaxFunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.id">CategoryTheory.PrelaxFunctor.id</a> <span class="fn">B</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.id_mapId"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L491-L491">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.id_mapId"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">id_mapId</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.id">CategoryTheory.Pseudofunctor.id</a> <span class="fn">B</span></span>)</span>.mapId</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">a</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.id_mapComp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L491-L491">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.id_mapComp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">id_mapComp</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.id">CategoryTheory.Pseudofunctor.id</a> <span class="fn">B</span></span>)</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.id"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L492-L495">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.id"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">id</span></a></span><span class="decl_args">
<span class="fn">(B : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">B</span></span></div></div><p>The identity pseudofunctor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Pseudofunctor.id" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.instInhabitedPseudofunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L498-L499">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.instInhabitedPseudofunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">instInhabitedPseudofunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">B</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Pseudofunctor.instInhabitedPseudofunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.id">CategoryTheory.Pseudofunctor.id</a> <span class="fn">B</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.comp_mapComp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L502-L502">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.comp_mapComp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">comp_mapComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.comp">CategoryTheory.Pseudofunctor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mapFunctor">CategoryTheory.Pseudofunctor.mapFunctor</a> <span class="fn">G</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">a</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">c</span></span>)</span></span>)</span>.mapIso</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>       <span class="fn"><span class="fn"><span class="fn">G</span>.mapComp</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span>)</span></span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.comp_mapId"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L502-L502">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.comp_mapId"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">comp_mapId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.comp">CategoryTheory.Pseudofunctor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.mapId</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mapFunctor">CategoryTheory.Pseudofunctor.mapFunctor</a> <span class="fn">G</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">a</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">a</span></span>)</span></span>)</span>.mapIso</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapId</span> <span class="fn">a</span></span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn">G</span>.mapId</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">a</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.comp_toPrelaxFunctor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L502-L502">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.comp_toPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">comp_toPrelaxFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.comp">CategoryTheory.Pseudofunctor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span>.toPrelaxFunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.PrelaxFunctor.comp">CategoryTheory.PrelaxFunctor.comp</a> <span class="fn"><span class="fn">F</span>.toPrelaxFunctor</span> <span class="fn"><span class="fn">G</span>.toPrelaxFunctor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.comp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L503-L509">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.comp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">D</span></span></div></div><p>Composition of pseudofunctors.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Pseudofunctor.comp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.mkOfOplax_mapId"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L514-L514">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax_mapId"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax_mapId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.PseudoCore">CategoryTheory.OplaxFunctor.PseudoCore</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax">CategoryTheory.Pseudofunctor.mkOfOplax</a> <span class="fn">F</span> <span class="fn">F'</span></span>)</span>.mapId</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F'</span>.mapIdIso</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.mkOfOplax_mapComp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L514-L514">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax_mapComp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax_mapComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.PseudoCore">CategoryTheory.OplaxFunctor.PseudoCore</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax">CategoryTheory.Pseudofunctor.mkOfOplax</a> <span class="fn">F</span> <span class="fn">F'</span></span>)</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F'</span>.mapCompIso</span> <span class="fn">f</span> <span class="fn">g</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.mkOfOplax_toPrelaxFunctor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L514-L514">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax_toPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax_toPrelaxFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.PseudoCore">CategoryTheory.OplaxFunctor.PseudoCore</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax">CategoryTheory.Pseudofunctor.mkOfOplax</a> <span class="fn">F</span> <span class="fn">F'</span></span>)</span>.toPrelaxFunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">F</span>.toPrelaxFunctor</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.mkOfOplax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L515-L531">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(F' : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.PseudoCore">CategoryTheory.OplaxFunctor.PseudoCore</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span></div></div><p>Construct a pseudofunctor from an oplax functor whose <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapId">mapId</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapComp">mapComp</a></code> are isomorphisms.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Pseudofunctor.mkOfOplax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.mkOfOplax'_toPrelaxFunctor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L536-L536">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax'_toPrelaxFunctor"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax'_toPrelaxFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">B</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapId</span> <span class="fn">a</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax'">CategoryTheory.Pseudofunctor.mkOfOplax'</a> <span class="fn">F</span></span>)</span>.toPrelaxFunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">F</span>.toPrelaxFunctor</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.mkOfOplax'_mapId"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L536-L536">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax'_mapId"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax'_mapId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">B</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapId</span> <span class="fn">a</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax'">CategoryTheory.Pseudofunctor.mkOfOplax'</a> <span class="fn">F</span></span>)</span>.mapId</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.asIso">CategoryTheory.asIso</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapId</span> <span class="fn">a</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.mkOfOplax'_mapComp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L536-L536">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax'_mapComp"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax'_mapComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">B</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapId</span> <span class="fn">a</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax'">CategoryTheory.Pseudofunctor.mkOfOplax'</a> <span class="fn">F</span></span>)</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.asIso">CategoryTheory.asIso</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Pseudofunctor.mkOfOplax'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Bicategory/Functor.lean#L537-L552">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor.mkOfOplax'"><span class="name">CategoryTheory</span>.<span class="name">Pseudofunctor</span>.<span class="name">mkOfOplax'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">B</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Basic.html#CategoryTheory.Bicategory">CategoryTheory.Bicategory</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor">CategoryTheory.OplaxFunctor</a> <span class="fn">B</span> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">B</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapId</span> <span class="fn">a</span></span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ {<span class="fn">a </span>b c : <span class="fn">B</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">CategoryTheory.IsIso</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.mapComp</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.Pseudofunctor">CategoryTheory.Pseudofunctor</a> <span class="fn">B</span> <span class="fn">C</span></span></div></div><p>Construct a pseudofunctor from an oplax functor whose <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapId">mapId</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Bicategory/Functor.html#CategoryTheory.OplaxFunctor.mapComp">mapComp</a></code> are isomorphisms.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Pseudofunctor.mkOfOplax'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>