{"name":"Lean.Meta.Match.MatcherApp.Transform","instances":[],"imports":["Lean.Meta.Match","Lean.Meta.InferType","Lean.Meta.Check","Lean.Meta.Tactic.Split"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Meta/Match/MatcherApp/Transform.lean#L152-L157","name":"Lean.Meta.MatcherApp.refineThrough?","line":152,"kind":"def","docLink":"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.refineThrough?","doc":"A non-failing version of `MatcherApp.refineThrough` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.refineThrough?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MatcherApp</span>.<span class=\"name\">refineThrough?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(matcherApp : <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">Lean.Meta.MatcherApp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Meta/Match/MatcherApp/Transform.lean#L113-L149","name":"Lean.Meta.MatcherApp.refineThrough","line":113,"kind":"def","docLink":"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.refineThrough","doc":"Given\n- matcherApp `match_i As (fun xs => motive[xs]) discrs (fun ys_1 => (alt_1 : motive (C_1[ys_1])) ... (fun ys_n => (alt_n : motive (C_n[ys_n]) remaining`, and\n- a expression `B[discrs]` (which may not be a type, e.g. `n : Nat`),\nreturns the expressions `fun ys_1 ... ys_i => B[C_1[ys_1]] ... B[C_n[ys_n]]`,\n\nThis method assumes\n- the `matcherApp.motive` is a lambda abstraction where `xs.size == discrs.size`\n- each alternative is a lambda abstraction where `ys_i.size == matcherApp.altNumParams[i]`\n\nThis is similar to `MatcherApp.addArg` when you only have an expression to\nrefined, and not a type with a value.\n\nThis is used in in `Lean.Elab.PreDefinition.WF.GuessFix` when constructing the context of recursive\ncalls to refine the functions' paramter, which may mention `major`.\nSee there for how to use this function.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.refineThrough\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MatcherApp</span>.<span class=\"name\">refineThrough</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(matcherApp : <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">Lean.Meta.MatcherApp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Meta/Match/MatcherApp/Transform.lean#L90-L94","name":"Lean.Meta.MatcherApp.addArg?","line":90,"kind":"def","docLink":"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.addArg?","doc":"Similar to `MatcherApp.addArg`, but returns `none` on failure. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.addArg?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MatcherApp</span>.<span class=\"name\">addArg?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(matcherApp : <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">Lean.Meta.MatcherApp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">Lean.Meta.MatcherApp</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Meta/Match/MatcherApp/Transform.lean#L54-L87","name":"Lean.Meta.MatcherApp.addArg","line":54,"kind":"def","docLink":"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.addArg","doc":"Given\n- matcherApp `match_i As (fun xs => motive[xs]) discrs (fun ys_1 => (alt_1 : motive (C_1[ys_1])) ... (fun ys_n => (alt_n : motive (C_n[ys_n]) remaining`, and\n- expression `e : B[discrs]`,\nConstruct the term\n`match_i As (fun xs => B[xs] -> motive[xs]) discrs (fun ys_1 (y : B[C_1[ys_1]]) => alt_1) ... (fun ys_n (y : B[C_n[ys_n]]) => alt_n) e remaining`.\n\nWe use `kabstract` to abstract the discriminants from `B[discrs]`.\n\nThis method assumes\n- the `matcherApp.motive` is a lambda abstraction where `xs.size == discrs.size`\n- each alternative is a lambda abstraction where `ys_i.size == matcherApp.altNumParams[i]`\n\nThis is used in in `Lean.Elab.PreDefinition.WF.Fix` when replacing recursive calls with calls to\nthe argument provided by `fix` to refine the termination argument, which may mention `major`.\nSee there for how to use this function.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatcherApp/Transform.html#Lean.Meta.MatcherApp.addArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MatcherApp</span>.<span class=\"name\">addArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(matcherApp : <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">Lean.Meta.MatcherApp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Match/MatcherApp/Basic.html#Lean.Meta.MatcherApp\">Lean.Meta.MatcherApp</a></span></div></div>"}]}