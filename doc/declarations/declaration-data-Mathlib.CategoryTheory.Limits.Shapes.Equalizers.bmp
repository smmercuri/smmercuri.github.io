{"name":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","instances":[{"typeNames":["Eq"],"name":"CategoryTheory.Limits.instDecidableEqWalkingParallelPair","className":"Decidable"},{"typeNames":["CategoryTheory.Limits.WalkingParallelPair"],"name":"CategoryTheory.Limits.instInhabitedWalkingParallelPair","className":"Inhabited"},{"typeNames":["Eq"],"name":"CategoryTheory.Limits.instDecidableEqWalkingParallelPairHom","className":"Decidable"},{"typeNames":["CategoryTheory.Limits.WalkingParallelPairHom"],"name":"CategoryTheory.Limits.instInhabitedWalkingParallelPairHomZeroOne","className":"Inhabited"},{"typeNames":["CategoryTheory.Limits.WalkingParallelPair"],"name":"CategoryTheory.Limits.walkingParallelPairHomCategory","className":"CategoryTheory.Category"},{"typeNames":["CategoryTheory.Limits.equalizer.ι"],"name":"CategoryTheory.Limits.equalizer.ι_mono","className":"CategoryTheory.Mono"},{"typeNames":[],"name":"CategoryTheory.Limits.hasEqualizer_of_self","className":"CategoryTheory.Limits.HasLimit"},{"typeNames":["CategoryTheory.Limits.equalizer.ι"],"name":"CategoryTheory.Limits.equalizer.ι_of_self","className":"CategoryTheory.IsIso"},{"typeNames":["CategoryTheory.Limits.coequalizer.π"],"name":"CategoryTheory.Limits.coequalizer.π_epi","className":"CategoryTheory.Epi"},{"typeNames":[],"name":"CategoryTheory.Limits.hasCoequalizer_of_self","className":"CategoryTheory.Limits.HasColimit"},{"typeNames":["CategoryTheory.Limits.coequalizer.π"],"name":"CategoryTheory.Limits.coequalizer.π_of_self","className":"CategoryTheory.IsIso"}],"imports":["Init","Mathlib.CategoryTheory.EpiMono","Mathlib.CategoryTheory.Limits.HasLimits"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1348-L1350","name":"CategoryTheory.Limits.splitEpiOfIdempotentCoequalizer","line":1348,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitEpiOfIdempotentCoequalizer","doc":"The coequalizer of an idempotent morphism and the identity is split epi. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitEpiOfIdempotentCoequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">splitEpiOfIdempotentCoequalizer</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span>)</span> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.SplitEpi\">CategoryTheory.SplitEpi</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span>)</span> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1337-L1344","name":"CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork","line":1337,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork","doc":"A coequalizer of an idempotent morphism and the identity is split epi. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">splitEpiOfIdempotentOfIsColimitCofork</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span>)</span> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.SplitEpi\">CategoryTheory.SplitEpi</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1336-L1336","name":"CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork_section_","line":1336,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork_section_","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork_section_\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">splitEpiOfIdempotentOfIsColimitCofork_section_</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span>)</span> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork\">CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork</a> <span class=\"fn\">C</span> <span class=\"fn\">hf</span> <span class=\"fn\">i</span></span>)</span>.section_</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">i</span>.desc</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ\">CategoryTheory.Limits.Cofork.ofπ</a> <span class=\"fn\">f</span> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1327-L1330","name":"CategoryTheory.Limits.hasCoequalizer_epi_comp","line":1327,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasCoequalizer_epi_comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasCoequalizer_epi_comp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasCoequalizer_epi_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">h</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">g</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1314-L1324","name":"CategoryTheory.Limits.isCoequalizerEpiComp","line":1314,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isCoequalizerEpiComp","doc":"The cofork obtained by precomposing a coequalizer cofork with an epimorphism is\na coequalizer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isCoequalizerEpiComp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isCoequalizerEpiComp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[hm : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">h</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let_fun this := <span class=\"fn\">⋯</span>;\n<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ\">CategoryTheory.Limits.Cofork.ofπ</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">c</span></span>)</span> <span class=\"fn\">this</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1299-L1307","name":"CategoryTheory.Limits.splitEpiOfCoequalizer","line":1299,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitEpiOfCoequalizer","doc":"We show that the converse to `isSplitEpiEqualizes` is true:\nWhenever `f` coequalizes `(f ≫ s)` and `(𝟙 X)`, then `s` is a section of `f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitEpiOfCoequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">splitEpiOfCoequalizer</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">s</span> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ\">CategoryTheory.Limits.Cofork.ofπ</a> <span class=\"fn\">f</span> <span class=\"fn\">⋯</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.SplitEpi\">CategoryTheory.SplitEpi</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1287-L1292","name":"CategoryTheory.Limits.isSplitEpiCoequalizes","line":1287,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isSplitEpiCoequalizes","doc":"A split epi `f` coequalizes `(f ≫ section_ f)` and `(𝟙 X)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isSplitEpiCoequalizes\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isSplitEpiCoequalizes</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.IsSplitEpi\">CategoryTheory.IsSplitEpi</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi\">CategoryTheory.Limits.coconeOfIsSplitEpi</a> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1281-L1282","name":"CategoryTheory.Limits.coconeOfIsSplitEpi_π","line":1281,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coconeOfIsSplitEpi_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.IsSplitEpi\">CategoryTheory.IsSplitEpi</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi\">CategoryTheory.Limits.coconeOfIsSplitEpi</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1276-L1277","name":"CategoryTheory.Limits.coconeOfIsSplitEpi","line":1276,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi","doc":"A split epi `f` coequalizes `(f ≫ section_ f)` and `(𝟙 X)`.\nHere we build the cocone, and show in `isSplitEpiCoequalizes` that it is a colimit cocone.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coconeOfIsSplitEpi</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.IsSplitEpi\">CategoryTheory.IsSplitEpi</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.section_\">CategoryTheory.section_</a> <span class=\"fn\">f</span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1275-L1275","name":"CategoryTheory.Limits.coconeOfIsSplitEpi_pt","line":1275,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi_pt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi_pt\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coconeOfIsSplitEpi_pt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.IsSplitEpi\">CategoryTheory.IsSplitEpi</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi\">CategoryTheory.Limits.coconeOfIsSplitEpi</a> <span class=\"fn\">f</span></span>)</span>.pt</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1275-L1275","name":"CategoryTheory.Limits.coconeOfIsSplitEpi_ι_app","line":1275,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi_ι_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi_ι_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coconeOfIsSplitEpi_ι_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.IsSplitEpi\">CategoryTheory.IsSplitEpi</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coconeOfIsSplitEpi\">CategoryTheory.Limits.coconeOfIsSplitEpi</a> <span class=\"fn\">f</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.rec\">CategoryTheory.Limits.WalkingParallelPair.rec</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span> <span class=\"fn\">X</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1261-L1263","name":"CategoryTheory.Limits.splitMonoOfIdempotentEqualizer","line":1261,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitMonoOfIdempotentEqualizer","doc":"The equalizer of an idempotent morphism and the identity is split mono. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitMonoOfIdempotentEqualizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">splitMonoOfIdempotentEqualizer</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span>)</span> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.SplitMono\">CategoryTheory.SplitMono</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span>)</span> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1251-L1257","name":"CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork","line":1251,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork","doc":"An equalizer of an idempotent morphism and the identity is split mono. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">splitMonoOfIdempotentOfIsLimitFork</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span>)</span> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.SplitMono\">CategoryTheory.SplitMono</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1250-L1250","name":"CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork_retraction","line":1250,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork_retraction","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork_retraction\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">splitMonoOfIdempotentOfIsLimitFork_retraction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span>)</span> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork\">CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork</a> <span class=\"fn\">C</span> <span class=\"fn\">hf</span> <span class=\"fn\">i</span></span>)</span>.retraction</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">i</span>.lift</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">f</span> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1243-L1246","name":"CategoryTheory.Limits.hasEqualizer_comp_mono","line":1243,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasEqualizer_comp_mono","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasEqualizer_comp_mono\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasEqualizer_comp_mono</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">h</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1228-L1237","name":"CategoryTheory.Limits.isEqualizerCompMono","line":1228,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isEqualizerCompMono","doc":"The fork obtained by postcomposing an equalizer fork with a monomorphism is an equalizer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isEqualizerCompMono\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isEqualizerCompMono</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[hm : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">h</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let_fun this := <span class=\"fn\">⋯</span>;\n<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">c</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1218-L1222","name":"CategoryTheory.Limits.splitMonoOfEqualizer","line":1218,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitMonoOfEqualizer","doc":"We show that the converse to `isSplitMonoEqualizes` is true:\nWhenever `f` equalizes `(r ≫ f)` and `(𝟙 Y)`, then `r` is a retraction of `f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.splitMonoOfEqualizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">splitMonoOfEqualizer</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{r : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hr : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">r</span> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">f</span> <span class=\"fn\">⋯</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.SplitMono\">CategoryTheory.SplitMono</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1205-L1211","name":"CategoryTheory.Limits.isSplitMonoEqualizes","line":1205,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isSplitMonoEqualizes","doc":"A split mono `f` equalizes `(retraction f ≫ f)` and `(𝟙 Y)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isSplitMonoEqualizes\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isSplitMonoEqualizes</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.IsSplitMono\">CategoryTheory.IsSplitMono</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono\">CategoryTheory.Limits.coneOfIsSplitMono</a> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1199-L1200","name":"CategoryTheory.Limits.coneOfIsSplitMono_ι","line":1199,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coneOfIsSplitMono_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.IsSplitMono\">CategoryTheory.IsSplitMono</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono\">CategoryTheory.Limits.coneOfIsSplitMono</a> <span class=\"fn\">f</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1194-L1195","name":"CategoryTheory.Limits.coneOfIsSplitMono","line":1194,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono","doc":"A split mono `f` equalizes `(retraction f ≫ f)` and `(𝟙 Y)`.\nHere we build the cone, and show in `isSplitMonoEqualizes` that it is a limit cone.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coneOfIsSplitMono</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.IsSplitMono\">CategoryTheory.IsSplitMono</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">Y</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.retraction\">CategoryTheory.retraction</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1193-L1193","name":"CategoryTheory.Limits.coneOfIsSplitMono_π_app","line":1193,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono_π_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono_π_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coneOfIsSplitMono_π_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.IsSplitMono\">CategoryTheory.IsSplitMono</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono\">CategoryTheory.Limits.coneOfIsSplitMono</a> <span class=\"fn\">f</span></span>)</span>.π</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.rec\">CategoryTheory.Limits.WalkingParallelPair.rec</a> (motive := <span class=\"fn\">fun (<span class=\"fn\">t</span> : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>) =&gt;\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span> →\n      <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>         <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">Y</span></span>)</span>\n              <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.retraction\">CategoryTheory.retraction</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">f</span></span>)</span></span>)</span>.obj</span>\n          <span class=\"fn\">X</span></span></span>)</span></span></span>)\n    <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span>) =&gt; <span class=\"fn\"><span class=\"fn\">⋯</span> ▸ <span class=\"fn\">f</span></span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span>) =&gt; <span class=\"fn\"><span class=\"fn\">⋯</span> ▸ <span class=\"fn\">f</span></span></span>)</span> <span class=\"fn\">X</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1193-L1193","name":"CategoryTheory.Limits.coneOfIsSplitMono_pt","line":1193,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono_pt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono_pt\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coneOfIsSplitMono_pt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EpiMono.html#CategoryTheory.IsSplitMono\">CategoryTheory.IsSplitMono</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coneOfIsSplitMono\">CategoryTheory.Limits.coneOfIsSplitMono</a> <span class=\"fn\">f</span></span>)</span>.pt</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1179-L1181","name":"CategoryTheory.Limits.hasCoequalizers_of_hasColimit_parallelPair","line":1179,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasCoequalizers_of_hasColimit_parallelPair","doc":"If `C` has all colimits of diagrams `parallelPair f g`, then it has all coequalizers "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasCoequalizers_of_hasColimit_parallelPair\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasCoequalizers_of_hasColimit_parallelPair</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ {<span class=\"fn\">X </span>Y : <span class=\"fn\">C</span>} {<span class=\"fn\">f </span>g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimit\">CategoryTheory.Limits.HasColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizers\">CategoryTheory.Limits.HasCoequalizers</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1173-L1175","name":"CategoryTheory.Limits.hasEqualizers_of_hasLimit_parallelPair","line":1173,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasEqualizers_of_hasLimit_parallelPair","doc":"If `C` has all limits of diagrams `parallelPair f g`, then it has all equalizers "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasEqualizers_of_hasLimit_parallelPair\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasEqualizers_of_hasLimit_parallelPair</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ {<span class=\"fn\">X </span>Y : <span class=\"fn\">C</span>} {<span class=\"fn\">f </span>g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasLimit\">CategoryTheory.Limits.HasLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizers\">CategoryTheory.Limits.HasEqualizers</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1168-L1169","name":"CategoryTheory.Limits.HasCoequalizers","line":1168,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizers","doc":"`HasCoequalizers` represents a choice of coequalizer for every pair of morphisms "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizers\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasCoequalizers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1163-L1164","name":"CategoryTheory.Limits.HasEqualizers","line":1163,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizers","doc":"`HasEqualizers` represents a choice of equalizer for every pair of morphisms "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizers\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasEqualizers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1150-L1155","name":"CategoryTheory.Limits.coequalizerComparison_map_desc","line":1150,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerComparison_map_desc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerComparison_map_desc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizerComparison_map_desc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerComparison\">CategoryTheory.Limits.coequalizerComparison</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">G</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc\">CategoryTheory.Limits.coequalizer.desc</a> <span class=\"fn\">h</span> <span class=\"fn\">w</span></span>)</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc\">CategoryTheory.Limits.coequalizer.desc</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">h</span></span>)</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1149-L1149","name":"CategoryTheory.Limits.coequalizerComparison_map_desc_assoc","line":1149,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerComparison_map_desc_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerComparison_map_desc_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizerComparison_map_desc_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z✝</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h✝</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h✝</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">D</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">Z✝</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerComparison\">CategoryTheory.Limits.coequalizerComparison</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">G</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc\">CategoryTheory.Limits.coequalizer.desc</a> <span class=\"fn\">h✝</span> <span class=\"fn\">w</span></span>)</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc\">CategoryTheory.Limits.coequalizer.desc</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">h✝</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1144-L1146","name":"CategoryTheory.Limits.ι_comp_coequalizerComparison","line":1144,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.ι_comp_coequalizerComparison","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.ι_comp_coequalizerComparison\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">ι_comp_coequalizerComparison</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerComparison\">CategoryTheory.Limits.coequalizerComparison</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">G</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1143-L1143","name":"CategoryTheory.Limits.ι_comp_coequalizerComparison_assoc","line":1143,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.ι_comp_coequalizerComparison_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.ι_comp_coequalizerComparison_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">ι_comp_coequalizerComparison_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">D</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerComparison\">CategoryTheory.Limits.coequalizerComparison</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">G</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1137-L1140","name":"CategoryTheory.Limits.coequalizerComparison","line":1137,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerComparison","doc":"The comparison morphism for the coequalizer of `f,g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerComparison\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizerComparison</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1128-L1133","name":"CategoryTheory.Limits.map_lift_equalizerComparison","line":1128,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.map_lift_equalizerComparison","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.map_lift_equalizerComparison\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">map_lift_equalizerComparison</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{h : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift\">CategoryTheory.Limits.equalizer.lift</a> <span class=\"fn\">h</span> <span class=\"fn\">w</span></span>)</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerComparison\">CategoryTheory.Limits.equalizerComparison</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">G</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift\">CategoryTheory.Limits.equalizer.lift</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">h</span></span>)</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1127-L1127","name":"CategoryTheory.Limits.map_lift_equalizerComparison_assoc","line":1127,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.map_lift_equalizerComparison_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.map_lift_equalizerComparison_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">map_lift_equalizerComparison_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{h : <span class=\"fn\"><span class=\"fn\">Z✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h✝</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h✝</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">D</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\">CategoryTheory.Limits.equalizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift\">CategoryTheory.Limits.equalizer.lift</a> <span class=\"fn\">h✝</span> <span class=\"fn\">w</span></span>)</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerComparison\">CategoryTheory.Limits.equalizerComparison</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">G</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift\">CategoryTheory.Limits.equalizer.lift</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">h✝</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1122-L1124","name":"CategoryTheory.Limits.equalizerComparison_comp_π","line":1122,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerComparison_comp_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerComparison_comp_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizerComparison_comp_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerComparison\">CategoryTheory.Limits.equalizerComparison</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">G</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1121-L1121","name":"CategoryTheory.Limits.equalizerComparison_comp_π_assoc","line":1121,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerComparison_comp_π_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerComparison_comp_π_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizerComparison_comp_π_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">D</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">X</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerComparison\">CategoryTheory.Limits.equalizerComparison</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">G</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1115-L1118","name":"CategoryTheory.Limits.equalizerComparison","line":1115,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerComparison","doc":"The comparison morphism for the equalizer of `f,g`.\nThis is an isomorphism iff `G` preserves the equalizer of `f,g`; see\n`CategoryTheory/Limits/Preserves/Shapes/Equalizers.lean`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerComparison\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizerComparison</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\">CategoryTheory.Limits.equalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\">CategoryTheory.Limits.equalizer</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <span class=\"fn\">g</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1103-L1104","name":"CategoryTheory.Limits.coequalizer.isoTargetOfSelf_inv","line":1103,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.isoTargetOfSelf_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.isoTargetOfSelf_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">isoTargetOfSelf_inv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.isoTargetOfSelf\">CategoryTheory.Limits.coequalizer.isoTargetOfSelf</a> <span class=\"fn\">f</span></span>)</span>.inv</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1096-L1099","name":"CategoryTheory.Limits.coequalizer.isoTargetOfSelf_hom","line":1096,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.isoTargetOfSelf_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.isoTargetOfSelf_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">isoTargetOfSelf_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.isoTargetOfSelf\">CategoryTheory.Limits.coequalizer.isoTargetOfSelf</a> <span class=\"fn\">f</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc\">CategoryTheory.Limits.coequalizer.desc</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">Y</span></span>)</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1091-L1092","name":"CategoryTheory.Limits.coequalizer.isoTargetOfSelf","line":1091,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.isoTargetOfSelf","doc":"The coequalizer of a morphism with itself is isomorphic to the target. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.isoTargetOfSelf\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">isoTargetOfSelf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1086-L1087","name":"CategoryTheory.Limits.coequalizer.π_of_self","line":1086,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_of_self","doc":"The coequalizer projection for `(f, f)` is an isomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_of_self\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">π_of_self</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1079-L1082","name":"CategoryTheory.Limits.hasCoequalizer_of_self","line":1079,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasCoequalizer_of_self","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasCoequalizer_of_self\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasCoequalizer_of_self</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1073-L1074","name":"CategoryTheory.Limits.eq_of_mono_coequalizer","line":1073,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.eq_of_mono_coequalizer","doc":"If the coequalizer of two morphisms is a monomorphism, then the two morphisms are equal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.eq_of_mono_coequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">eq_of_mono_coequalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1068-L1069","name":"CategoryTheory.Limits.eq_of_mono_cofork_π","line":1068,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.eq_of_mono_cofork_π","doc":"Two morphisms are equal if there is a cofork whose projection is mono. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.eq_of_mono_cofork_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">eq_of_mono_cofork_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1062-L1064","name":"CategoryTheory.Limits.isIso_limit_cocone_parallelPair_of_epi","line":1062,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_limit_cocone_parallelPair_of_epi","doc":"A coequalizer that is a monomorphism is an isomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_limit_cocone_parallelPair_of_epi\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isIso_limit_cocone_parallelPair_of_epi</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">c</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1057-L1058","name":"CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_self","line":1057,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_self","doc":"Every coequalizer of `(f, f)` is an isomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_self\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isIso_colimit_cocone_parallelPair_of_self</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1052-L1053","name":"CategoryTheory.Limits.coequalizer.π_of_eq","line":1052,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_of_eq","doc":"The coequalizer of `(f, g)`, where `f = g`, is an isomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_of_eq\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">π_of_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1046-L1048","name":"CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_eq","line":1046,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_eq","doc":"Every coequalizer of `(f, g)`, where `f = g`, is an isomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_eq\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isIso_colimit_cocone_parallelPair_of_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h₀ : <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1039-L1042","name":"CategoryTheory.Limits.isColimitIdCofork","line":1039,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isColimitIdCofork","doc":"The identity on `Y` is a coequalizer of `(f, g)`, where `f = g`.  "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isColimitIdCofork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isColimitIdCofork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.idCofork\">CategoryTheory.Limits.idCofork</a> <span class=\"fn\">h</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1034-L1035","name":"CategoryTheory.Limits.idCofork","line":1034,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.idCofork","doc":"The identity determines a cocone on the coequalizer diagram of `f` and `g`, if `f = g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.idCofork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">idCofork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1023-L1024","name":"CategoryTheory.Limits.epi_of_isColimit_cofork","line":1023,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.epi_of_isColimit_cofork","doc":"The coequalizer morphism in any colimit cocone is an epimorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.epi_of_isColimit_cofork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">epi_of_isColimit_cofork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1012-L1013","name":"CategoryTheory.Limits.coequalizer.π_epi","line":1012,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_epi","doc":"A coequalizer morphism is an epimorphism "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_epi\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">π_epi</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1006-L1008","name":"CategoryTheory.Limits.coequalizer.existsUnique","line":1006,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.existsUnique","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.existsUnique\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">existsUnique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">k</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃! (<span class=\"fn\">d</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L1001-L1003","name":"CategoryTheory.Limits.coequalizer.hom_ext","line":1001,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.hom_ext","doc":"Two maps from a coequalizer are equal if they are equal when composed with the coequalizer\nmap "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">l</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L993-L995","name":"CategoryTheory.Limits.coequalizer.desc'","line":993,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc'","doc":"Any morphism `k : Y ⟶ W` satisfying `f ≫ k = g ≫ k` induces a morphism\n`l : coequalizer f g ⟶ W` satisfying `coequalizer.π ≫ g = l`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">desc'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">k</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span> //\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">l</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L983-L988","name":"CategoryTheory.Limits.coequalizer.π_colimMap_desc","line":983,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_colimMap_desc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_colimMap_desc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">π_colimMap_desc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f' : <span class=\"fn\"><span class=\"fn\">X'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g' : <span class=\"fn\"><span class=\"fn\">X'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f'</span> <span class=\"fn\">g'</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(q : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(wf : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">q</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">p</span> <span class=\"fn\">f'</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(wg : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">q</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">p</span> <span class=\"fn\">g'</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(wh : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f'</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g'</span> <span class=\"fn\">h</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimMap\">CategoryTheory.Limits.colimMap</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPairHom\">CategoryTheory.Limits.parallelPairHom</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">f'</span> <span class=\"fn\">g'</span> <span class=\"fn\">p</span> <span class=\"fn\">q</span> <span class=\"fn\">wf</span> <span class=\"fn\">wg</span></span>)</span></span>)</span>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc\">CategoryTheory.Limits.coequalizer.desc</a> <span class=\"fn\">h</span> <span class=\"fn\">wh</span></span>)</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">q</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L978-L980","name":"CategoryTheory.Limits.coequalizer.π_desc","line":978,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_desc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_desc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">π_desc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">k</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc\">CategoryTheory.Limits.coequalizer.desc</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L977-L977","name":"CategoryTheory.Limits.coequalizer.π_desc_assoc","line":977,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_desc_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π_desc_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">π_desc_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">k</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc\">CategoryTheory.Limits.coequalizer.desc</a> <span class=\"fn\">k</span> <span class=\"fn\">h✝</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L971-L973","name":"CategoryTheory.Limits.coequalizer.desc","line":971,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc","doc":"Any morphism `k : Y ⟶ W` satisfying `f ≫ k = g ≫ k` factors through the coequalizer of `f`\nand `g` via `coequalizer.desc : coequalizer f g ⟶ W`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.desc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">desc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">k</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L962-L964","name":"CategoryTheory.Limits.coequalizerIsCoequalizer","line":962,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerIsCoequalizer","doc":"The cofork built from `coequalizer.π f g` is colimiting. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizerIsCoequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizerIsCoequalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ\">CategoryTheory.Limits.Cofork.ofπ</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L957-L958","name":"CategoryTheory.Limits.coequalizer.condition","line":957,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L956-L956","name":"CategoryTheory.Limits.coequalizer.condition_assoc","line":956,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L952-L953","name":"CategoryTheory.Limits.coequalizer.cofork_ι_app_one","line":952,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.cofork_ι_app_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.cofork_ι_app_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">cofork_ι_app_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.cofork\">CategoryTheory.Limits.coequalizer.cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.ι</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L947-L948","name":"CategoryTheory.Limits.coequalizer.cofork_π","line":947,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.cofork_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.cofork_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">cofork_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.cofork\">CategoryTheory.Limits.coequalizer.cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L942-L943","name":"CategoryTheory.Limits.coequalizer.cofork","line":942,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.cofork","doc":"An arbitrary choice of coequalizer cocone for a parallel pair `f` and `g`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.cofork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">cofork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L936-L937","name":"CategoryTheory.Limits.coequalizer.π","line":936,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π","doc":"If a coequalizer of `f` and `g` exists, we can access the corresponding projection by\nsaying `coequalizer.π f g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span>.<span class=\"name\">π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L930-L931","name":"CategoryTheory.Limits.coequalizer","line":930,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer","doc":"If a coequalizer of `f` and `g` exists, we can access an arbitrary choice of such by\nsaying `coequalizer f g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">coequalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">CategoryTheory.Limits.HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">C</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L922-L923","name":"CategoryTheory.Limits.HasCoequalizer","line":922,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer","doc":"`HasCoequalizer f g` represents a particular choice of colimiting cocone\nfor the parallel pair of morphisms `f` and `g`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasCoequalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L911-L914","name":"CategoryTheory.Limits.equalizer.isoSourceOfSelf_inv","line":911,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.isoSourceOfSelf_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.isoSourceOfSelf_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">isoSourceOfSelf_inv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.isoSourceOfSelf\">CategoryTheory.Limits.equalizer.isoSourceOfSelf</a> <span class=\"fn\">f</span></span>)</span>.inv</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift\">CategoryTheory.Limits.equalizer.lift</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span>)</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L906-L907","name":"CategoryTheory.Limits.equalizer.isoSourceOfSelf_hom","line":906,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.isoSourceOfSelf_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.isoSourceOfSelf_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">isoSourceOfSelf_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.isoSourceOfSelf\">CategoryTheory.Limits.equalizer.isoSourceOfSelf</a> <span class=\"fn\">f</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L901-L902","name":"CategoryTheory.Limits.equalizer.isoSourceOfSelf","line":901,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.isoSourceOfSelf","doc":"The equalizer of a morphism with itself is isomorphic to the source. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.isoSourceOfSelf\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">isoSourceOfSelf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\">CategoryTheory.Limits.equalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L896-L897","name":"CategoryTheory.Limits.equalizer.ι_of_self","line":896,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι_of_self","doc":"The equalizer inclusion for `(f, f)` is an isomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι_of_self\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">ι_of_self</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L889-L892","name":"CategoryTheory.Limits.hasEqualizer_of_self","line":889,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasEqualizer_of_self","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.hasEqualizer_of_self\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">hasEqualizer_of_self</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L883-L884","name":"CategoryTheory.Limits.eq_of_epi_equalizer","line":883,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.eq_of_epi_equalizer","doc":"If the equalizer of two morphisms is an epimorphism, then the two morphisms are equal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.eq_of_epi_equalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">eq_of_epi_equalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L878-L879","name":"CategoryTheory.Limits.eq_of_epi_fork_ι","line":878,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.eq_of_epi_fork_ι","doc":"Two morphisms are equal if there is a fork whose inclusion is epi. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.eq_of_epi_fork_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">eq_of_epi_fork_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L873-L874","name":"CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_epi","line":873,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_epi","doc":"An equalizer that is an epimorphism is an isomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_epi\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isIso_limit_cone_parallelPair_of_epi</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">c</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L868-L869","name":"CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_self","line":868,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_self","doc":"Every equalizer of `(f, f)` is an isomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_self\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isIso_limit_cone_parallelPair_of_self</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L863-L864","name":"CategoryTheory.Limits.equalizer.ι_of_eq","line":863,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι_of_eq","doc":"The equalizer of `(f, g)`, where `f = g`, is an isomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι_of_eq\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">ι_of_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L857-L859","name":"CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_eq","line":857,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_eq","doc":"Every equalizer of `(f, g)`, where `f = g`, is an isomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_eq\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isIso_limit_cone_parallelPair_of_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h₀ : <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L850-L853","name":"CategoryTheory.Limits.isLimitIdFork","line":850,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isLimitIdFork","doc":"The identity on `X` is an equalizer of `(f, g)`, if `f = g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.isLimitIdFork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isLimitIdFork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.idFork\">CategoryTheory.Limits.idFork</a> <span class=\"fn\">h</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L845-L846","name":"CategoryTheory.Limits.idFork","line":845,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.idFork","doc":"The identity determines a cone on the equalizer diagram of `f` and `g` if `f = g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.idFork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">idFork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L834-L835","name":"CategoryTheory.Limits.mono_of_isLimit_fork","line":834,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.mono_of_isLimit_fork","doc":"The equalizer morphism in any limit cone is a monomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.mono_of_isLimit_fork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">mono_of_isLimit_fork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">c</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L823-L824","name":"CategoryTheory.Limits.equalizer.ι_mono","line":823,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι_mono","doc":"An equalizer morphism is a monomorphism "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι_mono\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">ι_mono</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L817-L819","name":"CategoryTheory.Limits.equalizer.existsUnique","line":817,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.existsUnique","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.existsUnique\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">existsUnique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃! (<span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\">CategoryTheory.Limits.equalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L812-L814","name":"CategoryTheory.Limits.equalizer.hom_ext","line":812,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.hom_ext","doc":"Two maps into an equalizer are equal if they are equal when composed with the equalizer map. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\">CategoryTheory.Limits.equalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\">CategoryTheory.Limits.equalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L805-L807","name":"CategoryTheory.Limits.equalizer.lift'","line":805,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift'","doc":"A morphism `k : W ⟶ X` satisfying `k ≫ f = k ≫ g` induces a morphism `l : W ⟶ equalizer f g`\nsatisfying `l ≫ equalizer.ι f g = k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">lift'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\">CategoryTheory.Limits.equalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span> //\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L798-L800","name":"CategoryTheory.Limits.equalizer.lift_ι","line":798,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">lift_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift\">CategoryTheory.Limits.equalizer.lift</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L797-L797","name":"CategoryTheory.Limits.equalizer.lift_ι_assoc","line":797,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift_ι_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift_ι_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">lift_ι_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift\">CategoryTheory.Limits.equalizer.lift</a> <span class=\"fn\">k</span> <span class=\"fn\">h✝</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L792-L793","name":"CategoryTheory.Limits.equalizer.lift","line":792,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift","doc":"A morphism `k : W ⟶ X` satisfying `k ≫ f = k ≫ g` factors through the equalizer of `f` and `g`\nvia `equalizer.lift : W ⟶ equalizer f g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.lift\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\">CategoryTheory.Limits.equalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L783-L785","name":"CategoryTheory.Limits.equalizerIsEqualizer","line":783,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerIsEqualizer","doc":"The equalizer built from `equalizer.ι f g` is limiting. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizerIsEqualizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizerIsEqualizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">⋯</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L778-L779","name":"CategoryTheory.Limits.equalizer.condition","line":778,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L777-L777","name":"CategoryTheory.Limits.equalizer.condition_assoc","line":777,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L773-L774","name":"CategoryTheory.Limits.equalizer.fork_π_app_zero","line":773,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.fork_π_app_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.fork_π_app_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">fork_π_app_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.fork\">CategoryTheory.Limits.equalizer.fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.π</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L768-L769","name":"CategoryTheory.Limits.equalizer.fork_ι","line":768,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.fork_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.fork_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">fork_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.fork\">CategoryTheory.Limits.equalizer.fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L763-L764","name":"CategoryTheory.Limits.equalizer.fork","line":763,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.fork","doc":"An equalizer cone for a parallel pair `f` and `g` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.fork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">fork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L758-L759","name":"CategoryTheory.Limits.equalizer.ι","line":758,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι","doc":"If an equalizer of `f` and `g` exists, we can access the inclusion\n`equalizer f g ⟶ X` by saying `equalizer.ι f g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span>.<span class=\"name\">ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\">CategoryTheory.Limits.equalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L752-L753","name":"CategoryTheory.Limits.equalizer","line":752,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer","doc":"If an equalizer of `f` and `g` exists, we can access an arbitrary choice of such by\nsaying `equalizer f g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">equalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">CategoryTheory.Limits.HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">C</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L744-L745","name":"CategoryTheory.Limits.HasEqualizer","line":744,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer","doc":"`HasEqualizer f g` represents a particular choice of limiting cone\nfor the parallel pair of morphisms `f` and `g`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">HasEqualizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L733-L734","name":"CategoryTheory.Limits.Cofork.isoCoforkOfπ","line":733,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.isoCoforkOfπ","doc":"Every cofork is isomorphic to one of the form `Cofork.ofπ _ _`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.isoCoforkOfπ\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">isoCoforkOfπ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ\">CategoryTheory.Limits.Cofork.ofπ</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">c</span></span>)</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L726-L729","name":"CategoryTheory.Limits.Cofork.ext","line":726,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ext","doc":"To construct an isomorphism between coforks,\nit suffices to give an isomorphism between the cocone points\nand check that it commutes with the `π` morphisms.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.Equalizers._hyg.7225\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L725-L725","name":"CategoryTheory.Limits.Cofork.ext_hom","line":725,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ext_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ext_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">ext_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.Equalizers._hyg.7225\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ext\">CategoryTheory.Limits.Cofork.ext</a> <span class=\"fn\">i</span> <span class=\"fn\">w</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.mkHom\">CategoryTheory.Limits.Cofork.mkHom</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\">w</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L725-L725","name":"CategoryTheory.Limits.Cofork.ext_inv","line":725,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ext_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ext_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">ext_inv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.Equalizers._hyg.7225\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ext\">CategoryTheory.Limits.Cofork.ext</a> <span class=\"fn\">i</span> <span class=\"fn\">w</span></span>)</span>.inv</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.mkHom\">CategoryTheory.Limits.Cofork.mkHom</a> <span class=\"fn\"><span class=\"fn\">i</span>.inv</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L717-L718","name":"CategoryTheory.Limits.Fork.π_comp_hom","line":717,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.π_comp_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.π_comp_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">π_comp_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f✝</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f✝</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\"><span class=\"fn\">f</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L716-L716","name":"CategoryTheory.Limits.Fork.π_comp_hom_assoc","line":716,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.π_comp_hom_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.π_comp_hom_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">π_comp_hom_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f✝</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f✝</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">f</span>.hom</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L712-L713","name":"CategoryTheory.Limits.Fork.hom_comp_ι","line":712,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.hom_comp_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.hom_comp_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">hom_comp_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f✝</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f✝</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">f</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L711-L711","name":"CategoryTheory.Limits.Fork.hom_comp_ι_assoc","line":711,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.hom_comp_ι_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.hom_comp_ι_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">hom_comp_ι_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f✝</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f✝</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f✝</span> <span class=\"fn\">g</span></span>)</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">f</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L703-L708","name":"CategoryTheory.Limits.Cofork.mkHom","line":703,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.mkHom","doc":"Helper function for constructing morphisms between coequalizer coforks.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.mkHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">mkHom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L702-L702","name":"CategoryTheory.Limits.Cofork.mkHom_hom","line":702,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.mkHom_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.mkHom_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">mkHom_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.mkHom\">CategoryTheory.Limits.Cofork.mkHom</a> <span class=\"fn\">k</span> <span class=\"fn\">w</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L696-L697","name":"CategoryTheory.Limits.Fork.isoForkOfι","line":696,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.isoForkOfι","doc":"Every fork is isomorphic to one of the form `Fork.of_ι _ _`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.isoForkOfι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">isoForkOfι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">c</span></span>)</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L689-L692","name":"CategoryTheory.Limits.Fork.ext","line":689,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ext","doc":"To construct an isomorphism between forks,\nit suffices to give an isomorphism between the cone points\nand check that it commutes with the `ι` morphisms.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.Equalizers._hyg.6826\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L688-L688","name":"CategoryTheory.Limits.Fork.ext_inv","line":688,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ext_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ext_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">ext_inv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.Equalizers._hyg.6826\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ext\">CategoryTheory.Limits.Fork.ext</a> <span class=\"fn\">i</span> <span class=\"fn\">w</span></span>)</span>.inv</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.mkHom\">CategoryTheory.Limits.Fork.mkHom</a> <span class=\"fn\"><span class=\"fn\">i</span>.inv</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L688-L688","name":"CategoryTheory.Limits.Fork.ext_hom","line":688,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ext_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ext_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">ext_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><a href=\"./Init/Meta.html#autoParam\">autoParam</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span>)</span>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#_auto._@.Mathlib.CategoryTheory.Limits.Shapes.Equalizers._hyg.6826\">_auto✝</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ext\">CategoryTheory.Limits.Fork.ext</a> <span class=\"fn\">i</span> <span class=\"fn\">w</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.mkHom\">CategoryTheory.Limits.Fork.mkHom</a> <span class=\"fn\"><span class=\"fn\">i</span>.hom</span> <span class=\"fn\">w</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L675-L681","name":"CategoryTheory.Limits.Fork.mkHom","line":675,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.mkHom","doc":"Helper function for constructing morphisms between equalizer forks.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.mkHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">mkHom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L674-L674","name":"CategoryTheory.Limits.Fork.mkHom_hom","line":674,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.mkHom_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.mkHom_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">mkHom_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.mkHom\">CategoryTheory.Limits.Fork.mkHom</a> <span class=\"fn\">k</span> <span class=\"fn\">w</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L667-L669","name":"CategoryTheory.Limits.Cofork.π_precompose","line":667,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π_precompose","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π_precompose\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">π_precompose</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f' : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g' : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f'</span> <span class=\"fn\">g'</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f'</span> <span class=\"fn\">g'</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocones.precompose\">CategoryTheory.Limits.Cocones.precompose</a> <span class=\"fn\">α</span></span>)</span>.obj</span> <span class=\"fn\">c</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">c</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L661-L663","name":"CategoryTheory.Limits.Fork.ι_postcompose","line":661,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι_postcompose","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι_postcompose\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">ι_postcompose</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f' : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g' : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f'</span> <span class=\"fn\">g'</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cones.postcompose\">CategoryTheory.Limits.Cones.postcompose</a> <span class=\"fn\">α</span></span>)</span>.obj</span> <span class=\"fn\">c</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">c</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L656-L657","name":"CategoryTheory.Limits.Cofork.ofCocone_ι","line":656,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofCocone_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofCocone_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">ofCocone_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofCocone\">CategoryTheory.Limits.Cofork.ofCocone</a> <span class=\"fn\">t</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L651-L652","name":"CategoryTheory.Limits.Fork.ofCone_π","line":651,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofCone_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofCone_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">ofCone_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone\">CategoryTheory.Limits.Cone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofCone\">CategoryTheory.Limits.Fork.ofCone</a> <span class=\"fn\">t</span></span>)</span>.π</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L643-L647","name":"CategoryTheory.Limits.Cofork.ofCocone","line":643,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofCocone","doc":"Given `F : WalkingParallelPair ⥤ C`, which is really the same as\n`parallelPair (F.map left) (F.map right)` and a cocone on `F`, we get a cofork on\n`F.map left` and `F.map right`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofCocone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">ofCocone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L633-L637","name":"CategoryTheory.Limits.Fork.ofCone","line":633,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofCone","doc":"Given `F : WalkingParallelPair ⥤ C`, which is really the same as\n`parallelPair (F.map left) (F.map right)` and a cone on `F`, we get a fork on\n`F.map left` and `F.map right`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofCone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">ofCone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone\">CategoryTheory.Limits.Cone</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L626-L627","name":"CategoryTheory.Limits.Cocone.ofCofork_ι","line":626,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cocone.ofCofork_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cocone.ofCofork_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cocone</span>.<span class=\"name\">ofCofork_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cocone.ofCofork\">CategoryTheory.Limits.Cocone.ofCofork</a> <span class=\"fn\">t</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L621-L622","name":"CategoryTheory.Limits.Cone.ofFork_π","line":621,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cone.ofFork_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cone.ofFork_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cone</span>.<span class=\"name\">ofFork_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cone.ofFork\">CategoryTheory.Limits.Cone.ofFork</a> <span class=\"fn\">t</span></span>)</span>.π</span>.app</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L612-L617","name":"CategoryTheory.Limits.Cocone.ofCofork","line":612,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cocone.ofCofork","doc":"This is a helper construction that can be useful when verifying that a category has all\ncoequalizers. Given `F : WalkingParallelPair ⥤ C`, which is really the same as\n`parallelPair (F.map left) (F.map right)`, and a cofork on `F.map left` and `F.map right`,\nwe get a cocone on `F`.\n\nIf you're thinking about using this, have a look at\n`hasCoequalizers_of_hasColimit_parallelPair`, which you may find to be an easier way of\nachieving your goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cocone.ofCofork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cocone</span>.<span class=\"name\">ofCofork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L596-L601","name":"CategoryTheory.Limits.Cone.ofFork","line":596,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cone.ofFork","doc":"This is a helper construction that can be useful when verifying that a category has all\nequalizers. Given `F : WalkingParallelPair ⥤ C`, which is really the same as\n`parallelPair (F.map left) (F.map right)`, and a fork on `F.map left` and `F.map right`,\nwe get a cone on `F`.\n\nIf you're thinking about using this, have a look at `hasEqualizers_of_hasLimit_parallelPair`,\nwhich you may find to be an easier way of achieving your goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cone.ofFork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cone</span>.<span class=\"name\">ofFork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone\">CategoryTheory.Limits.Cone</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L582-L586","name":"CategoryTheory.Limits.Cofork.IsColimit.homIso_natural","line":582,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso_natural","doc":"The bijection of `Cofork.IsColimit.homIso` is natural in `Z`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso_natural\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso_natural</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(q : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso\">CategoryTheory.Limits.Cofork.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z'</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">q</span></span>)</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso\">CategoryTheory.Limits.Cofork.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span>)</span> <span class=\"fn\">q</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L573-L578","name":"CategoryTheory.Limits.Cofork.IsColimit.homIso","line":573,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso","doc":"Given a colimit cocone for the pair `f g : X ⟶ Y`, for any `Z`, morphisms from the cocone point\nto `Z` are in bijection with morphisms `h : Y ⟶ Z` such that `f ≫ h = g ≫ h`.\nFurther, this bijection is natural in `Z`: see `Cofork.IsColimit.homIso_natural`.\nThis is a special case of `IsColimit.homIso'`, often useful to construct adjunctions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span> // <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span></span> }</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L572-L572","name":"CategoryTheory.Limits.Cofork.IsColimit.homIso_apply_coe","line":572,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso_apply_coe","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso_apply_coe\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso_apply_coe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso\">CategoryTheory.Limits.Cofork.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">k</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L572-L572","name":"CategoryTheory.Limits.Cofork.IsColimit.homIso_symm_apply","line":572,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso_symm_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso_symm_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">homIso_symm_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span> // <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span></span> }</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.homIso\">CategoryTheory.Limits.Cofork.IsColimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span>.symm</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.desc'\">CategoryTheory.Limits.Cofork.IsColimit.desc'</a> <span class=\"fn\">ht</span> <span class=\"fn\">↑<span class=\"fn\">h</span></span> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L561-L564","name":"CategoryTheory.Limits.Fork.IsLimit.homIso_natural","line":561,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso_natural","doc":"The bijection of `Fork.IsLimit.homIso` is natural in `Z`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso_natural\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso_natural</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(q : <span class=\"fn\"><span class=\"fn\">Z'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso\">CategoryTheory.Limits.Fork.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z'</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">q</span> <span class=\"fn\">k</span></span>)</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">q</span> <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso\">CategoryTheory.Limits.Fork.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L552-L557","name":"CategoryTheory.Limits.Fork.IsLimit.homIso","line":552,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso","doc":"Given a limit cone for the pair `f g : X ⟶ Y`, for any `Z`, morphisms from `Z` to its point are in\nbijection with morphisms `h : Z ⟶ X` such that `h ≫ f = h ≫ g`.\nFurther, this bijection is natural in `Z`: see `Fork.IsLimit.homIso_natural`.\nThis is a special case of `IsLimit.homIso'`, often useful to construct adjunctions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">g</span></span></span> }</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L551-L551","name":"CategoryTheory.Limits.Fork.IsLimit.homIso_symm_apply","line":551,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso_symm_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso_symm_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso_symm_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">{ <span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">h</span> <span class=\"fn\">g</span></span></span> }</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso\">CategoryTheory.Limits.Fork.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span>.symm</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift'\">CategoryTheory.Limits.Fork.IsLimit.lift'</a> <span class=\"fn\">ht</span> <span class=\"fn\">↑<span class=\"fn\">h</span></span> <span class=\"fn\">⋯</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L551-L551","name":"CategoryTheory.Limits.Fork.IsLimit.homIso_apply_coe","line":551,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso_apply_coe","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso_apply_coe\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">homIso_apply_coe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ht : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Z : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.homIso\">CategoryTheory.Limits.Fork.IsLimit.homIso</a> <span class=\"fn\">ht</span> <span class=\"fn\">Z</span></span>)</span> <span class=\"fn\">k</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L539-L542","name":"CategoryTheory.Limits.Cofork.IsColimit.ofExistsUnique","line":539,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.ofExistsUnique","doc":"Noncomputably make a colimit cocone from the existence of unique factorizations. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.ofExistsUnique\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">ofExistsUnique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>),\n  <span class=\"fn\">∃! (<span class=\"fn\">d</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L532-L535","name":"CategoryTheory.Limits.Fork.IsLimit.ofExistsUnique","line":532,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.ofExistsUnique","doc":"Noncomputably make a limit cone from the existence of unique factorizations. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.ofExistsUnique\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">ofExistsUnique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>),\n  <span class=\"fn\">∃! (<span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L524-L528","name":"CategoryTheory.Limits.Cofork.IsColimit.mk'","line":524,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.mk'","doc":"This is another convenient method to verify that a fork is a limit cone. It\nonly asks for a proof of facts that carry any mathematical content, and allows access to the\nsame `s` for all parts. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.mk'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">mk'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(create : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>) →\n  <span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span> //\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">l</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span></span> <a href=\"./Init/Prelude.html#And\">∧</a>       <span class=\"fn\">∀\n        {<span class=\"fn\">m</span> :\n          <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n              <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>             <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n              <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span></span>},\n        <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">m</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span></span> →\n          <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></span></span></span> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L511-L518","name":"CategoryTheory.Limits.Cofork.IsColimit.mk","line":511,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.mk","doc":"This is a slightly more convenient method to verify that a cofork is a colimit cocone. It\nonly asks for a proof of facts that carry any mathematical content "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.mk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(desc : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fac : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">desc</span> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(uniq : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>) (<span class=\"fn\">m</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">m</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span></span> →\n    <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">desc</span> <span class=\"fn\">s</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L504-L506","name":"CategoryTheory.Limits.Fork.IsLimit.mk'","line":504,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.mk'","doc":"This is another convenient method to verify that a fork is a limit cone. It\nonly asks for a proof of facts that carry any mathematical content, and allows access to the\nsame `s` for all parts. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.mk'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">mk'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(create : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>) →\n  <span class=\"fn\">{ <span class=\"fn\">l</span> :\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n        <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>       <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n        <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span></span> //\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span> <a href=\"./Init/Prelude.html#And\">∧</a>       <span class=\"fn\">∀\n        {<span class=\"fn\">m</span> :\n          <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n              <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>             <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n              <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span></span>},\n        <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">m</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></span></span></span> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L491-L498","name":"CategoryTheory.Limits.Fork.IsLimit.mk","line":491,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.mk","doc":"This is a slightly more convenient method to verify that a fork is a limit cone. It\nonly asks for a proof of facts that carry any mathematical content "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.mk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lift : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fac : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">lift</span> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(uniq : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>) (<span class=\"fn\">m</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">m</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">lift</span> <span class=\"fn\">s</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L490-L490","name":"CategoryTheory.Limits.Fork.IsLimit.mk_lift","line":490,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.mk_lift","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.mk_lift\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">mk_lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lift : <span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fac : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">lift</span> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(uniq : <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>) (<span class=\"fn\">m</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">m</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span></span> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">lift</span> <span class=\"fn\">s</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.mk\">CategoryTheory.Limits.Fork.IsLimit.mk</a> <span class=\"fn\">t</span> <span class=\"fn\">lift</span> <span class=\"fn\">fac</span> <span class=\"fn\">uniq</span></span>)</span>.lift</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">lift</span> <span class=\"fn\">s</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L482-L485","name":"CategoryTheory.Limits.Cofork.IsColimit.existsUnique","line":482,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.existsUnique","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.existsUnique\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">existsUnique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">k</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃! (<span class=\"fn\">d</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L476-L479","name":"CategoryTheory.Limits.Fork.IsLimit.existsUnique","line":476,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.existsUnique","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.existsUnique\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">existsUnique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃! (<span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L471-L473","name":"CategoryTheory.Limits.Cofork.IsColimit.desc'","line":471,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.desc'","doc":"If `s` is a colimit cofork over `f` and `g`, then a morphism `k : Y ⟶ W` satisfying\n`f ≫ k = g ≫ k` induces a morphism `l : s.pt ⟶ W` such that `cofork.π s ≫ l = k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.desc'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">desc'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">k</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span> // <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">l</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L465-L467","name":"CategoryTheory.Limits.Cofork.IsColimit.π_desc'","line":465,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.π_desc'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.π_desc'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">π_desc'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">k</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.desc\">CategoryTheory.Limits.Cofork.IsColimit.desc</a> <span class=\"fn\">hs</span> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L464-L464","name":"CategoryTheory.Limits.Cofork.IsColimit.π_desc'_assoc","line":464,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.π_desc'_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.π_desc'_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">π_desc'_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">k</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.desc\">CategoryTheory.Limits.Cofork.IsColimit.desc</a> <span class=\"fn\">hs</span> <span class=\"fn\">k</span> <span class=\"fn\">h✝</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L460-L462","name":"CategoryTheory.Limits.Cofork.IsColimit.desc","line":460,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.desc","doc":"If `s` is a colimit cofork over `f` and `g`, then a morphism `k : Y ⟶ W` satisfying\n`f ≫ k = g ≫ k` induces a morphism `l : s.pt ⟶ W` such that `cofork.π s ≫ l = k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.desc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">desc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">k</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L452-L454","name":"CategoryTheory.Limits.Fork.IsLimit.lift'","line":452,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift'","doc":"If `s` is a limit fork over `f` and `g`, then a morphism `k : W ⟶ X` satisfying\n`k ≫ f = k ≫ g` induces a morphism `l : W ⟶ s.pt` such that `l ≫ fork.ι s = k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">lift'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">l</span> : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span> // <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L446-L448","name":"CategoryTheory.Limits.Fork.IsLimit.lift_ι'","line":446,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift_ι'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift_ι'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">lift_ι'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift\">CategoryTheory.Limits.Fork.IsLimit.lift</a> <span class=\"fn\">hs</span> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L445-L445","name":"CategoryTheory.Limits.Fork.IsLimit.lift_ι'_assoc","line":445,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift_ι'_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift_ι'_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">lift_ι'_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift\">CategoryTheory.Limits.Fork.IsLimit.lift</a> <span class=\"fn\">hs</span> <span class=\"fn\">k</span> <span class=\"fn\">h✝</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L441-L443","name":"CategoryTheory.Limits.Fork.IsLimit.lift","line":441,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift","doc":"If `s` is a limit fork over `f` and `g`, then a morphism `k : W ⟶ X` satisfying\n`k ≫ f = k ≫ g` induces a morphism `l : W ⟶ s.pt` such that `l ≫ fork.ι s = k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L434-L435","name":"CategoryTheory.Limits.Cofork.IsColimit.π_desc","line":434,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.π_desc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.π_desc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">π_desc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">hs</span>.desc</span> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L433-L433","name":"CategoryTheory.Limits.Cofork.IsColimit.π_desc_assoc","line":433,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.π_desc_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.π_desc_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">π_desc_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">hs</span>.desc</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L429-L430","name":"CategoryTheory.Limits.Fork.IsLimit.lift_ι","line":429,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">lift_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">hs</span>.lift</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L428-L428","name":"CategoryTheory.Limits.Fork.IsLimit.lift_ι_assoc","line":428,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift_ι_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.lift_ι_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">lift_ι_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">hs</span>.lift</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L423-L425","name":"CategoryTheory.Limits.Cofork.IsColimit.hom_ext","line":423,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.hom_ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.IsColimit.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">IsColimit</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">l</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L418-L420","name":"CategoryTheory.Limits.Fork.IsLimit.hom_ext","line":418,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.hom_ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.IsLimit.hom_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">IsLimit</span>.<span class=\"name\">hom_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L412-L415","name":"CategoryTheory.Limits.Cofork.coequalizer_ext","line":412,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.coequalizer_ext","doc":"To check whether two maps are coequalized by both maps of a cofork, it suffices to check it for\nthe second map "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.coequalizer_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">coequalizer_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.pt</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">W</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">l</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <span class=\"fn\">j</span></span>)</span> <span class=\"fn\">l</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L401-L407","name":"CategoryTheory.Limits.Fork.equalizer_ext","line":401,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.equalizer_ext","doc":"To check whether two maps are equalized by both maps of a fork, it suffices to check it for the\nfirst map "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.equalizer_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">equalizer_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{k : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><span class=\"fn\">W</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">l</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <span class=\"fn\">j</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L395-L396","name":"CategoryTheory.Limits.Cofork.condition","line":395,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L394-L394","name":"CategoryTheory.Limits.Cofork.condition_assoc","line":394,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n    <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L390-L391","name":"CategoryTheory.Limits.Fork.condition","line":390,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L389-L389","name":"CategoryTheory.Limits.Fork.condition_assoc","line":389,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.condition_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.condition_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">condition_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L385-L386","name":"CategoryTheory.Limits.Cofork.π_ofπ","line":385,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π_ofπ","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π_ofπ\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">π_ofπ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">π</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ\">CategoryTheory.Limits.Cofork.ofπ</a> <span class=\"fn\">π</span> <span class=\"fn\">w</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">π</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L380-L381","name":"CategoryTheory.Limits.Fork.ι_ofι","line":380,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι_ofι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι_ofι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">ι_ofι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">ι</span> <span class=\"fn\">w</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">ι</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L371-L375","name":"CategoryTheory.Limits.Cofork.ofπ","line":371,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ","doc":"A cofork on `f g : X ⟶ Y` is determined by the morphism `π : Y ⟶ P` satisfying\n`f ≫ π = g ≫ π`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">ofπ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">π</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L370-L370","name":"CategoryTheory.Limits.Cofork.ofπ_ι_app","line":370,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ_ι_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ_ι_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">ofπ_ι_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">π</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ\">CategoryTheory.Limits.Cofork.ofπ</a> <span class=\"fn\">π</span> <span class=\"fn\">w</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.casesOn\">CategoryTheory.Limits.WalkingParallelPair.casesOn</a> <span class=\"fn\">X</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">π</span></span>)</span> <span class=\"fn\">π</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L370-L370","name":"CategoryTheory.Limits.Cofork.ofπ_pt","line":370,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ_pt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ_pt\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">ofπ_pt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">π</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ\">CategoryTheory.Limits.Cofork.ofπ</a> <span class=\"fn\">π</span> <span class=\"fn\">w</span></span>)</span>.pt</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">P</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L360-L365","name":"CategoryTheory.Limits.Fork.ofι","line":360,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι","doc":"A fork on `f g : X ⟶ Y` is determined by the morphism `ι : P ⟶ X` satisfying `ι ≫ f = ι ≫ g`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">ofι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L359-L359","name":"CategoryTheory.Limits.Fork.ofι_π_app","line":359,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι_π_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι_π_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">ofι_π_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X✝</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">ι</span> <span class=\"fn\">w</span></span>)</span>.π</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.casesOn\">CategoryTheory.Limits.WalkingParallelPair.casesOn</a> (motive := <span class=\"fn\">fun (<span class=\"fn\">t</span> : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>) =&gt;\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span> →\n      <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span>)</span>.obj</span> <span class=\"fn\">P</span></span>)</span>.obj</span> <span class=\"fn\">X</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>         <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.obj</span> <span class=\"fn\">X</span></span></span>)</span></span></span>)\n    <span class=\"fn\">X</span> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span>) =&gt; <span class=\"fn\"><span class=\"fn\">⋯</span> ▸ <span class=\"fn\">ι</span></span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span>) =&gt; <span class=\"fn\"><span class=\"fn\">⋯</span> ▸ <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">f</span></span></span></span>)</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L359-L359","name":"CategoryTheory.Limits.Fork.ofι_pt","line":359,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι_pt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι_pt\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">ofι_pt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ι : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">ι</span> <span class=\"fn\">g</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">ι</span> <span class=\"fn\">w</span></span>)</span>.pt</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">P</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L353-L354","name":"CategoryTheory.Limits.Cofork.app_zero_eq_comp_π_right","line":353,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.app_zero_eq_comp_π_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.app_zero_eq_comp_π_right\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">app_zero_eq_comp_π_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L352-L352","name":"CategoryTheory.Limits.Cofork.app_zero_eq_comp_π_right_assoc","line":352,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.app_zero_eq_comp_π_right_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.app_zero_eq_comp_π_right_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">app_zero_eq_comp_π_right_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">s</span>.pt</span></span>)</span>.obj</span>\n    <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span>)</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L348-L349","name":"CategoryTheory.Limits.Cofork.app_zero_eq_comp_π_left","line":348,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.app_zero_eq_comp_π_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.app_zero_eq_comp_π_left\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">app_zero_eq_comp_π_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.ι</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">s</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L343-L344","name":"CategoryTheory.Limits.Fork.app_one_eq_ι_comp_right","line":343,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.app_one_eq_ι_comp_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.app_one_eq_ι_comp_right\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">app_one_eq_ι_comp_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L342-L342","name":"CategoryTheory.Limits.Fork.app_one_eq_ι_comp_right_assoc","line":342,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.app_one_eq_ι_comp_right_assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.app_one_eq_ι_comp_right_assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">app_one_eq_ι_comp_right_assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span>)</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L338-L339","name":"CategoryTheory.Limits.Fork.app_one_eq_ι_comp_left","line":338,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.app_one_eq_ι_comp_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.app_one_eq_ι_comp_left\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">app_one_eq_ι_comp_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.π</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L333-L334","name":"CategoryTheory.Limits.Cofork.app_one_eq_π","line":333,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.app_one_eq_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.app_one_eq_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">app_one_eq_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.ι</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\">t</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L328-L329","name":"CategoryTheory.Limits.Cofork.π","line":328,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π","doc":"A cofork `t` on the parallelPair `f g : X ⟶ Y` consists of two morphisms\n`t.ι.app zero : X ⟶ t.pt` and `t.ι.app one : Y ⟶ t.pt`. Of these, only the second one is\ninteresting, and we give it the shorter name `Cofork.π t`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span>.<span class=\"name\">π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\">CategoryTheory.Limits.Cofork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n    <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L321-L322","name":"CategoryTheory.Limits.Fork.app_zero_eq_ι","line":321,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.app_zero_eq_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.app_zero_eq_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">app_zero_eq_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">t</span>.π</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\">t</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L316-L317","name":"CategoryTheory.Limits.Fork.ι","line":316,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι","doc":"A fork `t` on the parallel pair `f g : X ⟶ Y` consists of two morphisms\n`t.π.app zero : t.pt ⟶ X`\nand `t.π.app one : t.pt ⟶ Y`. Of these, only the first one is interesting, and we give it the\nshorter name `Fork.ι t`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span>.<span class=\"name\">ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\">CategoryTheory.Limits.Fork</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const\">CategoryTheory.Functor.const</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span>)</span>.obj</span> <span class=\"fn\"><span class=\"fn\">t</span>.pt</span></span>)</span>.obj</span>\n    <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L306-L307","name":"CategoryTheory.Limits.Cofork","line":306,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork","doc":"A cofork on `f` and `g` is just a `Cocone (parallelPair f g)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Cofork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u v)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L301-L302","name":"CategoryTheory.Limits.Fork","line":301,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork","doc":"A fork on `f` and `g` is just a `Cone (parallelPair f g)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Fork</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u v)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L295-L297","name":"CategoryTheory.Limits.parallelPair.eqOfHomEq","line":295,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.eqOfHomEq","doc":"Construct a natural isomorphism between `parallelPair f g` and `parallelPair f' g'` given\nequalities `f = f'` and `g = g'`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.eqOfHomEq\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair</span>.<span class=\"name\">eqOfHomEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f' : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g' : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f'</span> <span class=\"fn\">g'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L294-L294","name":"CategoryTheory.Limits.parallelPair.eqOfHomEq_inv_app","line":294,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.eqOfHomEq_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.eqOfHomEq_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair</span>.<span class=\"name\">eqOfHomEq_inv_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f' : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g' : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.eqOfHomEq\">CategoryTheory.Limits.parallelPair.eqOfHomEq</a> <span class=\"fn\">hf</span> <span class=\"fn\">hg</span></span>)</span>.inv</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.rec\">CategoryTheory.Limits.WalkingParallelPair.rec</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">CategoryTheory.Iso.refl</a> <span class=\"fn\">X✝</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">CategoryTheory.Iso.refl</a> <span class=\"fn\">Y</span></span>)</span> <span class=\"fn\">X</span></span>)</span>.inv</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L294-L294","name":"CategoryTheory.Limits.parallelPair.eqOfHomEq_hom_app","line":294,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.eqOfHomEq_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.eqOfHomEq_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair</span>.<span class=\"name\">eqOfHomEq_hom_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f' : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g' : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.eqOfHomEq\">CategoryTheory.Limits.parallelPair.eqOfHomEq</a> <span class=\"fn\">hf</span> <span class=\"fn\">hg</span></span>)</span>.hom</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.rec\">CategoryTheory.Limits.WalkingParallelPair.rec</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">CategoryTheory.Iso.refl</a> <span class=\"fn\">X✝</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">CategoryTheory.Iso.refl</a> <span class=\"fn\">Y</span></span>)</span> <span class=\"fn\">X</span></span>)</span>.hom</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L282-L289","name":"CategoryTheory.Limits.parallelPair.ext","line":282,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.ext","doc":"Construct a natural isomorphism between functors out of the walking parallel pair from\nits components. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(zero : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(one : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(left : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span> <span class=\"fn\"><span class=\"fn\">one</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">zero</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(right : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span> <span class=\"fn\"><span class=\"fn\">one</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">zero</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">G</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L281-L281","name":"CategoryTheory.Limits.parallelPair.ext_hom_app","line":281,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.ext_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.ext_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair</span>.<span class=\"name\">ext_hom_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(zero : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(one : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(left : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span> <span class=\"fn\"><span class=\"fn\">one</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">zero</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(right : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span> <span class=\"fn\"><span class=\"fn\">one</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">zero</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.ext\">CategoryTheory.Limits.parallelPair.ext</a> <span class=\"fn\">zero</span> <span class=\"fn\">one</span> <span class=\"fn\">left</span> <span class=\"fn\">right</span></span>)</span>.hom</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.rec\">CategoryTheory.Limits.WalkingParallelPair.rec</a> <span class=\"fn\">zero</span> <span class=\"fn\">one</span> <span class=\"fn\">X</span></span>)</span>.hom</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L281-L281","name":"CategoryTheory.Limits.parallelPair.ext_inv_app","line":281,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.ext_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.ext_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair</span>.<span class=\"name\">ext_inv_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(zero : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(one : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(left : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span> <span class=\"fn\"><span class=\"fn\">one</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">zero</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(right : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span> <span class=\"fn\"><span class=\"fn\">one</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">zero</span>.hom</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair.ext\">CategoryTheory.Limits.parallelPair.ext</a> <span class=\"fn\">zero</span> <span class=\"fn\">one</span> <span class=\"fn\">left</span> <span class=\"fn\">right</span></span>)</span>.inv</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.rec\">CategoryTheory.Limits.WalkingParallelPair.rec</a> <span class=\"fn\">zero</span> <span class=\"fn\">one</span> <span class=\"fn\">X</span></span>)</span>.inv</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L273-L276","name":"CategoryTheory.Limits.parallelPairHom_app_one","line":273,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPairHom_app_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPairHom_app_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPairHom_app_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f' : <span class=\"fn\"><span class=\"fn\">X'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g' : <span class=\"fn\"><span class=\"fn\">X'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(q : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(wf : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">q</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">p</span> <span class=\"fn\">f'</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(wg : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">q</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">p</span> <span class=\"fn\">g'</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPairHom\">CategoryTheory.Limits.parallelPairHom</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">f'</span> <span class=\"fn\">g'</span> <span class=\"fn\">p</span> <span class=\"fn\">q</span> <span class=\"fn\">wf</span> <span class=\"fn\">wg</span></span>)</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">q</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L266-L269","name":"CategoryTheory.Limits.parallelPairHom_app_zero","line":266,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPairHom_app_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPairHom_app_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPairHom_app_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f' : <span class=\"fn\"><span class=\"fn\">X'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g' : <span class=\"fn\"><span class=\"fn\">X'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(q : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(wf : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">q</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">p</span> <span class=\"fn\">f'</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(wg : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">q</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">p</span> <span class=\"fn\">g'</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPairHom\">CategoryTheory.Limits.parallelPairHom</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">f'</span> <span class=\"fn\">g'</span> <span class=\"fn\">p</span> <span class=\"fn\">q</span> <span class=\"fn\">wf</span> <span class=\"fn\">wg</span></span>)</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L254-L262","name":"CategoryTheory.Limits.parallelPairHom","line":254,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPairHom","doc":"Construct a morphism between parallel pairs. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPairHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPairHom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y' : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f' : <span class=\"fn\"><span class=\"fn\">X'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g' : <span class=\"fn\"><span class=\"fn\">X'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(q : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(wf : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">q</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">p</span> <span class=\"fn\">f'</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(wg : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">q</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">p</span> <span class=\"fn\">g'</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f'</span> <span class=\"fn\">g'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L248-L250","name":"CategoryTheory.Limits.diagramIsoParallelPair","line":248,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.diagramIsoParallelPair","doc":"Every functor indexing a (co)equalizer is naturally isomorphic (actually, equal) to a\n`parallelPair` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.diagramIsoParallelPair\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">diagramIsoParallelPair</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L247-L247","name":"CategoryTheory.Limits.diagramIsoParallelPair_hom_app","line":247,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.diagramIsoParallelPair_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.diagramIsoParallelPair_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">diagramIsoParallelPair_hom_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.diagramIsoParallelPair\">CategoryTheory.Limits.diagramIsoParallelPair</a> <span class=\"fn\">F</span></span>)</span>.hom</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L247-L247","name":"CategoryTheory.Limits.diagramIsoParallelPair_inv_app","line":247,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.diagramIsoParallelPair_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.diagramIsoParallelPair_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">diagramIsoParallelPair_inv_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.diagramIsoParallelPair\">CategoryTheory.Limits.diagramIsoParallelPair</a> <span class=\"fn\">F</span></span>)</span>.inv</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L241-L242","name":"CategoryTheory.Limits.parallelPair_functor_obj","line":241,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair_functor_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair_functor_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair_functor_obj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span>)</span>\n        <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span>)</span></span>)</span>.obj</span>\n    <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">j</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L237-L237","name":"CategoryTheory.Limits.parallelPair_map_right","line":237,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair_map_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair_map_right\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair_map_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L233-L233","name":"CategoryTheory.Limits.parallelPair_map_left","line":233,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair_map_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair_map_left\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair_map_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L229-L229","name":"CategoryTheory.Limits.parallelPair_obj_one","line":229,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair_obj_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair_obj_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair_obj_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L225-L225","name":"CategoryTheory.Limits.parallelPair_obj_zero","line":225,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair_obj_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair_obj_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair_obj_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L209-L221","name":"CategoryTheory.Limits.parallelPair","line":209,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair","doc":"`parallelPair f g` is the diagram in `C` consisting of the two morphisms `f` and `g` with\ncommon domain and codomain. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">parallelPair</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L199-L201","name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_counitIso_one","line":199,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_counitIso_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_counitIso_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOpEquiv_counitIso_one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv\">CategoryTheory.Limits.walkingParallelPairOpEquiv</a>.counitIso</span>.app</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">CategoryTheory.Iso.refl</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L194-L195","name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_counitIso_zero","line":194,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_counitIso_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_counitIso_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOpEquiv_counitIso_zero</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv\">CategoryTheory.Limits.walkingParallelPairOpEquiv</a>.counitIso</span>.app</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">CategoryTheory.Iso.refl</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L189-L190","name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_unitIso_one","line":189,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_unitIso_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_unitIso_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOpEquiv_unitIso_one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv\">CategoryTheory.Limits.walkingParallelPairOpEquiv</a>.unitIso</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">CategoryTheory.Iso.refl</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L184-L185","name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_unitIso_zero","line":184,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_unitIso_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_unitIso_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOpEquiv_unitIso_zero</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv\">CategoryTheory.Limits.walkingParallelPairOpEquiv</a>.unitIso</span>.app</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">CategoryTheory.Iso.refl</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L163-L180","name":"CategoryTheory.Limits.walkingParallelPairOpEquiv","line":163,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv","doc":"The equivalence `WalkingParallelPair ⥤ WalkingParallelPairᵒᵖ` sending left to left and right to\nright.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOpEquiv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L162-L162","name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_functor","line":162,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_functor","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_functor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOpEquiv_functor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv\">CategoryTheory.Limits.walkingParallelPairOpEquiv</a>.functor</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp\">CategoryTheory.Limits.walkingParallelPairOp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L162-L162","name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_inverse","line":162,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_inverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv_inverse\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOpEquiv_inverse</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOpEquiv\">CategoryTheory.Limits.walkingParallelPairOpEquiv</a>.inverse</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp\">CategoryTheory.Limits.walkingParallelPairOp</a>.leftOp</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L154-L155","name":"CategoryTheory.Limits.walkingParallelPairOp_right","line":154,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp_right\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOp_right</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp\">CategoryTheory.Limits.walkingParallelPairOp</a>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\">CategoryTheory.Limits.WalkingParallelPairHom.right</a>.op</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L149-L150","name":"CategoryTheory.Limits.walkingParallelPairOp_left","line":149,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp_left\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOp_left</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp\">CategoryTheory.Limits.walkingParallelPairOp</a>.map</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\">CategoryTheory.Limits.WalkingParallelPairHom.left</a>.op</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L145-L145","name":"CategoryTheory.Limits.walkingParallelPairOp_one","line":145,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp_one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp_one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOp_one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp\">CategoryTheory.Limits.walkingParallelPairOp</a>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L141-L141","name":"CategoryTheory.Limits.walkingParallelPairOp_zero","line":141,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOp_zero</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp\">CategoryTheory.Limits.walkingParallelPairOp</a>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L132-L137","name":"CategoryTheory.Limits.walkingParallelPairOp","line":132,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp","doc":"The functor `WalkingParallelPair ⥤ WalkingParallelPairᵒᵖ` sending left to left and right to\nright.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairOp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairOp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L126-L127","name":"CategoryTheory.Limits.WalkingParallelPairHom.id.sizeOf_spec'","line":126,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.id.sizeOf_spec'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.id.sizeOf_spec'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPairHom</span>.<span class=\"name\">id</span>.<span class=\"name\">sizeOf_spec'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/SizeOf.html#SizeOf.sizeOf\">sizeOf</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">1</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Init/SizeOf.html#SizeOf.sizeOf\">sizeOf</a> <span class=\"fn\">X</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L120-L121","name":"CategoryTheory.Limits.walkingParallelPairHom_id","line":120,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairHom_id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairHom_id\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairHom_id</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.id\">CategoryTheory.Limits.WalkingParallelPairHom.id</a> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L110-L116","name":"CategoryTheory.Limits.walkingParallelPairHomCategory","line":110,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairHomCategory","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.walkingParallelPairHomCategory\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">walkingParallelPairHomCategory</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory\">CategoryTheory.SmallCategory</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L105-L108","name":"CategoryTheory.Limits.WalkingParallelPairHom.assoc","line":105,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.assoc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.assoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPairHom</span>.<span class=\"name\">assoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{W : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <span class=\"fn\">Y</span> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <span class=\"fn\">Z</span> <span class=\"fn\">W</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.comp\">CategoryTheory.Limits.WalkingParallelPairHom.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.comp\">CategoryTheory.Limits.WalkingParallelPairHom.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.comp\">CategoryTheory.Limits.WalkingParallelPairHom.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.comp\">CategoryTheory.Limits.WalkingParallelPairHom.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L101-L103","name":"CategoryTheory.Limits.WalkingParallelPairHom.comp_id","line":101,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.comp_id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.comp_id\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPairHom</span>.<span class=\"name\">comp_id</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.comp\">CategoryTheory.Limits.WalkingParallelPairHom.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.id\">CategoryTheory.Limits.WalkingParallelPairHom.id</a> <span class=\"fn\">Y</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L97-L99","name":"CategoryTheory.Limits.WalkingParallelPairHom.id_comp","line":97,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.id_comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.id_comp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPairHom</span>.<span class=\"name\">id_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.comp\">CategoryTheory.Limits.WalkingParallelPairHom.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.id\">CategoryTheory.Limits.WalkingParallelPairHom.id</a> <span class=\"fn\">X</span></span>)</span> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L87-L93","name":"CategoryTheory.Limits.WalkingParallelPairHom.comp","line":87,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.comp","doc":"Composition of morphisms in the indexing diagram for (co)equalizers. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.comp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPairHom</span>.<span class=\"name\">comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <span class=\"fn\">Y</span> <span class=\"fn\">Z</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <span class=\"fn\">X</span> <span class=\"fn\">Z</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L82-L82","name":"CategoryTheory.Limits.instInhabitedWalkingParallelPairHomZeroOne","line":82,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.instInhabitedWalkingParallelPairHomZeroOne","doc":"Satisfying the inhabited linter "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.instInhabitedWalkingParallelPairHomZeroOne\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">instInhabitedWalkingParallelPairHomZeroOne</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>\n    <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L74-L74","name":"CategoryTheory.Limits.instDecidableEqWalkingParallelPairHom","line":74,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.instDecidableEqWalkingParallelPairHom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.instDecidableEqWalkingParallelPairHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">instDecidableEqWalkingParallelPairHom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{<span class=\"fn\">a </span>a_1 : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>} → <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <span class=\"fn\">a</span> <span class=\"fn\">a_1</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L73-L73","name":"CategoryTheory.Limits.WalkingParallelPairHom.id","line":73,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.id\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPairHom</span>.<span class=\"name\">id</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <span class=\"fn\">X</span> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L72-L72","name":"CategoryTheory.Limits.WalkingParallelPairHom.right","line":72,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.right\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPairHom</span>.<span class=\"name\">right</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L71-L71","name":"CategoryTheory.Limits.WalkingParallelPairHom.left","line":71,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom.left\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPairHom</span>.<span class=\"name\">left</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\">CategoryTheory.Limits.WalkingParallelPairHom</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>\n  <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L70-L74","name":"CategoryTheory.Limits.WalkingParallelPairHom","line":70,"kind":"inductive","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom","doc":"The type family of morphisms for the diagram indexing a (co)equalizer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPairHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPairHom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> → <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a> → <a href=\"./foundational_types.html\">Type</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L64-L64","name":"CategoryTheory.Limits.instInhabitedWalkingParallelPair","line":64,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.instInhabitedWalkingParallelPair","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.instInhabitedWalkingParallelPair\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">instInhabitedWalkingParallelPair</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L64-L64","name":"CategoryTheory.Limits.instDecidableEqWalkingParallelPair","line":64,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.instDecidableEqWalkingParallelPair","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.instDecidableEqWalkingParallelPair\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">instDecidableEqWalkingParallelPair</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L63-L63","name":"CategoryTheory.Limits.WalkingParallelPair.one","line":63,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPair</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L62-L62","name":"CategoryTheory.Limits.WalkingParallelPair.zero","line":62,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPair</span>.<span class=\"name\">zero</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\">CategoryTheory.Limits.WalkingParallelPair</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L61-L64","name":"CategoryTheory.Limits.WalkingParallelPair","line":61,"kind":"inductive","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair","doc":"The type of objects for the diagram indexing a (co)equalizer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">WalkingParallelPair</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}