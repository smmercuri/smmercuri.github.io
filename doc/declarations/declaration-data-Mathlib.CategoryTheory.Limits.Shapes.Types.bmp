{"name":"Mathlib.CategoryTheory.Limits.Shapes.Types","instances":[{"typeNames":["CategoryTheory.Discrete","_builtin_typeu"],"name":"CategoryTheory.Limits.Types.instHasProductsTypeTypes","className":"CategoryTheory.Limits.HasLimitsOfShape"},{"typeNames":["CategoryTheory.Limits.terminal"],"name":"CategoryTheory.Limits.Types.instInhabitedTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self","className":"Inhabited"},{"typeNames":["CategoryTheory.Limits.terminal"],"name":"CategoryTheory.Limits.Types.instSubsingletonTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self","className":"Subsingleton"},{"typeNames":["CategoryTheory.Limits.terminal"],"name":"CategoryTheory.Limits.Types.instUniqueTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self","className":"Unique"},{"typeNames":["_builtin_typeu"],"name":"CategoryTheory.Limits.Types.instHasPullbacksTypeTypes","className":"CategoryTheory.Limits.HasLimitsOfShape"},{"typeNames":["_builtin_typeu"],"name":"CategoryTheory.Limits.Types.instHasPushoutsTypeTypes","className":"CategoryTheory.Limits.HasColimitsOfShape"}],"imports":["Init","Mathlib.CategoryTheory.Limits.Types","Mathlib.CategoryTheory.Limits.Shapes.Products","Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","Mathlib.CategoryTheory.Limits.Shapes.Terminal","Mathlib.CategoryTheory.ConcreteCategory.Basic","Mathlib.Tactic.CategoryTheory.Elementwise","Mathlib.Data.Set.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L921-L928","name":"CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_iff_of_isColimit","line":921,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_iff_of_isColimit","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_iff_of_isColimit\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pushoutCocone_inl_eq_inr_iff_of_isColimit</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone\">CategoryTheory.Limits.PushoutCocone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hc : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><a href=\"./Mathlib/Init/Function.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x₁ : <span class=\"fn\">X₁</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x₂ : <span class=\"fn\">X₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone.inl\">CategoryTheory.Limits.PushoutCocone.inl</a> <span class=\"fn\">c</span> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone.inr\">CategoryTheory.Limits.PushoutCocone.inr</a> <span class=\"fn\">c</span> <span class=\"fn\">x₂</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\">∃ (s : <span class=\"fn\">S</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x₂</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L914-L919","name":"CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_iff_of_iso","line":914,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_iff_of_iso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_iff_of_iso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pushoutCocone_inl_eq_inr_iff_of_iso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone\">CategoryTheory.Limits.PushoutCocone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c' : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone\">CategoryTheory.Limits.PushoutCocone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">c'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x₁ : <span class=\"fn\">X₁</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x₂ : <span class=\"fn\">X₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone.inl\">CategoryTheory.Limits.PushoutCocone.inl</a> <span class=\"fn\">c</span> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone.inr\">CategoryTheory.Limits.PushoutCocone.inr</a> <span class=\"fn\">c</span> <span class=\"fn\">x₂</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone.inl\">CategoryTheory.Limits.PushoutCocone.inl</a> <span class=\"fn\">c'</span> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone.inr\">CategoryTheory.Limits.PushoutCocone.inr</a> <span class=\"fn\">c'</span> <span class=\"fn\">x₂</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L907-L912","name":"CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_imp_of_iso","line":907,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_imp_of_iso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_imp_of_iso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pushoutCocone_inl_eq_inr_imp_of_iso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone\">CategoryTheory.Limits.PushoutCocone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c' : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone\">CategoryTheory.Limits.PushoutCocone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">c'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x₁ : <span class=\"fn\">X₁</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x₂ : <span class=\"fn\">X₂</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone.inl\">CategoryTheory.Limits.PushoutCocone.inl</a> <span class=\"fn\">c</span> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone.inr\">CategoryTheory.Limits.PushoutCocone.inr</a> <span class=\"fn\">c</span> <span class=\"fn\">x₂</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone.inl\">CategoryTheory.Limits.PushoutCocone.inl</a> <span class=\"fn\">c'</span> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone.inr\">CategoryTheory.Limits.PushoutCocone.inr</a> <span class=\"fn\">c'</span> <span class=\"fn\">x₂</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L893-L901","name":"CategoryTheory.Limits.Types.Pushout.inl_eq_inr_iff","line":893,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl_eq_inr_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl_eq_inr_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">inl_eq_inr_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x₁ : <span class=\"fn\">X₁</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x₂ : <span class=\"fn\">X₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl\">CategoryTheory.Limits.Types.Pushout.inl</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inr\">CategoryTheory.Limits.Types.Pushout.inr</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">x₂</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\">∃ (s : <span class=\"fn\">S</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x₂</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L887-L891","name":"CategoryTheory.Limits.Types.Pushout.quot_mk_eq_iff","line":887,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.quot_mk_eq_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.quot_mk_eq_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">quot_mk_eq_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><span class=\"fn\">X₁</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\"><span class=\"fn\">X₁</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Quot.mk\">Quot.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel\">CategoryTheory.Limits.Types.Pushout.Rel</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Quot.mk\">Quot.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel\">CategoryTheory.Limits.Types.Pushout.Rel</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">b</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\">CategoryTheory.Limits.Types.Pushout.Rel'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L866-L885","name":"CategoryTheory.Limits.Types.Pushout.equivPushout'","line":866,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.equivPushout'","doc":"The obvious equivalence `Pushout f g ≃ Pushout' f g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.equivPushout'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">equivPushout'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout\">CategoryTheory.Limits.Types.Pushout</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout'\">CategoryTheory.Limits.Types.Pushout'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L828-L863","name":"CategoryTheory.Limits.Types.Pushout.equivalence_rel'","line":828,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.equivalence_rel'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.equivalence_rel'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">equivalence_rel'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Equivalence\">Equivalence</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\">CategoryTheory.Limits.Types.Pushout.Rel'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L818-L824","name":"CategoryTheory.Limits.Types.Pushout.Rel'.symm","line":818,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'.symm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'.symm\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">Rel'</span>.<span class=\"name\">symm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><span class=\"fn\">X₁</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">X₂</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\"><span class=\"fn\">X₁</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">X₂</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\">CategoryTheory.Limits.Types.Pushout.Rel'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\">CategoryTheory.Limits.Types.Pushout.Rel'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">y</span> <span class=\"fn\">x</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L808-L814","name":"CategoryTheory.Limits.Types.Pushout.inr_rel'_inr_iff","line":808,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inr_rel'_inr_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inr_rel'_inr_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">inr_rel'_inr_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x₂ : <span class=\"fn\">X₂</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y₂ : <span class=\"fn\">X₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\">CategoryTheory.Limits.Types.Pushout.Rel'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inr\">Sum.inr</a> <span class=\"fn\">x₂</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inr\">Sum.inr</a> <span class=\"fn\">y₂</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y₂</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L798-L805","name":"CategoryTheory.Limits.Types.Pushout.inl_rel'_inr_iff","line":798,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl_rel'_inr_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl_rel'_inr_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">inl_rel'_inr_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x₁ : <span class=\"fn\">X₁</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x₂ : <span class=\"fn\">X₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\">CategoryTheory.Limits.Types.Pushout.Rel'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inl\">Sum.inl</a> <span class=\"fn\">x₁</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inr\">Sum.inr</a> <span class=\"fn\">x₂</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (s : <span class=\"fn\">S</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">s</span></span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">s</span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L786-L795","name":"CategoryTheory.Limits.Types.Pushout.inl_rel'_inl_iff","line":786,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl_rel'_inl_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl_rel'_inl_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">inl_rel'_inl_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x₁ : <span class=\"fn\">X₁</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y₁ : <span class=\"fn\">X₁</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\">CategoryTheory.Limits.Types.Pushout.Rel'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inl\">Sum.inl</a> <span class=\"fn\">x₁</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inl\">Sum.inl</a> <span class=\"fn\">y₁</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y₁</span></span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">∃ (x₀ : <span class=\"fn\">S</span>) (y₀ : <span class=\"fn\">S</span>) (_ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">x₀</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">y₀</span></span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x₀</span></span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\">y₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">y₀</span></span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L775-L783","name":"CategoryTheory.Limits.Types.Pushout.isColimitCocone","line":775,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.isColimitCocone","doc":"The cocone `cocone f g` is colimit. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.isColimitCocone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">isColimitCocone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.cocone\">CategoryTheory.Limits.Types.Pushout.cocone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L772-L772","name":"CategoryTheory.Limits.Types.Pushout.cocone","line":772,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.cocone","doc":"The constructed pushout cocone in the category of types. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.cocone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">cocone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PushoutCocone\">CategoryTheory.Limits.PushoutCocone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L771-L771","name":"CategoryTheory.Limits.Types.Pushout.cocone_pt","line":771,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.cocone_pt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.cocone_pt\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">cocone_pt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.cocone\">CategoryTheory.Limits.Types.Pushout.cocone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.pt</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout\">CategoryTheory.Limits.Types.Pushout</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L771-L771","name":"CategoryTheory.Limits.Types.Pushout.cocone_ι_app","line":771,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.cocone_ι_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.cocone_ι_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">cocone_ι_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.WalkingSpan\">CategoryTheory.Limits.WalkingSpan</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.span\">CategoryTheory.Limits.span</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.obj</span> <span class=\"fn\">j</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.cocone\">CategoryTheory.Limits.Types.Pushout.cocone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">j</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Init/Prelude.html#Option.rec\">Option.rec</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl\">CategoryTheory.Limits.Types.Pushout.inl</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>)</span>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">val</span> : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair\">CategoryTheory.Limits.WalkingPair</a>) =&gt;\n        <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.rec\">CategoryTheory.Limits.WalkingPair.rec</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl\">CategoryTheory.Limits.Types.Pushout.inl</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>\n          <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inr\">CategoryTheory.Limits.Types.Pushout.inr</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">val</span></span></span>)</span>\n      <span class=\"fn\">j</span> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L766-L768","name":"CategoryTheory.Limits.Types.Pushout.condition","line":766,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.condition","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl\">CategoryTheory.Limits.Types.Pushout.inl</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inr\">CategoryTheory.Limits.Types.Pushout.inr</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L764-L764","name":"CategoryTheory.Limits.Types.Pushout.inr","line":764,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inr","doc":"The right inclusion in the constructed pushout `Pushout f g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">inr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">X₂</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout\">CategoryTheory.Limits.Types.Pushout</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L760-L760","name":"CategoryTheory.Limits.Types.Pushout.inl","line":760,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl","doc":"The left inclusion in the constructed pushout `Pushout f g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.inl\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">inl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">X₁</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout\">CategoryTheory.Limits.Types.Pushout</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L754-L754","name":"CategoryTheory.Limits.Types.Pushout'","line":754,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout'","doc":"The quotient of `X₁ ⊕ X₂` by the relation `PushoutRel' f g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L751-L751","name":"CategoryTheory.Limits.Types.Pushout.Rel'.inr_inl","line":751,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'.inr_inl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'.inr_inl\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">Rel'</span>.<span class=\"name\">inr_inl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\">S</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\">CategoryTheory.Limits.Types.Pushout.Rel'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inr\">Sum.inr</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">s</span></span>)</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inl\">Sum.inl</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">s</span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L750-L750","name":"CategoryTheory.Limits.Types.Pushout.Rel'.inl_inr","line":750,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'.inl_inr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'.inl_inr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">Rel'</span>.<span class=\"name\">inl_inr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\">S</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\">CategoryTheory.Limits.Types.Pushout.Rel'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inl\">Sum.inl</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">s</span></span>)</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inr\">Sum.inr</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">s</span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L749-L749","name":"CategoryTheory.Limits.Types.Pushout.Rel'.inl_inl","line":749,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'.inl_inl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'.inl_inl\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">Rel'</span>.<span class=\"name\">inl_inl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x₀ : <span class=\"fn\">S</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y₀ : <span class=\"fn\">S</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">x₀</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">y₀</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\">CategoryTheory.Limits.Types.Pushout.Rel'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inl\">Sum.inl</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x₀</span></span>)</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inl\">Sum.inl</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">y₀</span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L748-L748","name":"CategoryTheory.Limits.Types.Pushout.Rel'.refl","line":748,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'.refl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'.refl\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">Rel'</span>.<span class=\"name\">refl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\">X₁</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\">CategoryTheory.Limits.Types.Pushout.Rel'</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">x</span> <span class=\"fn\">x</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L747-L751","name":"CategoryTheory.Limits.Types.Pushout.Rel'","line":747,"kind":"inductive","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'","doc":"In case `f : S ⟶ X₁` is a monomorphism, this relation is the equivalence relation\ngenerated by `Pushout.Rel f g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">Rel'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X₁</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">X₂</span></span> → <span class=\"fn\"><span class=\"fn\">X₁</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">X₂</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L743-L743","name":"CategoryTheory.Limits.Types.Pushout","line":743,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout","doc":"Construction of the pushout in the category of types, as a quotient of `X₁ ⊕ X₂`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L740-L740","name":"CategoryTheory.Limits.Types.Pushout.Rel.inl_inr","line":740,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel.inl_inr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel.inl_inr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">Rel</span>.<span class=\"name\">inl_inr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\">S</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel\">CategoryTheory.Limits.Types.Pushout.Rel</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inl\">Sum.inl</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">s</span></span>)</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#Sum.inr\">Sum.inr</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">s</span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L739-L740","name":"CategoryTheory.Limits.Types.Pushout.Rel","line":739,"kind":"inductive","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel","doc":"The pushout of two maps `f : S ⟶ X₁` and `g : S ⟶ X₂` is the quotient\nby the equivalence relation on `X₁ ⊕ X₂` generated by this relation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Pushout.Rel\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Pushout</span>.<span class=\"name\">Rel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X₁</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">X₂</span></span> → <span class=\"fn\"><span class=\"fn\">X₁</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">X₂</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L727-L729","name":"CategoryTheory.Limits.Types.pullbackIsoPullback_inv_snd_apply","line":727,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_inv_snd_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_inv_snd_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackIsoPullback_inv_snd_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackCone\">CategoryTheory.Limits.Types.pullbackCone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.pt</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.pullback.snd\">CategoryTheory.Limits.pullback.snd</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback\">CategoryTheory.Limits.Types.pullbackIsoPullback</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.inv</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackCone\">CategoryTheory.Limits.Types.pullbackCone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.pt</span>) =&gt; <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">p</span></span>)</span>.2</span></span>)</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L721-L723","name":"CategoryTheory.Limits.Types.pullbackIsoPullback_inv_snd","line":721,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_inv_snd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_inv_snd\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackIsoPullback_inv_snd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback\">CategoryTheory.Limits.Types.pullbackIsoPullback</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.inv</span>\n    <span class=\"fn\">CategoryTheory.Limits.pullback.snd</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">fun (<span class=\"fn\">p</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.PullbackObj\">CategoryTheory.Limits.Types.PullbackObj</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">p</span></span>)</span>.2</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L716-L718","name":"CategoryTheory.Limits.Types.pullbackIsoPullback_inv_fst_apply","line":716,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_inv_fst_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_inv_fst_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackIsoPullback_inv_fst_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackCone\">CategoryTheory.Limits.Types.pullbackCone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.pt</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.pullback.fst\">CategoryTheory.Limits.pullback.fst</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback\">CategoryTheory.Limits.Types.pullbackIsoPullback</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.inv</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackCone\">CategoryTheory.Limits.Types.pullbackCone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.pt</span>) =&gt; <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">p</span></span>)</span>.1</span></span>)</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L710-L712","name":"CategoryTheory.Limits.Types.pullbackIsoPullback_inv_fst","line":710,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_inv_fst","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_inv_fst\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackIsoPullback_inv_fst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback\">CategoryTheory.Limits.Types.pullbackIsoPullback</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.inv</span>\n    <span class=\"fn\">CategoryTheory.Limits.pullback.fst</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">fun (<span class=\"fn\">p</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.PullbackObj\">CategoryTheory.Limits.Types.PullbackObj</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">p</span></span>)</span>.1</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L704-L706","name":"CategoryTheory.Limits.Types.pullbackIsoPullback_hom_snd","line":704,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_hom_snd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_hom_snd\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackIsoPullback_hom_snd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.pullback\">CategoryTheory.Limits.pullback</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback\">CategoryTheory.Limits.Types.pullbackIsoPullback</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.hom</span> <span class=\"fn\">p</span></span>)</span></span>)</span>.2</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.pullback.snd\">CategoryTheory.Limits.pullback.snd</a> <span class=\"fn\">p</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L698-L700","name":"CategoryTheory.Limits.Types.pullbackIsoPullback_hom_fst","line":698,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_hom_fst","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback_hom_fst\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackIsoPullback_hom_fst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.pullback\">CategoryTheory.Limits.pullback</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback\">CategoryTheory.Limits.Types.pullbackIsoPullback</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.hom</span> <span class=\"fn\">p</span></span>)</span></span>)</span>.1</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.pullback.fst\">CategoryTheory.Limits.pullback.fst</a> <span class=\"fn\">p</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L693-L694","name":"CategoryTheory.Limits.Types.pullbackIsoPullback","line":693,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback","doc":"The pullback given by the instance `HasPullbacks (Type u)` is isomorphic to the\nexplicit pullback object given by `PullbackObj`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackIsoPullback\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackIsoPullback</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.pullback\">CategoryTheory.Limits.pullback</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.PullbackObj\">CategoryTheory.Limits.Types.PullbackObj</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L686-L687","name":"CategoryTheory.Limits.Types.pullbackConeIsoPullback","line":686,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackConeIsoPullback","doc":"The pullback cone given by the instance `HasPullbacks (Type u)` is isomorphic to the\nexplicit pullback cone given by `pullbackLimitCone`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackConeIsoPullback\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackConeIsoPullback</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.cone\">CategoryTheory.Limits.limit.cone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.cospan\">CategoryTheory.Limits.cospan</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackCone\">CategoryTheory.Limits.Types.pullbackCone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L673-L680","name":"CategoryTheory.Limits.Types.pullbackLimitCone","line":673,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackLimitCone","doc":"The explicit pullback in the category of types, bundled up as a `LimitCone`\nfor given `f` and `g`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackLimitCone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackLimitCone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.LimitCone\">CategoryTheory.Limits.LimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.cospan\">CategoryTheory.Limits.cospan</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L672-L672","name":"CategoryTheory.Limits.Types.pullbackLimitCone_isLimit","line":672,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackLimitCone_isLimit","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackLimitCone_isLimit\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackLimitCone_isLimit</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackLimitCone\">CategoryTheory.Limits.Types.pullbackLimitCone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.isLimit</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PullbackCone.isLimitAux\">CategoryTheory.Limits.PullbackCone.isLimitAux</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackCone\">CategoryTheory.Limits.Types.pullbackCone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PullbackCone\">CategoryTheory.Limits.PullbackCone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>) (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">s</span>.pt</span>) =&gt;\n      <span class=\"fn\">{ <span class=\"fn\">val</span> := <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PullbackCone.fst\">CategoryTheory.Limits.PullbackCone.fst</a> <span class=\"fn\">s</span> <span class=\"fn\">x</span></span>, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PullbackCone.snd\">CategoryTheory.Limits.PullbackCone.snd</a> <span class=\"fn\">s</span> <span class=\"fn\">x</span></span>)</span>,\n        <span class=\"fn\">property</span> := <span class=\"fn\">⋯</span> }</span></span>)</span>\n    <span class=\"fn\">⋯</span> <span class=\"fn\">⋯</span> <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L672-L672","name":"CategoryTheory.Limits.Types.pullbackLimitCone_cone","line":672,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackLimitCone_cone","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackLimitCone_cone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackLimitCone_cone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackLimitCone\">CategoryTheory.Limits.Types.pullbackLimitCone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.cone</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackCone\">CategoryTheory.Limits.Types.pullbackCone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L665-L666","name":"CategoryTheory.Limits.Types.pullbackCone","line":665,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackCone","doc":"The explicit pullback cone on `PullbackObj f g`.\nThis is bundled with the `IsLimit` data as `pullbackLimitCone f g`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pullbackCone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pullbackCone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.PullbackCone\">CategoryTheory.Limits.PullbackCone</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L654-L655","name":"CategoryTheory.Limits.Types.PullbackObj","line":654,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.PullbackObj","doc":"The usual explicit pullback in the category of types, as a subtype of the product.\nThe full `LimitCone` data is bundled as `pullbackLimitCone f g`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.PullbackObj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">PullbackObj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L644-L645","name":"CategoryTheory.Limits.Types.instHasPushoutsTypeTypes","line":644,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instHasPushoutsTypeTypes","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instHasPushoutsTypeTypes\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">instHasPushoutsTypeTypes</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.HasPushouts\">CategoryTheory.Limits.HasPushouts</a> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L638-L642","name":"CategoryTheory.Limits.Types.instHasPullbacksTypeTypes","line":638,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instHasPullbacksTypeTypes","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instHasPullbacksTypeTypes\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">instHasPullbacksTypeTypes</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.HasPullbacks\">CategoryTheory.Limits.HasPullbacks</a> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L622-L624","name":"CategoryTheory.Limits.Types.coequalizerIso_quot_comp_inv","line":622,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerIso_quot_comp_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerIso_quot_comp_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coequalizerIso_quot_comp_inv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.asHom\">CategoryTheory.asHom</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Quot.mk\">Quot.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.CoequalizerRel\">CategoryTheory.Limits.Types.CoequalizerRel</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>)</span></span>)</span>\n    <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerIso\">CategoryTheory.Limits.Types.coequalizerIso</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.inv</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L615-L617","name":"CategoryTheory.Limits.Types.coequalizerIso_π_comp_hom","line":615,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerIso_π_comp_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerIso_π_comp_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coequalizerIso_π_comp_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">CategoryTheory.Limits.coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>\n    <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerIso\">CategoryTheory.Limits.Types.coequalizerIso</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Init/Prelude.html#Quot.mk\">Quot.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.CoequalizerRel\">CategoryTheory.Limits.Types.CoequalizerRel</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L614-L614","name":"CategoryTheory.Limits.Types.coequalizerIso_π_comp_hom_apply","line":614,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerIso_π_comp_hom_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerIso_π_comp_hom_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coequalizerIso_π_comp_hom_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.obj</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.isoColimitCocone\">CategoryTheory.Limits.colimit.isoColimitCocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerColimit\">CategoryTheory.Limits.Types.coequalizerColimit</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>)</span>.hom</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.ι\">CategoryTheory.Limits.colimit.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>\n      <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.one\">CategoryTheory.Limits.WalkingParallelPair.one</a> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.π\">CategoryTheory.Limits.Cofork.π</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerColimit\">CategoryTheory.Limits.Types.coequalizerColimit</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.cocone</span></span>)</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L610-L611","name":"CategoryTheory.Limits.Types.coequalizerIso","line":610,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerIso","doc":"The categorical coequalizer in `Type u` is the quotient by `f g ~ g x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coequalizerIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer\">CategoryTheory.Limits.coequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Quot\">Quot</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.CoequalizerRel\">CategoryTheory.Limits.Types.CoequalizerRel</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L582-L606","name":"CategoryTheory.Limits.Types.coequalizer_preimage_image_eq_of_preimage_eq","line":582,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizer_preimage_image_eq_of_preimage_eq","doc":"If `π : Y ⟶ Z` is an equalizer for `(f, g)`, and `U ⊆ Y` such that `f ⁻¹' U = g ⁻¹' U`,\nthen `π ⁻¹' (π '' U) = U`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizer_preimage_image_eq_of_preimage_eq\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coequalizer_preimage_image_eq_of_preimage_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">π</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">π</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Cofork.ofπ\">CategoryTheory.Limits.Cofork.ofπ</a> <span class=\"fn\">π</span> <span class=\"fn\">e</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(U : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Mathlib/Data/Set/Defs.html#Set.preimage\">⁻¹'</a> <span class=\"fn\">U</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Mathlib/Data/Set/Defs.html#Set.preimage\">⁻¹'</a> <span class=\"fn\">U</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">π</span> <a href=\"./Mathlib/Data/Set/Defs.html#Set.preimage\">⁻¹'</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">π</span> <a href=\"./Mathlib/Init/Set.html#Set.image\">''</a> <span class=\"fn\">U</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">U</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L566-L576","name":"CategoryTheory.Limits.Types.coequalizerColimit","line":566,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerColimit","doc":"Show that the quotient by the relation generated by `f(x) ~ g(x)`\nis a coequalizer for the pair `(f, g)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coequalizerColimit\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coequalizerColimit</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.ColimitCocone\">CategoryTheory.Limits.ColimitCocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L560-L560","name":"CategoryTheory.Limits.Types.CoequalizerRel.Rel","line":560,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.CoequalizerRel.Rel","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.CoequalizerRel.Rel\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">CoequalizerRel</span>.<span class=\"name\">Rel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">X</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.CoequalizerRel\">CategoryTheory.Limits.Types.CoequalizerRel</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">x</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L559-L560","name":"CategoryTheory.Limits.Types.CoequalizerRel","line":559,"kind":"inductive","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.CoequalizerRel","doc":"(Implementation) The relation to be quotiented to obtain the coequalizer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.CoequalizerRel\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">CoequalizerRel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Y</span> → <span class=\"fn\">Y</span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L548-L549","name":"CategoryTheory.Limits.Types.equalizerIso_inv_comp_ι","line":548,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerIso_inv_comp_ι","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerIso_inv_comp_ι\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">equalizerIso_inv_comp_ι</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerIso\">CategoryTheory.Limits.Types.equalizerIso</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span>)</span>.inv</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">Subtype.val</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L547-L547","name":"CategoryTheory.Limits.Types.equalizerIso_inv_comp_ι_apply","line":547,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerIso_inv_comp_ι_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerIso_inv_comp_ι_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">equalizerIso_inv_comp_ι_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">CategoryTheory.Limits.Types.equalizerLimit</span>.cone</span>.pt</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.π\">CategoryTheory.Limits.limit.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span>)</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.WalkingParallelPair.zero\">CategoryTheory.Limits.WalkingParallelPair.zero</a>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.isoLimitCone\">CategoryTheory.Limits.limit.isoLimitCone</a> <span class=\"fn\">CategoryTheory.Limits.Types.equalizerLimit</span></span>)</span>.inv</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ι\">CategoryTheory.Limits.Fork.ι</a> <span class=\"fn\"><span class=\"fn\">CategoryTheory.Limits.Types.equalizerLimit</span>.cone</span></span>)</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L543-L544","name":"CategoryTheory.Limits.Types.equalizerIso_hom_comp_subtype","line":543,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerIso_hom_comp_subtype","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerIso_hom_comp_subtype\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">equalizerIso_hom_comp_subtype</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerIso\">CategoryTheory.Limits.Types.equalizerIso</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span>)</span>.hom</span> <span class=\"fn\">Subtype.val</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">CategoryTheory.Limits.equalizer.ι</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L537-L538","name":"CategoryTheory.Limits.Types.equalizerIso","line":537,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerIso","doc":"The categorical equalizer in `Type u` is `{x : Y // g x = h x}`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">equalizerIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer\">CategoryTheory.Limits.equalizer</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">{ <span class=\"fn\">x</span> : <span class=\"fn\">Y</span> // <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">h</span> <span class=\"fn\">x</span></span></span> }</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L526-L531","name":"CategoryTheory.Limits.Types.equalizerLimit","line":526,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerLimit","doc":"Show that the subtype `{x : Y // g x = h x}` is an equalizer for the pair `(g,h)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.equalizerLimit\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">equalizerLimit</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.LimitCone\">CategoryTheory.Limits.LimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.parallelPair\">CategoryTheory.Limits.parallelPair</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L519-L522","name":"CategoryTheory.Limits.Types.type_equalizer_iff_unique","line":519,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.type_equalizer_iff_unique","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.type_equalizer_iff_unique\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">type_equalizer_iff_unique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">f</span> <span class=\"fn\">w</span></span>)</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\">∀ (<span class=\"fn\">y</span> : <span class=\"fn\">Y</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">h</span> <span class=\"fn\">y</span></span></span> → <span class=\"fn\">∃! (<span class=\"fn\">x</span> : <span class=\"fn\">X</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L506-L516","name":"CategoryTheory.Limits.Types.unique_of_type_equalizer","line":506,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.unique_of_type_equalizer","doc":"The converse of `type_equalizer_of_unique`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.unique_of_type_equalizer\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">unique_of_type_equalizer</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">f</span> <span class=\"fn\">w</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <span class=\"fn\">Y</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hy : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">h</span> <span class=\"fn\">y</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃! (<span class=\"fn\">x</span> : <span class=\"fn\">X</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L492-L502","name":"CategoryTheory.Limits.Types.typeEqualizerOfUnique","line":492,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.typeEqualizerOfUnique","doc":"Show the given fork in `Type u` is an equalizer given that any element in the \"difference kernel\"\ncomes from `X`.\nThe converse of `unique_of_type_equalizer`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.typeEqualizerOfUnique\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">typeEqualizerOfUnique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Z : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{h : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\">∀ (<span class=\"fn\">y</span> : <span class=\"fn\">Y</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">h</span> <span class=\"fn\">y</span></span></span> → <span class=\"fn\">∃! (<span class=\"fn\">x</span> : <span class=\"fn\">X</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">f</span> <span class=\"fn\">w</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L478-L480","name":"CategoryTheory.Limits.Types.coproductIso_mk_comp_inv","line":478,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductIso_mk_comp_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductIso_mk_comp_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coproductIso_mk_comp_inv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./Mathlib/Data/TypeMax.html#TypeMax\">TypeMax</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.asHom\">CategoryTheory.asHom</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span>) =&gt; <span class=\"fn\">{ <span class=\"fn\">fst</span> := <span class=\"fn\">j</span>, <span class=\"fn\">snd</span> := <span class=\"fn\">x</span> }</span></span></span>)</span>\n    <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductIso\">CategoryTheory.Limits.Types.coproductIso</a> <span class=\"fn\">F</span></span>)</span>.inv</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.ι\">CategoryTheory.Limits.Sigma.ι</a> <span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L471-L473","name":"CategoryTheory.Limits.Types.coproductIso_ι_comp_hom","line":471,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductIso_ι_comp_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductIso_ι_comp_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coproductIso_ι_comp_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./Mathlib/Data/TypeMax.html#TypeMax\">TypeMax</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.ι\">CategoryTheory.Limits.Sigma.ι</a> <span class=\"fn\">F</span> <span class=\"fn\">j</span></span>)</span>\n    <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductIso\">CategoryTheory.Limits.Types.coproductIso</a> <span class=\"fn\">F</span></span>)</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span>) =&gt; <span class=\"fn\">{ <span class=\"fn\">fst</span> := <span class=\"fn\">j</span>, <span class=\"fn\">snd</span> := <span class=\"fn\">x</span> }</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L470-L470","name":"CategoryTheory.Limits.Types.coproductIso_ι_comp_hom_apply","line":470,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductIso_ι_comp_hom_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductIso_ι_comp_hom_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coproductIso_ι_comp_hom_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./Mathlib/Data/TypeMax.html#TypeMax\">TypeMax</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span>)</span>.obj</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">j</span> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.isoColimitCocone\">CategoryTheory.Limits.colimit.isoColimitCocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductColimitCocone\">CategoryTheory.Limits.Types.coproductColimitCocone</a> <span class=\"fn\">F</span></span>)</span></span>)</span>.hom</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.ι\">CategoryTheory.Limits.colimit.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span>)</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">j</span> }</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductColimitCocone\">CategoryTheory.Limits.Types.coproductColimitCocone</a> <span class=\"fn\">F</span></span>)</span>.cocone</span>.ι</span>.app</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">j</span> }</span></span>)</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L466-L467","name":"CategoryTheory.Limits.Types.coproductIso","line":466,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductIso","doc":"The categorical coproduct in `Type u` is the type theoretic coproduct `Σ j, F j`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coproductIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./Mathlib/Data/TypeMax.html#TypeMax\">TypeMax</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj\">∐</a> <span class=\"fn\">F</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">(j : <span class=\"fn\">J</span>) × <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L453-L462","name":"CategoryTheory.Limits.Types.coproductColimitCocone","line":453,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductColimitCocone","doc":"The category of types has `Σ j, f j` as the coproduct of a type family `f : J → Type`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.coproductColimitCocone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">coproductColimitCocone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./Mathlib/Data/TypeMax.html#TypeMax\">TypeMax</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.ColimitCocone\">CategoryTheory.Limits.ColimitCocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L445-L447","name":"CategoryTheory.Limits.Types.Small.productIso_inv_comp_π","line":445,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso_inv_comp_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso_inv_comp_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Small</span>.<span class=\"name\">productIso_inv_comp_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./foundational_types.html\">Type</a> u</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{u, v}</a>    <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso\">CategoryTheory.Limits.Types.Small.productIso</a> <span class=\"fn\">F</span></span>)</span>.inv</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">F</span> <span class=\"fn\">j</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Shrink\">Shrink.{u, max u v}</a>          <span class=\"fn\">(<span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) → <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span>)</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#equivShrink\">equivShrink</a> <span class=\"fn\">(<span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) → <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span>)</span></span>)</span>.symm</span> <span class=\"fn\">f</span> <span class=\"fn\">j</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L444-L444","name":"CategoryTheory.Limits.Types.Small.productIso_inv_comp_π_apply","line":444,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso_inv_comp_π_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso_inv_comp_π_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Small</span>.<span class=\"name\">productIso_inv_comp_π_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./foundational_types.html\">Type</a> u</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{u, v}</a>    <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productLimitCone\">CategoryTheory.Limits.Types.Small.productLimitCone</a> <span class=\"fn\">F</span></span>)</span>.cone</span>.pt</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.π\">CategoryTheory.Limits.limit.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span>)</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">j</span> }</span>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.isoLimitCone\">CategoryTheory.Limits.limit.isoLimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productLimitCone\">CategoryTheory.Limits.Types.Small.productLimitCone</a> <span class=\"fn\">F</span></span>)</span></span>)</span>.inv</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productLimitCone\">CategoryTheory.Limits.Types.Small.productLimitCone</a> <span class=\"fn\">F</span></span>)</span>.cone</span>.π</span>.app</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">j</span> }</span></span>)</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L440-L442","name":"CategoryTheory.Limits.Types.Small.productIso_hom_comp_eval_apply","line":440,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso_hom_comp_eval_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso_hom_comp_eval_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Small</span>.<span class=\"name\">productIso_hom_comp_eval_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./foundational_types.html\">Type</a> u</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{u, v}</a>    <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.piObj\">∏</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#equivShrink\">equivShrink</a> <span class=\"fn\">(<span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) → <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span>)</span></span>)</span>.symm</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso\">CategoryTheory.Limits.Types.Small.productIso</a> <span class=\"fn\">F</span></span>)</span>.hom</span> <span class=\"fn\">x</span></span>)</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">F</span> <span class=\"fn\">j</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L433-L435","name":"CategoryTheory.Limits.Types.Small.productIso_hom_comp_eval","line":433,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso_hom_comp_eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso_hom_comp_eval\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Small</span>.<span class=\"name\">productIso_hom_comp_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./foundational_types.html\">Type</a> u</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{u, v}</a>    <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso\">CategoryTheory.Limits.Types.Small.productIso</a> <span class=\"fn\">F</span></span>)</span>.hom</span>\n    <span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Shrink\">Shrink.{u, max u v}</a>          <span class=\"fn\">(<span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) → <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span>)</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#equivShrink\">equivShrink</a> <span class=\"fn\">(<span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) → <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span>)</span></span>)</span>.symm</span> <span class=\"fn\">f</span> <span class=\"fn\">j</span></span></span></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L428-L430","name":"CategoryTheory.Limits.Types.Small.productIso","line":428,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso","doc":"The categorical product in `Type u` indexed in `Type v`\nis the type theoretic product `Π j, F j`, after shrinking back to `Type u`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Small</span>.<span class=\"name\">productIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./foundational_types.html\">Type</a> u</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{u, v}</a>    <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.piObj\">∏</a> <span class=\"fn\">F</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Shrink\">Shrink.{u, max u v}</a>          <span class=\"fn\">(<span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) → <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L415-L424","name":"CategoryTheory.Limits.Types.Small.productLimitCone","line":415,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productLimitCone","doc":"A variant of `productLimitCone` using a `Small` hypothesis rather than a function to `TypeMax`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.Small.productLimitCone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">Small</span>.<span class=\"name\">productLimitCone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./foundational_types.html\">Type</a> u</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{u, v}</a>    <span class=\"fn\">J</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.LimitCone\">CategoryTheory.Limits.LimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L403-L405","name":"CategoryTheory.Limits.Types.productIso_inv_comp_π","line":403,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso_inv_comp_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso_inv_comp_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">productIso_inv_comp_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./Mathlib/Data/TypeMax.html#TypeMax\">TypeMax</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso\">CategoryTheory.Limits.Types.productIso</a> <span class=\"fn\">F</span></span>)</span>.inv</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">F</span> <span class=\"fn\">j</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) → <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L402-L402","name":"CategoryTheory.Limits.Types.productIso_inv_comp_π_apply","line":402,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso_inv_comp_π_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso_inv_comp_π_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">productIso_inv_comp_π_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./Mathlib/Data/TypeMax.html#TypeMax\">TypeMax</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productLimitCone\">CategoryTheory.Limits.Types.productLimitCone</a> <span class=\"fn\">F</span></span>)</span>.cone</span>.pt</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.π\">CategoryTheory.Limits.limit.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span>)</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">j</span> }</span>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.isoLimitCone\">CategoryTheory.Limits.limit.isoLimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productLimitCone\">CategoryTheory.Limits.Types.productLimitCone</a> <span class=\"fn\">F</span></span>)</span></span>)</span>.inv</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productLimitCone\">CategoryTheory.Limits.Types.productLimitCone</a> <span class=\"fn\">F</span></span>)</span>.cone</span>.π</span>.app</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">j</span> }</span></span>)</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L397-L399","name":"CategoryTheory.Limits.Types.productIso_hom_comp_eval_apply","line":397,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso_hom_comp_eval_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso_hom_comp_eval_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">productIso_hom_comp_eval_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./Mathlib/Data/TypeMax.html#TypeMax\">TypeMax</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.piObj\">∏</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso\">CategoryTheory.Limits.Types.productIso</a> <span class=\"fn\">F</span></span>)</span>.hom</span> <span class=\"fn\">x</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">F</span> <span class=\"fn\">j</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L391-L393","name":"CategoryTheory.Limits.Types.productIso_hom_comp_eval","line":391,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso_hom_comp_eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso_hom_comp_eval\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">productIso_hom_comp_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./Mathlib/Data/TypeMax.html#TypeMax\">TypeMax</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso\">CategoryTheory.Limits.Types.productIso</a> <span class=\"fn\">F</span></span>)</span>.hom</span> <span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) → <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span></span></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L384-L385","name":"CategoryTheory.Limits.Types.productIso","line":384,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso","doc":"The categorical product in `TypeMax.{v, u}` is the type theoretic product `Π j, F j`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">productIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./Mathlib/Data/TypeMax.html#TypeMax\">TypeMax</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.piObj\">∏</a> <span class=\"fn\">F</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) → <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">j</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L373-L380","name":"CategoryTheory.Limits.Types.productLimitCone","line":373,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productLimitCone","doc":"The category of types has `Π j, f j` as the product of a type family `f : J → TypeMax.{v, u}`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productLimitCone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">productLimitCone</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <a href=\"./Mathlib/Data/TypeMax.html#TypeMax\">TypeMax</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.LimitCone\">CategoryTheory.Limits.LimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L360-L367","name":"CategoryTheory.Limits.Types.isCoprodOfMono","line":360,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.isCoprodOfMono","doc":"Any monomorphism in `Type` is a coproduct injection. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.isCoprodOfMono\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">isCoprodOfMono</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan.mk\">CategoryTheory.Limits.BinaryCofan.mk</a> <span class=\"fn\">f</span> <span class=\"fn\">Subtype.val</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L311-L356","name":"CategoryTheory.Limits.Types.binaryCofan_isColimit_iff","line":311,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCofan_isColimit_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCofan_isColimit_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCofan_isColimit_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(c : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan\">CategoryTheory.Limits.BinaryCofan</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">c</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Init/Function.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan.inl\">CategoryTheory.Limits.BinaryCofan.inl</a> <span class=\"fn\">c</span></span>)</span></span> <a href=\"./Init/Prelude.html#And\">∧</a>     <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Init/Function.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan.inr\">CategoryTheory.Limits.BinaryCofan.inr</a> <span class=\"fn\">c</span></span>)</span></span> <a href=\"./Init/Prelude.html#And\">∧</a>       <span class=\"fn\"><a href=\"./Mathlib/Order/Disjoint.html#IsCompl\">IsCompl</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Set/Defs.html#Set.range\">Set.range</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan.inl\">CategoryTheory.Limits.BinaryCofan.inl</a> <span class=\"fn\">c</span></span>)</span></span>)</span>\n        <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Set/Defs.html#Set.range\">Set.range</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan.inr\">CategoryTheory.Limits.BinaryCofan.inr</a> <span class=\"fn\">c</span></span>)</span></span>)</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L304-L306","name":"CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_inv","line":304,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductIso_inr_comp_inv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.asHom\">CategoryTheory.asHom</a> <span class=\"fn\">Sum.inr</span></span>)</span>\n    <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso\">CategoryTheory.Limits.Types.binaryCoproductIso</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.inv</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">CategoryTheory.Limits.coprod.inr</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L303-L303","name":"CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_inv_apply","line":303,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_inv_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_inv_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductIso_inr_comp_inv_apply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.obj</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.right\">CategoryTheory.Limits.WalkingPair.right</a> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.isoColimitCocone\">CategoryTheory.Limits.colimit.isoColimitCocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimitCocone\">CategoryTheory.Limits.Types.binaryCoproductColimitCocone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>)</span>.inv</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan.inr\">CategoryTheory.Limits.BinaryCofan.inr</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimitCocone\">CategoryTheory.Limits.Types.binaryCoproductColimitCocone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.cocone</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.ι\">CategoryTheory.Limits.colimit.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.right\">CategoryTheory.Limits.WalkingPair.right</a> }</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L298-L300","name":"CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_inv","line":298,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductIso_inl_comp_inv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Types.html#CategoryTheory.asHom\">CategoryTheory.asHom</a> <span class=\"fn\">Sum.inl</span></span>)</span>\n    <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso\">CategoryTheory.Limits.Types.binaryCoproductIso</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.inv</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">CategoryTheory.Limits.coprod.inl</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L297-L297","name":"CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_inv_apply","line":297,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_inv_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_inv_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductIso_inl_comp_inv_apply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.obj</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.left\">CategoryTheory.Limits.WalkingPair.left</a> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.isoColimitCocone\">CategoryTheory.Limits.colimit.isoColimitCocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimitCocone\">CategoryTheory.Limits.Types.binaryCoproductColimitCocone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>)</span>.inv</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan.inl\">CategoryTheory.Limits.BinaryCofan.inl</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimitCocone\">CategoryTheory.Limits.Types.binaryCoproductColimitCocone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.cocone</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.ι\">CategoryTheory.Limits.colimit.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.left\">CategoryTheory.Limits.WalkingPair.left</a> }</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L292-L294","name":"CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_hom","line":292,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductIso_inr_comp_hom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">CategoryTheory.Limits.coprod.inr</span>\n    <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso\">CategoryTheory.Limits.Types.binaryCoproductIso</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">Sum.inr</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L291-L291","name":"CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_hom_apply","line":291,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_hom_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_hom_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductIso_inr_comp_hom_apply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.obj</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.right\">CategoryTheory.Limits.WalkingPair.right</a> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.isoColimitCocone\">CategoryTheory.Limits.colimit.isoColimitCocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimitCocone\">CategoryTheory.Limits.Types.binaryCoproductColimitCocone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>)</span>.hom</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.ι\">CategoryTheory.Limits.colimit.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.right\">CategoryTheory.Limits.WalkingPair.right</a> }</span>\n      <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan.inr\">CategoryTheory.Limits.BinaryCofan.inr</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimitCocone\">CategoryTheory.Limits.Types.binaryCoproductColimitCocone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.cocone</span></span>)</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L286-L288","name":"CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_hom","line":286,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductIso_inl_comp_hom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">CategoryTheory.Limits.coprod.inl</span>\n    <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso\">CategoryTheory.Limits.Types.binaryCoproductIso</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">Sum.inl</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L285-L285","name":"CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_hom_apply","line":285,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_hom_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_hom_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductIso_inl_comp_hom_apply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.obj</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.left\">CategoryTheory.Limits.WalkingPair.left</a> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.isoColimitCocone\">CategoryTheory.Limits.colimit.isoColimitCocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimitCocone\">CategoryTheory.Limits.Types.binaryCoproductColimitCocone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>)</span>.hom</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.colimit.ι\">CategoryTheory.Limits.colimit.ι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.left\">CategoryTheory.Limits.WalkingPair.left</a> }</span>\n      <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan.inl\">CategoryTheory.Limits.BinaryCofan.inl</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimitCocone\">CategoryTheory.Limits.Types.binaryCoproductColimitCocone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.cocone</span></span>)</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L279-L280","name":"CategoryTheory.Limits.Types.binaryCoproductIso","line":279,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso","doc":"The categorical binary coproduct in `Type u` is the sum `X ⊕ Y`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductIso</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.coprod\">⨿</a> <span class=\"fn\">Y</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">Y</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L274-L275","name":"CategoryTheory.Limits.Types.binaryCoproductColimitCocone","line":274,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimitCocone","doc":"The category of types has `X ⊕ Y`,\nas the binary coproduct of `X` and `Y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimitCocone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductColimitCocone</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.ColimitCocone\">CategoryTheory.Limits.ColimitCocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L265-L268","name":"CategoryTheory.Limits.Types.binaryCoproductColimit","line":265,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimit","doc":"The sum type `X ⊕ Y` is a binary coproduct for `X` and `Y`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimit\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductColimit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit\">CategoryTheory.Limits.IsColimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductCocone\">CategoryTheory.Limits.Types.binaryCoproductCocone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L264-L264","name":"CategoryTheory.Limits.Types.binaryCoproductColimit_desc","line":264,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimit_desc","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimit_desc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductColimit_desc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan\">CategoryTheory.Limits.BinaryCofan</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">Y</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductColimit\">CategoryTheory.Limits.Types.binaryCoproductColimit</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.desc</span> <span class=\"fn\">s</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Std/Data/Sum/Basic.html#Sum.elim\">Sum.elim</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan.inl\">CategoryTheory.Limits.BinaryCofan.inl</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryCofan.inr\">CategoryTheory.Limits.BinaryCofan.inr</a> <span class=\"fn\">s</span></span>)</span> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L259-L260","name":"CategoryTheory.Limits.Types.binaryCoproductCocone","line":259,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductCocone","doc":"The sum type `X ⊕ Y` forms a cocone for the binary coproduct of `X` and `Y`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductCocone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductCocone</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone\">CategoryTheory.Limits.Cocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L258-L258","name":"CategoryTheory.Limits.Types.binaryCoproductCocone_pt","line":258,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductCocone_pt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductCocone_pt\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductCocone_pt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductCocone\">CategoryTheory.Limits.Types.binaryCoproductCocone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.pt</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">Y</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L258-L258","name":"CategoryTheory.Limits.Types.binaryCoproductCocone_ι_app","line":258,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductCocone_ι_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductCocone_ι_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryCoproductCocone_ι_app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair\">CategoryTheory.Limits.WalkingPair</a></span>) (<span class=\"fn\">a</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.obj</span> <span class=\"fn\">x</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryCoproductCocone\">CategoryTheory.Limits.Types.binaryCoproductCocone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.ι</span>.app</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.rec\">CategoryTheory.Limits.WalkingPair.rec</a> (motive := <span class=\"fn\">fun (<span class=\"fn\">t</span> : <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair\">CategoryTheory.Limits.WalkingPair</a>) =&gt;\n      <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.obj</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\"><span class=\"fn\">x</span>.as</span> }</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">Y</span></span></span>)</span></span></span>)\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.left\">CategoryTheory.Limits.WalkingPair.left</a></span>) =&gt; <span class=\"fn\"><span class=\"fn\">⋯</span> ▸ <span class=\"fn\">Sum.inl</span></span></span>)</span>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.right\">CategoryTheory.Limits.WalkingPair.right</a></span>) =&gt; <span class=\"fn\"><span class=\"fn\">⋯</span> ▸ <span class=\"fn\">Sum.inr</span></span></span>)</span> <span class=\"fn\"><span class=\"fn\">x</span>.as</span> <span class=\"fn\">⋯</span> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L248-L254","name":"CategoryTheory.Limits.Types.binaryProductIsoProd","line":248,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIsoProd","doc":"The product functor given by the instance `HasBinaryProducts (Type u)` is isomorphic to the\nexplicit binary product functor given by the product type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIsoProd\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductIsoProd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor\">CategoryTheory.Limits.Types.binaryProductFunctor</a> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">CategoryTheory.Limits.prod.functor</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L235-L242","name":"CategoryTheory.Limits.Types.binaryProductFunctor","line":235,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor","doc":"The functor which sends `X, Y` to the product type `X × Y`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductFunctor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L234-L234","name":"CategoryTheory.Limits.Types.binaryProductFunctor_obj_obj","line":234,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor_obj_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor_obj_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductFunctor_obj_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor\">CategoryTheory.Limits.Types.binaryProductFunctor</a>.obj</span> <span class=\"fn\">X</span></span>)</span>.obj</span> <span class=\"fn\">Y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">Y</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L234-L234","name":"CategoryTheory.Limits.Types.binaryProductFunctor_map_app","line":234,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor_map_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor_map_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductFunctor_map_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X₁</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryFan.mk\">CategoryTheory.Limits.BinaryFan.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">Prod.fst</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">Prod.snd</span></span>)</span>.pt</span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor\">CategoryTheory.Limits.Types.binaryProductFunctor</a>.map</span> <span class=\"fn\">f</span></span>)</span>.app</span> <span class=\"fn\">Y</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimit\">CategoryTheory.Limits.Types.binaryProductLimit</a> <span class=\"fn\">X₂</span> <span class=\"fn\">Y</span></span>)</span>.lift</span>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryFan.mk\">CategoryTheory.Limits.BinaryFan.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">Prod.fst</span> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">Prod.snd</span></span>)</span> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L234-L234","name":"CategoryTheory.Limits.Types.binaryProductFunctor_obj_map","line":234,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor_obj_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor_obj_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductFunctor_obj_map</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y₁ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y₂ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">Y₁</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryFan.mk\">CategoryTheory.Limits.BinaryFan.mk</a> <span class=\"fn\">Prod.fst</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">Prod.snd</span> <span class=\"fn\">f</span></span>)</span></span>)</span>.pt</span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductFunctor\">CategoryTheory.Limits.Types.binaryProductFunctor</a>.obj</span> <span class=\"fn\">X</span></span>)</span>.map</span> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimit\">CategoryTheory.Limits.Types.binaryProductLimit</a> <span class=\"fn\">X</span> <span class=\"fn\">Y₂</span></span>)</span>.lift</span>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryFan.mk\">CategoryTheory.Limits.BinaryFan.mk</a> <span class=\"fn\">Prod.fst</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">Prod.snd</span> <span class=\"fn\">f</span></span>)</span></span>)</span> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L225-L227","name":"CategoryTheory.Limits.Types.binaryProductIso_inv_comp_snd","line":225,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_inv_comp_snd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_inv_comp_snd\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductIso_inv_comp_snd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso\">CategoryTheory.Limits.Types.binaryProductIso</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.inv</span>\n    <span class=\"fn\">CategoryTheory.Limits.prod.snd</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">Prod.snd</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L224-L224","name":"CategoryTheory.Limits.Types.binaryProductIso_inv_comp_snd_apply","line":224,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_inv_comp_snd_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_inv_comp_snd_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductIso_inv_comp_snd_apply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone\">CategoryTheory.Limits.Types.binaryProductLimitCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.cone</span>.pt</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.π\">CategoryTheory.Limits.limit.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.right\">CategoryTheory.Limits.WalkingPair.right</a> }</span>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.isoLimitCone\">CategoryTheory.Limits.limit.isoLimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone\">CategoryTheory.Limits.Types.binaryProductLimitCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>)</span>.inv</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">Prod.snd</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L219-L221","name":"CategoryTheory.Limits.Types.binaryProductIso_inv_comp_fst","line":219,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_inv_comp_fst","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_inv_comp_fst\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductIso_inv_comp_fst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso\">CategoryTheory.Limits.Types.binaryProductIso</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.inv</span>\n    <span class=\"fn\">CategoryTheory.Limits.prod.fst</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">Prod.fst</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L218-L218","name":"CategoryTheory.Limits.Types.binaryProductIso_inv_comp_fst_apply","line":218,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_inv_comp_fst_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_inv_comp_fst_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductIso_inv_comp_fst_apply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone\">CategoryTheory.Limits.Types.binaryProductLimitCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.cone</span>.pt</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.π\">CategoryTheory.Limits.limit.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.left\">CategoryTheory.Limits.WalkingPair.left</a> }</span>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.isoLimitCone\">CategoryTheory.Limits.limit.isoLimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone\">CategoryTheory.Limits.Types.binaryProductLimitCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>)</span>.inv</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">Prod.fst</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L213-L215","name":"CategoryTheory.Limits.Types.binaryProductIso_hom_comp_snd","line":213,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_hom_comp_snd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_hom_comp_snd\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductIso_hom_comp_snd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso\">CategoryTheory.Limits.Types.binaryProductIso</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.hom</span> <span class=\"fn\">Prod.snd</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">CategoryTheory.Limits.prod.snd</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L212-L212","name":"CategoryTheory.Limits.Types.binaryProductIso_hom_comp_snd_apply","line":212,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_hom_comp_snd_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_hom_comp_snd_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductIso_hom_comp_snd_apply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit\">CategoryTheory.Limits.limit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">Prod.snd</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.isoLimitCone\">CategoryTheory.Limits.limit.isoLimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone\">CategoryTheory.Limits.Types.binaryProductLimitCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>)</span>.hom</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.π\">CategoryTheory.Limits.limit.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.right\">CategoryTheory.Limits.WalkingPair.right</a> }</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L207-L209","name":"CategoryTheory.Limits.Types.binaryProductIso_hom_comp_fst","line":207,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_hom_comp_fst","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_hom_comp_fst\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductIso_hom_comp_fst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso\">CategoryTheory.Limits.Types.binaryProductIso</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.hom</span> <span class=\"fn\">Prod.fst</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">CategoryTheory.Limits.prod.fst</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L206-L206","name":"CategoryTheory.Limits.Types.binaryProductIso_hom_comp_fst_apply","line":206,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_hom_comp_fst_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso_hom_comp_fst_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductIso_hom_comp_fst_apply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit\">CategoryTheory.Limits.limit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">Prod.fst</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.isoLimitCone\">CategoryTheory.Limits.limit.isoLimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone\">CategoryTheory.Limits.Types.binaryProductLimitCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>)</span>.hom</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.limit.π\">CategoryTheory.Limits.limit.π</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.WalkingPair.left\">CategoryTheory.Limits.WalkingPair.left</a> }</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L202-L203","name":"CategoryTheory.Limits.Types.binaryProductIso","line":202,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso","doc":"The categorical binary product in `Type u` is cartesian product. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductIso</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.prod\">⨯</a> <span class=\"fn\">Y</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">Y</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L197-L198","name":"CategoryTheory.Limits.Types.binaryProductLimitCone","line":197,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone","doc":"The category of types has `X × Y`, the usual cartesian product,\nas the binary product of `X` and `Y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductLimitCone</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.LimitCone\">CategoryTheory.Limits.LimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.pair\">CategoryTheory.Limits.pair</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L196-L196","name":"CategoryTheory.Limits.Types.binaryProductLimitCone_cone","line":196,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone_cone","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone_cone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductLimitCone_cone</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone\">CategoryTheory.Limits.Types.binaryProductLimitCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.cone</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone\">CategoryTheory.Limits.Types.binaryProductCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L196-L196","name":"CategoryTheory.Limits.Types.binaryProductLimitCone_isLimit","line":196,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone_isLimit","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone_isLimit\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductLimitCone_isLimit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimitCone\">CategoryTheory.Limits.Types.binaryProductLimitCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.isLimit</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimit\">CategoryTheory.Limits.Types.binaryProductLimit</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L187-L190","name":"CategoryTheory.Limits.Types.binaryProductLimit","line":187,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimit","doc":"The product type `X × Y` is a binary product for `X` and `Y`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimit\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductLimit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone\">CategoryTheory.Limits.Types.binaryProductCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L186-L186","name":"CategoryTheory.Limits.Types.binaryProductLimit_lift","line":186,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimit_lift","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimit_lift\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductLimit_lift</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryFan\">CategoryTheory.Limits.BinaryFan</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\">s</span>.pt</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductLimit\">CategoryTheory.Limits.Types.binaryProductLimit</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.lift</span> <span class=\"fn\">s</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryFan.fst\">CategoryTheory.Limits.BinaryFan.fst</a> <span class=\"fn\">s</span> <span class=\"fn\">x</span></span>, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryFan.snd\">CategoryTheory.Limits.BinaryFan.snd</a> <span class=\"fn\">s</span> <span class=\"fn\">x</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L181-L182","name":"CategoryTheory.Limits.Types.binaryProductCone_snd","line":181,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone_snd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone_snd\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductCone_snd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryFan.snd\">CategoryTheory.Limits.BinaryFan.snd</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone\">CategoryTheory.Limits.Types.binaryProductCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">Prod.snd</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L176-L177","name":"CategoryTheory.Limits.Types.binaryProductCone_fst","line":176,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone_fst","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone_fst\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductCone_fst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryFan.fst\">CategoryTheory.Limits.BinaryFan.fst</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone\">CategoryTheory.Limits.Types.binaryProductCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">Prod.fst</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L171-L172","name":"CategoryTheory.Limits.Types.binaryProductCone","line":171,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone","doc":"The product type `X × Y` forms a cone for the binary product of `X` and `Y`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductCone</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.BinaryFan\">CategoryTheory.Limits.BinaryFan</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L170-L170","name":"CategoryTheory.Limits.Types.binaryProductCone_pt","line":170,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone_pt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone_pt\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">binaryProductCone_pt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.binaryProductCone\">CategoryTheory.Limits.Types.binaryProductCone</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span>.pt</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">Y</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L158-L163","name":"CategoryTheory.Limits.Types.initial_iff_empty","line":158,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.initial_iff_empty","doc":"An object in `Type u` is initial if and only if it is empty. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.initial_iff_empty\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">initial_iff_empty</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.IsInitial\">CategoryTheory.Limits.IsInitial</a> <span class=\"fn\">X</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/IsEmpty.html#IsEmpty\">IsEmpty</a> <span class=\"fn\">X</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L153-L154","name":"CategoryTheory.Limits.Types.isInitialPunit","line":153,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.isInitialPunit","doc":"The initial object in `Type u` is `PEmpty`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.isInitialPunit\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">isInitialPunit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.IsInitial\">CategoryTheory.Limits.IsInitial</a> <a href=\"./Init/Prelude.html#PEmpty\">PEmpty.{u + 1}</a>     </span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L148-L149","name":"CategoryTheory.Limits.Types.initialIso","line":148,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.initialIso","doc":"The initial object in `Type u` is `PEmpty`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.initialIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">initialIso</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.initial\">⊥_</a> <a href=\"./foundational_types.html\">Type</a> u</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <a href=\"./Init/Prelude.html#PEmpty\">PEmpty.{u + 1}</a>     </span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L136-L144","name":"CategoryTheory.Limits.Types.initialColimitCocone","line":136,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.initialColimitCocone","doc":"The category of types has `PEmpty` as an initial object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.initialColimitCocone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">initialColimitCocone</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.ColimitCocone\">CategoryTheory.Limits.ColimitCocone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PEmpty.html#CategoryTheory.Functor.empty\">CategoryTheory.Functor.empty</a> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L129-L133","name":"CategoryTheory.Limits.Types.isTerminalEquivIsoPUnit","line":129,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.isTerminalEquivIsoPUnit","doc":"A type is terminal if and only if it is isomorphic to `PUnit`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.isTerminalEquivIsoPUnit\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">isTerminalEquivIsoPUnit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.IsTerminal\">CategoryTheory.Limits.IsTerminal</a> <span class=\"fn\">X</span></span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit.{u + 1}</a>     </span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L123-L126","name":"CategoryTheory.Limits.Types.isTerminalEquivUnique","line":123,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.isTerminalEquivUnique","doc":"A type is terminal if and only if it contains exactly one element. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.isTerminalEquivUnique\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">isTerminalEquivUnique</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(X : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.IsTerminal\">CategoryTheory.Limits.IsTerminal</a> <span class=\"fn\">X</span></span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Unique.html#Unique\">Unique</a> <span class=\"fn\">X</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L120-L120","name":"CategoryTheory.Limits.Types.instUniqueTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self","line":120,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instUniqueTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instUniqueTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">instUniqueTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Unique.html#Unique\">Unique</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.terminal\">⊤_</a> <a href=\"./foundational_types.html\">Type</a> u</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L116-L118","name":"CategoryTheory.Limits.Types.instSubsingletonTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self","line":116,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instSubsingletonTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instSubsingletonTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">instSubsingletonTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.terminal\">⊤_</a> <a href=\"./foundational_types.html\">Type</a> u</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L113-L114","name":"CategoryTheory.Limits.Types.instInhabitedTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self","line":113,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instInhabitedTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instInhabitedTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">instInhabitedTerminalTypeTypesHasLimitsOfShapeDiscretePEmptyDiscreteCategoryInstSmallDiscreteUnivLE_of_maxSmall_self</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.terminal\">⊤_</a> <a href=\"./foundational_types.html\">Type</a> u</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L107-L108","name":"CategoryTheory.Limits.Types.isTerminalPunit","line":107,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.isTerminalPunit","doc":"The terminal object in `Type u` is `PUnit`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.isTerminalPunit\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">isTerminalPunit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.IsTerminal\">CategoryTheory.Limits.IsTerminal</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit.{u + 1}</a>     </span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L102-L103","name":"CategoryTheory.Limits.Types.terminalIso","line":102,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.terminalIso","doc":"The terminal object in `Type u` is `PUnit`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.terminalIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">terminalIso</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.terminal\">⊤_</a> <a href=\"./foundational_types.html\">Type</a> u</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit.{u + 1}</a>     </span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L88-L98","name":"CategoryTheory.Limits.Types.terminalLimitCone","line":88,"kind":"def","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.terminalLimitCone","doc":"The category of types has `PUnit` as a terminal object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.terminalLimitCone\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">terminalLimitCone</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.LimitCone\">CategoryTheory.Limits.LimitCone</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PEmpty.html#CategoryTheory.Functor.empty\">CategoryTheory.Functor.empty</a> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> u)</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L82-L84","name":"CategoryTheory.Limits.Types.pi_map_π_apply'","line":82,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pi_map_π_apply'","doc":"A restatement of `Types.Limit.map_π_apply` that uses `Pi.π` and `Pi.map`,\nwith specialized universes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pi_map_π_apply'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pi_map_π_apply'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(α : <span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">β</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">j</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.piObj\">∏</a> <span class=\"fn\">fun (<span class=\"fn\">b</span> : <span class=\"fn\">β</span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">b</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">g</span> <span class=\"fn\">b</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.map\">CategoryTheory.Limits.Pi.map</a> <span class=\"fn\">α</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">b</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">f</span> <span class=\"fn\">b</span> <span class=\"fn\">x</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L74-L77","name":"CategoryTheory.Limits.Types.pi_map_π_apply","line":74,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pi_map_π_apply","doc":"A restatement of `Types.Limit.map_π_apply` that uses `Pi.π` and `Pi.map`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pi_map_π_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pi_map_π_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{u, v}</a>    <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Type</a> u</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Type</a> u</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(α : <span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">β</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">j</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.piObj\">∏</a> <span class=\"fn\">fun (<span class=\"fn\">b</span> : <span class=\"fn\">β</span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">b</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">g</span> <span class=\"fn\">b</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.map\">CategoryTheory.Limits.Pi.map</a> <span class=\"fn\">α</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">b</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">f</span> <span class=\"fn\">b</span> <span class=\"fn\">x</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L66-L69","name":"CategoryTheory.Limits.Types.pi_lift_π_apply'","line":66,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pi_lift_π_apply'","doc":"A restatement of `Types.Limit.lift_π_apply` that uses `Pi.π` and `Pi.lift`,\nwith specialized universes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pi_lift_π_apply'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pi_lift_π_apply'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Type</a> v</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\">β</span>) → <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">b</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">P</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">f</span> <span class=\"fn\">b</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.lift\">CategoryTheory.Limits.Pi.lift</a> <span class=\"fn\">s</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">b</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L58-L61","name":"CategoryTheory.Limits.Types.pi_lift_π_apply","line":58,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pi_lift_π_apply","doc":"A restatement of `Types.Limit.lift_π_apply` that uses `Pi.π` and `Pi.lift`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.pi_lift_π_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">pi_lift_π_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{u, v}</a>    <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Type</a> u</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\">β</span>) → <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">b</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">P</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">f</span> <span class=\"fn\">b</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.lift\">CategoryTheory.Limits.Pi.lift</a> <span class=\"fn\">s</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">b</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/CategoryTheory/Limits/Shapes/Types.lean#L54-L54","name":"CategoryTheory.Limits.Types.instHasProductsTypeTypes","line":54,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instHasProductsTypeTypes","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.instHasProductsTypeTypes\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">Types</span>.<span class=\"name\">instHasProductsTypeTypes</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasProducts\">CategoryTheory.Limits.HasProducts</a> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> v)</a></span></div></div>"}]}