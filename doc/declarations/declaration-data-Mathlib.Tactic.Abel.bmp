{"name":"Mathlib.Tactic.Abel","instances":[{"typeNames":["Mathlib.Tactic.Abel.NormalExpr"],"name":"Mathlib.Tactic.Abel.instInhabitedNormalExpr","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.Abel.NormalExpr","Lean.Expr"],"name":"Mathlib.Tactic.Abel.instCoeNormalExprExpr","className":"Coe"}],"imports":["Init","Mathlib.Tactic.NormNum","Mathlib.Util.AtomM"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L559-L560","name":"Mathlib.Tactic.Abel.convAbel!","line":559,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!","doc":"The tactic `abel` evaluates expressions in abelian groups.\nThis is the conv tactic version, which rewrites a target which is an abel equality to `True`.\n\nSee also the `abel` tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">convAbel!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L557-L558","name":"Mathlib.Tactic.Abel.abelConv","line":557,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv","doc":"The tactic `abel` evaluates expressions in abelian groups.\nThis is the conv tactic version, which rewrites a target which is an abel equality to `True`.\n\nSee also the `abel` tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L548-L549","name":"Mathlib.Tactic.Abel.tacticAbel!","line":548,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!","doc":"Tactic for evaluating expressions in abelian groups.\n\n* `abel!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `abel1` fails if the target is not an equality.\n\nFor example:\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">tacticAbel!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L546-L547","name":"Mathlib.Tactic.Abel.abel","line":546,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel","doc":"Tactic for evaluating expressions in abelian groups.\n\n* `abel!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `abel1` fails if the target is not an equality.\n\nFor example:\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L532-L532","name":"Mathlib.Tactic.Abel.convAbel_nf!_","line":532,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">convAbel_nf!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L525-L530","name":"Mathlib.Tactic.Abel.elabAbelNFConv","line":525,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv","doc":"Elaborator for the `abel_nf` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">elabAbelNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L522-L522","name":"Mathlib.Tactic.Abel.abelNFConv","line":522,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L519-L520","name":"Mathlib.Tactic.Abel.tacticAbel_nf!__","line":519,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">tacticAbel_nf!__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L501-L517","name":"Mathlib.Tactic.Abel.abelNF","line":501,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L498-L499","name":"Mathlib.Tactic.Abel.abel!_term","line":498,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel!_term","doc":"Unsupported legacy syntax from mathlib3, which allowed passing additional terms to `abel!`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel!_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel!_term</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L496-L497","name":"Mathlib.Tactic.Abel.abel_term","line":496,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel_term","doc":"Unsupported legacy syntax from mathlib3, which allowed passing additional terms to `abel`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel_term</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L486-L494","name":"Mathlib.Tactic.Abel.abelNFLocalDecl","line":486,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFLocalDecl","doc":"Use `abel_nf` to rewrite hypothesis `h`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFLocalDecl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFLocalDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fvarId : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L474-L483","name":"Mathlib.Tactic.Abel.abelNFTarget","line":474,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFTarget","doc":"Use `abel_nf` to rewrite the main goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFTarget\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFTarget</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L469-L469","name":"Mathlib.Tactic.Abel.abelNFCore.evalAtom","line":469,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.evalAtom","doc":"The `evalAtom` implementation passed to `eval` calls `go` if `cfg.recursive` is true,\nand does nothing otherwise. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.evalAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFCore</span>.<span class=\"name\">evalAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context\">Lean.Meta.Simp.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(simp : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">Lean.Meta.SimpM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L453-L466","name":"Mathlib.Tactic.Abel.abelNFCore.go","line":453,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.go","doc":"The recursive case of `abelNF`.\n* `root`: true when the function is called directly from `abelNFCore`\n  and false when called by `evalAtom` in recursive mode.\n* `parent`: The input expression to simplify. In `pre` we make use of both `parent` and `e`\n  to determine if we are at the top level in order to prevent a loop\n  `go -> eval -> evalAtom -> go` which makes no progress.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFCore</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context\">Lean.Meta.Simp.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(simp : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">Lean.Meta.SimpM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(root : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(parent : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L433-L470","name":"Mathlib.Tactic.Abel.abelNFCore","line":433,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore","doc":"The core of `abel_nf`, which rewrites the expression `e` into `abel` normal form.\n\n* `s`: a reference to the mutable state of `abel`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `e`: the expression to rewrite\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L422-L423","name":"Mathlib.Tactic.Abel.elabAbelNFConfig","line":422,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig","doc":"Function elaborating `AbelNF.Config`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">elabAbelNFConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L420-L420","name":"Mathlib.Tactic.Abel.AbelNF.Config.mode","line":420,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mode","doc":"The normalization style. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mode</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">Mathlib.Tactic.Abel.AbelMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L418-L418","name":"Mathlib.Tactic.Abel.AbelNF.Config.recursive","line":418,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive","doc":"if true, atoms inside ring expressions will be reduced recursively "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">recursive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L416-L416","name":"Mathlib.Tactic.Abel.AbelNF.Config.red","line":416,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.red","doc":"the reducibility setting to use when comparing atoms for defeq "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.red\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">red</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L414-L414","name":"Mathlib.Tactic.Abel.AbelNF.Config.mk","line":414,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(red : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(recursive : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(mode : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">Mathlib.Tactic.Abel.AbelMode</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L414-L420","name":"Mathlib.Tactic.Abel.AbelNF.Config","line":414,"kind":"structure","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config","doc":"Configuration for `abel_nf`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L410-L411","name":"Mathlib.Tactic.Abel.AbelMode.raw","line":410,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.raw","doc":"Raw form: the representation `abel` uses internally. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span>.<span class=\"name\">raw</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">Mathlib.Tactic.Abel.AbelMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L408-L409","name":"Mathlib.Tactic.Abel.AbelMode.term","line":408,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.term","doc":"The default form "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span>.<span class=\"name\">term</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">Mathlib.Tactic.Abel.AbelMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L407-L411","name":"Mathlib.Tactic.Abel.AbelMode","line":407,"kind":"inductive","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode","doc":"The normalization style for `abel_nf`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L402-L404","name":"Mathlib.Tactic.Abel.NormalExpr.isAtom","line":402,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom","doc":"True if this represents an atomic expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">isAtom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L399-L399","name":"Mathlib.Tactic.Abel.termg_eq","line":399,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">termg_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Group/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L397-L397","name":"Mathlib.Tactic.Abel.term_eq","line":397,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Group/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L395-L395","name":"Mathlib.Tactic.Abel.abel1!","line":395,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!","doc":"Tactic for solving equations in the language of\n*additive*, commutative monoids and groups.\nThis version of `abel` fails if the target is not an equality\nthat is provable by the axioms of commutative monoids/groups.\n\n`abel1!` will use a more aggressive reducibility setting to identify atoms.\nThis can prove goals that `abel` cannot, but is more expensive.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel1!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L365-L373","name":"Mathlib.Tactic.Abel.abel1","line":365,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1","doc":"Tactic for solving equations in the language of\n*additive*, commutative monoids and groups.\nThis version of `abel` fails if the target is not an equality\nthat is provable by the axioms of commutative monoids/groups.\n\n`abel1!` will use a more aggressive reducibility setting to identify atoms.\nThis can prove goals that `abel` cannot, but is more expensive.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L320-L363","name":"Mathlib.Tactic.Abel.eval","line":320,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval","doc":"Evaluate an expression into its `abel` normal form, by recursing into subexpressions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">eval</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L298-L317","name":"Mathlib.Tactic.Abel.evalSMul'","line":298,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'","doc":"Normalize a term `orig` of the form `smul e₁ e₂` or `smulg e₁ e₂`.\nNormalized terms use `smul` for monoids and `smulg` for groups,\nso there are actually four cases to handle:\n* Using `smul` in a monoid just simplifies the pieces using `subst_into_smul`\n* Using `smulg` in a group just simplifies the pieces using `subst_into_smulg`\n* Using `smul a b` in a group requires converting `a` from a nat to an int and\n  then simplifying `smulg ↑a b` using `subst_into_smul_upcast`\n* Using `smulg` in a monoid is impossible (or at least out of scope),\n  because you need a group argument to write a `smulg` term "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalSMul'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(eval : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(is_smulg : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(orig : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e₁ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L285-L287","name":"Mathlib.Tactic.Abel.subst_into_negg","line":285,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_negg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ta : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pra : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">ta</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">ta</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L281-L283","name":"Mathlib.Tactic.Abel.subst_into_addg","line":281,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_addg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tl : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tr : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl : <span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prr : <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">tl</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L277-L279","name":"Mathlib.Tactic.Abel.subst_into_add","line":277,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tl : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tr : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl : <span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prr : <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">tl</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L272-L275","name":"Mathlib.Tactic.Abel.subst_into_smul_upcast","line":272,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smul_upcast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tl : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(zl : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tr : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl₁ : <span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl₂ : <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">tl</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">zl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prr : <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">zl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L268-L270","name":"Mathlib.Tactic.Abel.subst_into_smulg","line":268,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tl : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tr : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl : <span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prr : <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">tl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L264-L266","name":"Mathlib.Tactic.Abel.subst_into_smul","line":264,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tl : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tr : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl : <span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prr : <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">tl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L261-L262","name":"Mathlib.Tactic.Abel.unfold_zsmul","line":261,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_zsmul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Group/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L258-L259","name":"Mathlib.Tactic.Abel.unfold_smulg","line":258,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span></span>)</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Mathlib/Algebra/Group/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L255-L256","name":"Mathlib.Tactic.Abel.unfold_smul","line":255,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Group/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L252-L253","name":"Mathlib.Tactic.Abel.unfold_sub","line":252,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_sub</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#SubtractionMonoid\">SubtractionMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L244-L250","name":"Mathlib.Tactic.Abel.evalAtom","line":244,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom","doc":"Interpret an expression as an atom for `abel`'s normal form. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L240-L241","name":"Mathlib.Tactic.Abel.term_atom_pfg","line":240,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom_pfg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">1</span> <span class=\"fn\">x'</span> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L238-L239","name":"Mathlib.Tactic.Abel.term_atom_pf","line":238,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">1</span> <span class=\"fn\">x'</span> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L237-L237","name":"Mathlib.Tactic.Abel.term_atomg","line":237,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atomg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">1</span> <span class=\"fn\">x</span> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L236-L236","name":"Mathlib.Tactic.Abel.term_atom","line":236,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">1</span> <span class=\"fn\">x</span> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L228-L234","name":"Mathlib.Tactic.Abel.evalSMul","line":228,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul","doc":"Auxiliary function for `evalSMul'`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalSMul</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L220-L223","name":"Mathlib.Tactic.Abel.term_smulg","line":220,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n' : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L215-L218","name":"Mathlib.Tactic.Abel.term_smul","line":215,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n' : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">c</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">c</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L212-L213","name":"Mathlib.Tactic.Abel.zero_smulg","line":212,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L209-L210","name":"Mathlib.Tactic.Abel.zero_smul","line":209,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">c</span> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L207-L207","name":"Mathlib.Tactic.Abel.smulg","line":207,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg","doc":"A synonym for `•`, used internally in `abel`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L205-L205","name":"Mathlib.Tactic.Abel.smul","line":205,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul","doc":"A synonym for `•`, used internally in `abel`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L194-L202","name":"Mathlib.Tactic.Abel.evalNeg","line":194,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg","doc":"Interpret a negated expression in `abel`'s normal form.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalNeg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L187-L189","name":"Mathlib.Tactic.Abel.term_neg","line":187,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n' : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L162-L185","name":"Mathlib.Tactic.Abel.evalAdd","line":162,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd","doc":"Interpret the sum of two expressions in `abel`'s normal form.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalAdd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> →\n  <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L156-L157","name":"Mathlib.Tactic.Abel.zero_termg","line":156,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">0</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L153-L154","name":"Mathlib.Tactic.Abel.zero_term","line":153,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">0</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L147-L151","name":"Mathlib.Tactic.Abel.term_add_termg","line":147,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n₁ : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a₁ : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n₂ : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a₂ : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n' : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">n₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n₁</span> <span class=\"fn\">x</span> <span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n₂</span> <span class=\"fn\">x</span> <span class=\"fn\">a₂</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L143-L145","name":"Mathlib.Tactic.Abel.term_add_term","line":143,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n₁ : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a₁ : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n₂ : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a₂ : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n' : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">n₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n₁</span> <span class=\"fn\">x</span> <span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n₂</span> <span class=\"fn\">x</span> <span class=\"fn\">a₂</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L139-L141","name":"Mathlib.Tactic.Abel.term_add_constg","line":139,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_constg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L135-L137","name":"Mathlib.Tactic.Abel.term_add_const","line":135,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_const</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L131-L133","name":"Mathlib.Tactic.Abel.const_add_termg","line":131,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">const_add_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L127-L129","name":"Mathlib.Tactic.Abel.const_add_term","line":127,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">const_add_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L123-L123","name":"Mathlib.Tactic.Abel.NormalExpr.zero'","line":123,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'","doc":"Construct the normal form representing zero. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">zero'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L119-L120","name":"Mathlib.Tactic.Abel.NormalExpr.term'","line":119,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'","doc":"Construct the normal form representing a single term. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">term'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L116-L116","name":"Mathlib.Tactic.Abel.instCoeNormalExprExpr","line":116,"kind":"instance","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">instCoeNormalExprExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L112-L114","name":"Mathlib.Tactic.Abel.NormalExpr.e","line":112,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e","doc":"Extract the expression from a normal form. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">e</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L109-L109","name":"Mathlib.Tactic.Abel.instInhabitedNormalExpr","line":109,"kind":"instance","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">instInhabitedNormalExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L108-L108","name":"Mathlib.Tactic.Abel.NormalExpr.nterm","line":108,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">nterm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L107-L107","name":"Mathlib.Tactic.Abel.NormalExpr.zero","line":107,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">zero</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L106-L109","name":"Mathlib.Tactic.Abel.NormalExpr","line":106,"kind":"inductive","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr","doc":"A normal form for `abel`.\nExpressions are represented as a list of terms of the form `e = n • x`,\nwhere `n : ℤ` and `x` is an arbitrary element of the additive commutative monoid or group.\nWe explicitly track the `Expr` forms of `e` and `n`, even though they could be reconstructed,\nfor efficiency. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L98-L99","name":"Mathlib.Tactic.Abel.intToExpr","line":98,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr","doc":"Interpret an integer as a coefficient to a term. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">intToExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L95-L95","name":"Mathlib.Tactic.Abel.mkTerm","line":95,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm","doc":"Evaluate a term with coefficient `n`, atom `x` and successor terms `a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">mkTerm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L92-L92","name":"Mathlib.Tactic.Abel.termg","line":92,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L90-L90","name":"Mathlib.Tactic.Abel.term","line":90,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative monoid. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L85-L87","name":"Mathlib.Tactic.Abel.iapp","line":85,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp","doc":"Apply the function `n : ∀ {α} [AddComm{Monoid,Group} α]` to the given list of arguments.\n\nWill use the `AddComm{Monoid,Group}` instance that has been cached in the context.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">iapp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(xs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L77-L79","name":"Mathlib.Tactic.Abel.addG","line":77,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG","doc":"Add the letter \"g\" to the end of the name, e.g. turning `term` into `termg`.\n\nThis is used to choose between declarations taking `AddCommMonoid` and those\ntaking `AddCommGroup` instances.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">addG</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L69-L70","name":"Mathlib.Tactic.Abel.Context.mkApp","line":69,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp","doc":"Apply the function `n : ∀ {α} [inst α], _` to the implicit parameters in the\ncontext, and the given list of arguments.\n\nCompared to `context.app`, this takes the name of the typeclass, rather than an\ninferred typeclass instance.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">mkApp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inst : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L60-L61","name":"Mathlib.Tactic.Abel.Context.app","line":60,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app","doc":"Apply the function `n : ∀ {α} [inst : AddWhatever α], _` to the\nimplicit parameters in the context, and the given list of arguments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inst : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L56-L56","name":"Mathlib.Tactic.Abel.M","line":56,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M","doc":"The monad for `Abel` contains, in addition to the `AtomM` state,\nsome information about the current type we are working over, so that we can consistently\nuse group lemmas or monoid lemmas as appropriate. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">M</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L42-L51","name":"Mathlib.Tactic.Abel.mkContext","line":42,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext","doc":"Populate a `context` object for evaluating `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">mkContext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L39-L39","name":"Mathlib.Tactic.Abel.Context.inst","line":39,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.inst","doc":"The `AddCommGroup α` or `AddCommMonoid α` expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.inst\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">inst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L37-L37","name":"Mathlib.Tactic.Abel.Context.isGroup","line":37,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.isGroup","doc":"Specify whether we are in an additive commutative group or an additive commutative monoid. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.isGroup\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">isGroup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L35-L35","name":"Mathlib.Tactic.Abel.Context.α0","line":35,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α0","doc":"The expression representing `0 : α`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α0\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">α0</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L33-L33","name":"Mathlib.Tactic.Abel.Context.univ","line":33,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.univ","doc":"The universe level for `α`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.univ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">univ</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L31-L31","name":"Mathlib.Tactic.Abel.Context.α","line":31,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α","doc":"The type of the ambient additive commutative group or monoid. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">α</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L29-L29","name":"Mathlib.Tactic.Abel.Context.mk","line":29,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(univ : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(α0 : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(isGroup : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inst : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/eaede86aa7777630a3826cd8f3fbf0cbaafa53e6/Mathlib/Tactic/Abel.lean#L29-L39","name":"Mathlib.Tactic.Abel.Context","line":29,"kind":"structure","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context","doc":"The `Context` for a call to `abel`.\n\nStores a few options for this call, and caches some common subexpressions\nsuch as typeclass instances and `0 : α`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}